{"remainingRequest":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\OverviewPanel\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\OverviewPanel\\index.vue","mtime":1705377390803},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\babel-loader\\lib\\index.js","mtime":1688115046651},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js","mtime":1688115046800}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBkb210b2ltYWdlIGZyb20gJ2RvbS10by1pbWFnZSc7DQppbXBvcnQgVGVzdEpzb24gZnJvbSAiQC9hc3NldHMvanNvbi9jYXNlM19maW4uanNvbiI7DQppbXBvcnQgVGVzdFJlbEpzb24gZnJvbSAiQC9hc3NldHMvanNvbi9jYXNlM19maW5fcmVsLmpzb24iOw0KaW1wb3J0IHRvb2xzIGZyb20gIkAvdXRpbHMvdG9vbHMuanMiOw0KaW1wb3J0IHsgY29sb3IgfSBmcm9tICdkMyc7DQoNCmV4cG9ydCBkZWZhdWx0IHsNCiAgcHJvcHM6IFsidmlkZW9UaW1lIl0sDQogIGRhdGEoKSB7DQogICAgcmV0dXJuIHsNCiAgICAgIGRhdGE6IFRlc3RKc29uLC8vdGVzdCBpbiB0aGUgb25saW5lIGRlbW8NCiAgICAgIHJlbERhdGE6IFRlc3RSZWxKc29uLC8vdGVzdCBpbiB0aGUgb25saW5lIGRlbW8NCiAgICAgIGZhdGhlck1hcDoge30sDQogICAgICB0cmVlRGF0YTogW10sDQogICAgICBuYW1lVGV4dElkczogW10sDQogICAgICB0ZXh0RzogJycsDQogICAgICBjb2xvck1hcDoge30sDQogICAgICByb290Q29sb3JNYXA6IHt9LA0KICAgICAgb3ZlckVudGl0eUlkOiAiIiwNCiAgICAgIG1hcmdpbjogeyB0b3A6IDE1LCByaWdodDogNSwgYm90dG9tOiA1LCBsZWZ0OiA1IH0sDQogICAgICAvLyBtY29sb3I6IFsNCiAgICAgIC8vICAgInJnYigyNTUsNjAsNjApIiwNCiAgICAgIC8vICAgInJnYigxNTUsMjAsMTAwKSIsDQogICAgICAvLyAgICJyZ2IoMjU1LDgzLDI1NSkiLA0KICAgICAgLy8gICAicmdiKDIwMCwxMDAsNTApIiwNCiAgICAgIC8vICAgInJnYigyMzUsMTM1LDE2MikiLA0KICAgICAgLy8gICAicmdiKDIwMCwyMDAsMTAyKSIsDQogICAgICAvLyAgICJyZ2IoMjU1LDE3OCwxMDEpIiwNCiAgICAgIC8vICAgInJnYig2MywxNTEsMTM0KSIsDQogICAgICAvLyAgICJyZ2IoODMsMTU1LDI1NSkiLA0KICAgICAgLy8gICAicmdiKDUwLDIwMCwxMjApIiwNCiAgICAgIC8vICAgInJnYigyLDUwLDIwMCkiLA0KICAgICAgLy8gICAicmdiKDAsMTIyLDI0NCkiLA0KICAgICAgLy8gICAicmdiKDE1MCwxMjIsMjQ0KSIsDQogICAgICAvLyAgICJyZ2IoMTY4LDE2OCwyNTUpIiwNCiAgICAgIC8vICAgInJnYigyMDAsMjAwLDIwMCkiLA0KICAgICAgLy8gXSwNCiAgICAgIG1jb2xvcjogWw0KICAgICAgICAicmdiKDkxLCAxMDcsIDI1NSkiLA0KICAgICAgICAicmdiKDYsIDIxNCwgMTYwKSIsDQogICAgICAgICJyZ2IoMjU1LCAxMjAsIDkwKSIsDQogICAgICAgICJyZ2IoMTI1LCA5OCwgMjExKSIsDQogICAgICAgICJyZ2IoMjU1LCAxMTMsIDIxMikiLA0KICAgICAgICAicmdiKDExMiwgMjE0LCAyNTUpIiwNCiAgICAgICAgInJnYigyNTUsIDE1OSwgMjgpIiwNCiAgICAgICAgInJnYigyNTUsIDc3LCAxMDkpIiwNCiAgICAgIF0sDQogICAgICBtTGlnaHRjb2xvcjogWw0KICAgICAgICAiI2ZmOWM5YyIsDQogICAgICAgICIjY2M4OGIwIiwNCiAgICAgICAgIiNmZmE4ZmYiLA0KICAgICAgICAiI2UzYjA5NyIsDQogICAgICAgICIjZjRjM2QwIiwNCiAgICAgICAgIiNmNGY0ZDAiLA0KICAgICAgICAiI2ZmZDhiMSIsDQogICAgICAgICIjOWVjYWMyIiwNCiAgICAgICAgIiNhOGNjZmYiLA0KICAgICAgICAiIzk3ZTNiYSIsDQogICAgICAgICIjNmY4YmUwIiwNCiAgICAgICAgInJnYigwLDEyMiwyNDQpIiwNCiAgICAgICAgIiNiNmEyZjciLA0KICAgICAgICAicmdiKDE2OCwxNjgsMjU1KSIsDQogICAgICAgICJyZ2IoMjAwLDIwMCwyMDApIiwNCiAgICAgIF0sDQogICAgfTsNCiAgfSwNCiAgd2F0Y2g6IHsNCiAgICB0eXBlKHZhbCkgew0KICAgIH0sDQogICAgdHJlZURhdGEodmFsKSB7DQogICAgICB0aGlzLmRyYXdvdmVyVmlldygpOw0KICAgIH0sDQogICAgb3ZlckVudGl0eUlkKHZhbCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KDQogICAgICBpZiAodmFsICE9ICcnKSB7DQogICAgICAgIGxldCB0ZXh0SWQgPSB0b29scy5kZWVwQ2xvbmUodmFsKTsNCiAgICAgICAgaWYgKF90aGlzLm5hbWVUZXh0SWRzLmluZGV4T2YodGV4dElkKSA9PSAtMSkgew0KICAgICAgICAgIHdoaWxlICh0ZXh0SWQgIT0gJ3Jvb3QnKSB7DQogICAgICAgICAgICBfdGhpcy5uYW1lVGV4dElkcy5wdXNoKHRleHRJZCk7DQogICAgICAgICAgICB0ZXh0SWQgPSBfdGhpcy5mYXRoZXJNYXBbdGV4dElkXTsNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KICAgICAgICBfdGhpcy5uYW1lVGV4dElkcyA9IFtdDQogICAgICB9DQoNCiAgICB9LA0KICAgIG5hbWVUZXh0SWRzKGlkcykgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IHR4ID0gNTA7DQogICAgICBsZXQgdHkgPSA2MDA7DQogICAgICBsZXQgY29sb3JNYXAgPSB0aGlzLmNvbG9yTWFwOw0KICAgICAgX3RoaXMudGV4dFBhdGhHLnNlbGVjdCgiZyIpLnJlbW92ZSgpOw0KICAgICAgbGV0IGcgPSBfdGhpcy50ZXh0UGF0aEcuYXBwZW5kKCJnIik7DQogICAgICBkMy5zZWxlY3RBbGwoYC5jdXJPdmVyQXJjYCkuc3R5bGUoImZpbHRlciIsICJ1cmwoKSIpDQogICAgICBmb3IgKGxldCBpID0gaWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7DQogICAgICBkMy5zZWxlY3RBbGwoYC5uYV8ke2lkc1tpXX1gKS5zdHlsZSgiZmlsdGVyIiwgInVybCgjY29vbFNoYWRvdykiKQ0KICAgICAgICBsZXQgY3VyZCA9IGRhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBpZHNbaV07IH0pOw0KICAgICAgICBsZXQgbmFtZSA9IGN1cmRbJ25hbWUnXS5zcGxpdCgiXyIpWzBdOw0KICAgICAgICBsZXQgbmFtZVMgPSBuYW1lLnNwbGl0KCIgIikNCiAgICAgICAgaWYobmFtZVMubGVuZ3RoPjQpew0KICAgICAgICAgIG5hbWUgPSBuYW1lUy5zcGxpY2UoMCw0KS5qb2luKCIgIikrIiAuLi4iDQoNCiAgICAgICAgfQ0KICAgICAgICBsZXQgdyA9IG5hbWUubGVuZ3RoICogMTA7DQogICAgICAgIGxldCBoID0gNDsNCiAgICAgICAgbGV0IHJ4ID0gNTsNCiAgICAgICAgbGV0IHJ5ID0gNTsNCiAgICAgICAgbGV0IGNvbG9yID0gY29sb3JNYXBbaWRzW2ldXTsNCiAgICAgICAgX3RoaXMuZHJhd1JlY3QoZywgdHgsIHR5ICsgNSwgdywgaCwgcngsIHJ5LCBjb2xvciwgMC41LCBjb2xvcikNCiAgICAgICAgX3RoaXMuZHJhd1R4dChnLCB0eCwgdHksIG5hbWUsICJyZ2IoNjAsNjAsNjApIiwgMCwgInN0YXJ0IiwgMTgpOw0KICAgICAgICB0eCArPSBuYW1lLmxlbmd0aCAqIDEyOw0KICAgICAgICBpZiAodHggPiA5MDApIHsNCiAgICAgICAgICB0eCA9IDEwOw0KICAgICAgICAgIHR5ICs9IDMwOw0KICAgICAgICB9DQogICAgICB9DQogICAgfSwNCiAgICBkYXRhKHZhbCkgew0KICAgIH0NCiAgfSwNCiAgbWV0aG9kczogew0KICAgIGNsaWNrX0VudCh0aW1lKSB7DQogICAgICB0aGlzLiRlbWl0KCJ0aW1lRHVyIiwgdGltZSk7DQogICAgfSwNCiAgICBkcmF3b3ZlclZpZXcoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBjb25zdCBtYXJnaW4gPSBfdGhpcy5tYXJnaW47DQogICAgICBsZXQgZGF0YSA9IF90aGlzLnRyZWVEYXRhOw0KICAgICAgbGV0IHdpZHRoID0gdGhpcy4kcmVmcy5vdmVydmlld1BhbmVsRGl2Lm9mZnNldFdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7DQogICAgICBsZXQgaGVpZ2h0ID0gdGhpcy4kcmVmcy5vdmVydmlld1BhbmVsRGl2Lm9mZnNldEhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tOw0KDQogICAgICAvLyB2YXIgdHJlZSA9IGQzLnRyZWUoKQ0KICAgICAgLy8gICAuc2l6ZShbd2lkdGgsIGhlaWdodCAtIDIwMF0pOw0KICAgICAgZDMuc2VsZWN0KCIjb3ZlcnZpZXdQYW5lbERpdiIpLnNlbGVjdCgic3ZnIikucmVtb3ZlKCk7DQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjb3ZlcnZpZXdQYW5lbERpdiIpLmFwcGVuZCgic3ZnIikNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKDUsMTApIik7DQogICAgICBsZXQgc3VuVHJlZUcgPSBzdmcuYXBwZW5kKCdnJykNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHJpdmVyRyA9IHN2Zy5hcHBlbmQoJ2cnKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCArIDIwKQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KQ0KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgzNSw2MDApIik7DQogICAgICBsZXQgdGV4dEcgPSBzdmcuYXBwZW5kKCdnJykNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHRleHRQYXRoRyA9IHN2Zy5hcHBlbmQoJ2cnKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgdG9vbFRpcEcgPSBzdmcuYXBwZW5kKCdnJykNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICB2YXIgZGVmcyA9IHN2Zy5hcHBlbmQoImRlZnMiKTsNCg0KICAgICAgdmFyIGZpbHRlciA9IGRlZnMNCiAgICAgICAgLmFwcGVuZCgiZmlsdGVyIikNCiAgICAgICAgLmF0dHIoImlkIiwgImNvb2xTaGFkb3ciKQ0KICAgICAgICAuYXR0cigieCIsICItMTAwJSIpDQogICAgICAgIC5hdHRyKCJ5IiwgIi0xMDAlIikgLy8NCiAgICAgICAgLmF0dHIoIndpZHRoIiwgIjMwMCUiKQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgIjMwMCUiKTsgLy8NCg0KICAgICAgZmlsdGVyDQogICAgICAgIC5hcHBlbmQoImZlTW9ycGhvbG9neSIpDQogICAgICAgIC5hdHRyKCJpbiIsICJTb3VyY2VHcmFwaGljIikNCiAgICAgICAgLmF0dHIoInJlc3VsdCIsICJ1cHBlckxheWVyIikNCiAgICAgICAgLmF0dHIoIm9wZXJhdG9yIiwgImRpbGF0ZSIpDQogICAgICAgIC5hdHRyKCJyYWRpdXMiLCAiMC4yIDAuMiIpOw0KDQogICAgICBmaWx0ZXINCiAgICAgICAgLmFwcGVuZCgiZmVNb3JwaG9sb2d5IikNCiAgICAgICAgLmF0dHIoImluIiwgIlNvdXJjZUFscGhhIikNCiAgICAgICAgLmF0dHIoInJlc3VsdCIsICJlbmxhcmdlZEFscGhhIikNCiAgICAgICAgLmF0dHIoIm9wZXJhdG9yIiwgImRpbGF0ZSIpDQogICAgICAgIC5hdHRyKCJyYWRpdXMiLCAiMC4yIDAuMiIpOw0KDQogICAgICBmaWx0ZXINCiAgICAgICAgLmFwcGVuZCgiZmVHYXVzc2lhbkJsdXIiKQ0KICAgICAgICAuYXR0cigiaW4iLCAiZW5sYXJnZWRBbHBoYSIpDQogICAgICAgIC5hdHRyKCJyZXN1bHQiLCAiYmx1cmVkQWxwaGEiKQ0KICAgICAgICAuYXR0cigic3RkRGV2aWF0aW9uIiwgIjMiKTsNCg0KICAgICAgZmlsdGVyDQogICAgICAgIC5hcHBlbmQoImZlT2Zmc2V0IikNCiAgICAgICAgLmF0dHIoImluIiwgImJsdXJlZEFscGhhIikNCiAgICAgICAgLmF0dHIoInJlc3VsdCIsICJsb3dlckxheWVyIikNCiAgICAgICAgLmF0dHIoImR5IiwgIjEiKTsgLy8NCg0KICAgICAgdmFyIGZlTWVyZ2UgPSBmaWx0ZXIuYXBwZW5kKCJmZU1lcmdlIik7DQogICAgICBmZU1lcmdlLmFwcGVuZCgiZmVNZXJnZU5vZGUiKS5hdHRyKCJpbiIsICJsb3dlckxheWVyIik7DQogICAgICBmZU1lcmdlLmFwcGVuZCgiZmVNZXJnZU5vZGUiKS5hdHRyKCJpbiIsICJ1cHBlckxheWVyIik7DQoNCiAgICAgIF90aGlzLnRleHRHID0gdGV4dEc7DQogICAgICBfdGhpcy50ZXh0UGF0aEcgPSB0ZXh0UGF0aEc7DQoNCiAgICAgIGxldCBjZW50ZXJYID0gbWFyZ2luLmxlZnQgKyAod2lkdGggLyAyKTsNCiAgICAgIGxldCBjZW50ZXJZID0gbWFyZ2luLnRvcCArIChoZWlnaHQgLyAyKSAtIDUwOw0KICAgICAgY29uc3QgZ0NpcmNsZSA9IHN2Zy5hcHBlbmQoImciKTsNCiAgICAgIC8vIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyBtYXJnaW4ubGVmdCArICIsIiArIG1hcmdpbi50b3AgKyAiKSIpDQogICAgICBsZXQgY3VyRCA9IHRvb2xzLmRlZXBDbG9uZShkYXRhKTsNCiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEsY3VyRCkNCiAgICAgIC8vIGN1ckRbJ2xheW91dCddID0gJy0xJzsNCg0KICAgICAgbGV0IGxheW91dCA9IC0xOw0KICAgICAgbGV0IHRvdGFsRHVyID0gMA0KICAgICAgZm9yIChsZXQgYyBpbiBkYXRhWydjaGlsZHJlbiddKSB7DQogICAgICAgIGlmIChkYXRhWydjaGlsZHJlbiddW2NdWyduYW1lJ10gIT0gJ1Rlc3QnKSB7DQogICAgICAgICAgdG90YWxEdXIgKz0gZGF0YVsnY2hpbGRyZW4nXVtjXVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgICB9DQogICAgICB9DQogICAgICBfdGhpcy5kcmF3U3VuVHJlZShzdW5UcmVlRywgY2VudGVyWCwgY2VudGVyWSwgY3VyRCwgbGF5b3V0LCB0b3RhbER1ciwgMCwgTWF0aC5QSSAqIDIsIDAsICIiLCAicm9vdCIpOw0KICAgICAgLy8gX3RoaXMuZHJhd1R5cGVSaXZlcihyaXZlckcpOw0KICAgIH0sDQogICAgZHJhd1R5cGVSaXZlcihzdmcpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBvcmlEYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCByZXNEYXRhID0gW107DQogICAgICBsZXQgdHJpTGkgPSBbXTsNCiAgICAgIGxldCBleGVMaSA9IFtdOw0KDQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaURhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IGN1ckVudCA9IG9yaURhdGFbaV07DQogICAgICAgIGxldCB0cCA9IHt9DQogICAgICAgIHRwWydvZCddID0gaTsNCiAgICAgICAgaWYgKChjdXJFbnRbJ3R5cGUnXSA9PSAiMSIpKSB7DQogICAgICAgICAgdHJpTGkucHVzaCh0cCk7DQogICAgICAgIH0NCiAgICAgICAgaWYgKGN1ckVudFsndHlwZSddID09ICIyIikgew0KICAgICAgICAgIGV4ZUxpLnB1c2godHApOw0KICAgICAgICB9DQogICAgICAgIGxldCB0eXBlRGF0YSA9IGN1ckVudFsiYXR0cmlidXRlIl1bImV4cHJlc3Npb25zIl07DQogICAgICAgIGxldCB0b3RhbER1ciA9IDA7DQoNCiAgICAgICAgZm9yIChsZXQgdCBpbiB0eXBlRGF0YSkgew0KICAgICAgICAgIC8vIGxldCBjb2xvciA9IHR5cGVDb2xvcltpXTsNCiAgICAgICAgICBsZXQgdHlwZUR1cml0aW9uID0gdHlwZURhdGFbdF07DQogICAgICAgICAgbGV0IHRvdGFsVHlwZVNlY29uZHMgPSAwOw0KICAgICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgICB0b3RhbFR5cGVTZWNvbmRzICs9ICh0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMF0pKQ0KICAgICAgICAgIH0NCiAgICAgICAgICB0b3RhbER1ciArPSB0b3RhbFR5cGVTZWNvbmRzOw0KICAgICAgICAgIHRwW3RdID0gdG90YWxUeXBlU2Vjb25kczsNCiAgICAgICAgfQ0KICAgICAgICBmb3IgKGxldCB0IGluIHRwKSB7DQogICAgICAgICAgaWYgKHQgIT0gJ29kJykgew0KICAgICAgICAgICAgdHBbdF0gLz0gdG90YWxEdXI7DQogICAgICAgICAgICBpZiAodG90YWxEdXIgPT0gMCkgew0KICAgICAgICAgICAgICB0cFt0XSA9IDA7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIHJlc0RhdGEucHVzaCh0cCkNCiAgICAgIH0NCg0KICAgICAgbGV0IGRhdGEgPSByZXNEYXRhOw0KICAgICAgY29uc29sZS5sb2coZGF0YSkNCiAgICAgIHZhciBzdGFjayA9IGQzLnN0YWNrKCkNCiAgICAgICAgLmtleXMoWycxJywgJzInLCAnMyddKQ0KICAgICAgICAub3JkZXIoZDMuc3RhY2tPcmRlckluc2lkZU91dCkNCiAgICAgICAgLm9mZnNldChkMy5zdGFja09mZnNldFdpZ2dsZSk7DQoNCiAgICAgIGxldCB5UmFuZ2VXaWR0aCA9IDgwOw0KICAgICAgbGV0IHhTdGVwID0gKHN2Zy5hdHRyKCJ3aWR0aCIpIC0gODApIC8gb3JpRGF0YS5sZW5ndGg7DQogICAgICBsZXQgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWy0xLCAxXSkucmFuZ2UoWzAsIDgwXSk7DQogICAgICB2YXIgYXJlYSA9IGQzLmFyZWEoKQ0KICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAgICAgLngoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4gZC5kYXRhLm9kICogeFN0ZXA7DQogICAgICAgIH0pDQogICAgICAgIC55MChmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIHJldHVybiB5UmFuZ2VXaWR0aCAtIHlTY2FsZShkWzBdKTsNCiAgICAgICAgfSkNCiAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgcmV0dXJuIHlSYW5nZVdpZHRoIC0geVNjYWxlKGRbMV0pOw0KICAgICAgICB9KTsNCiAgICAgIGNvbnNvbGUubG9nKGRhdGEpDQogICAgICBsZXQgc3RhY2tEYXRhID0gc3RhY2soZGF0YSkNCiAgICAgIGNvbnNvbGUubG9nKGRhdGEsIHN0YWNrRGF0YSkNCiAgICAgIGxldCBsZW5UaHJlc2hvbGQgPSAwLjQ7DQogICAgICBsZXQgaWNvbkxpID0ge30NCiAgICAgIGZvciAobGV0IHMgaW4gc3RhY2tEYXRhKSB7DQogICAgICAgIGljb25MaVtzXSA9IFtdDQogICAgICAgIGZvciAobGV0IGkgaW4gc3RhY2tEYXRhW3NdKSB7DQogICAgICAgICAgbGV0IGxlbkFyZWEgPSBzdGFja0RhdGFbc11baV0NCiAgICAgICAgICBpZiAoKGxlbkFyZWFbMV0gLSBsZW5BcmVhWzBdKSA+IDAuNCkgew0KICAgICAgICAgICAgaWNvbkxpW3NdLnB1c2goW2ksIGxlbkFyZWFdKTsNCiAgICAgICAgICB9DQogICAgICAgICAgZm9yIChsZXQgbGkgaW4gaWNvbkxpW3NdKSB7DQogICAgICAgICAgICBpZiAoaSA8IChpY29uTGlbc11bbGldWzBdICsgMikpIHsNCiAgICAgICAgICAgICAgbGV0IHNlbGVjdEFyZWEgPSBpY29uTGlbc11bbGldWzFdDQogICAgICAgICAgICAgIGlmICgoKHNlbGVjdEFyZWFbMV0gLSBsZW5BcmVhWzFdKSAtIChzZWxlY3RBcmVhWzBdIC0gbGVuQXJlYVswXSkpIDwgMC4yKSB7DQogICAgICAgICAgICAgICAgaWNvbkxpW3NdLnNwbGljZShzLCAxKTsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgLy8gbGV0IGFyZWFHID0gc3ZnLmFwcGVuZCgiZyIpDQogICAgICBsZXQgdHlwZUNvbG9yID0gew0KICAgICAgICAiMSI6ICIjZmY5YzljIiwNCiAgICAgICAgIjIiOiAiI2Y0ZjRkMCIsDQogICAgICAgICIzIjogIiM2ZjhiZTAiLA0KICAgICAgfTsNCiAgICAgIGxldCBjb2xvckxpID0gX3RoaXMubWNvbG9yOw0KICAgICAgc3ZnLnNlbGVjdEFsbCgicGF0aCIpDQogICAgICAgIC5kYXRhKHN0YWNrRGF0YSkNCiAgICAgICAgLmpvaW4oInBhdGgiKQ0KICAgICAgICAuYXR0cigiaWQiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5rZXkgfSkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgInJpdmVyIikNCiAgICAgICAgLmF0dHIoImQiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIHJldHVybiBhcmVhKGQpDQogICAgICAgIH0pDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZnVuY3Rpb24gKGQsIGkpIHsNCiAgICAgICAgICByZXR1cm4gdHlwZUNvbG9yW2Qua2V5XQ0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlb3ZlciIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0QWxsKCIucml2ZXIiKS5zdHlsZSgiZmlsdGVyIiwgInVybCgpIikNCiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoImZpbHRlciIsICJ1cmwoI2Nvb2xTaGFkb3cpIikNCiAgICAgICAgfSkNCg0KICAgICAgZm9yIChsZXQgdCBpbiB0cmlMaSkgew0KICAgICAgICBsZXQgYXJlYSA9IHRvb2xzLmNhbGNUcmlhbmdsZSgodHJpTGlbdF1bJ29kJ10pICogeFN0ZXAsIC0zMCwgMTQpOw0KICAgICAgICBfdGhpcy5kcmF3VHJpYW5nbGUoc3ZnLCAicmdiKDI1MCwgMTk5LCA4OCkiLCBhcmVhLCAicmdiKDI1MCwgMTk5LCA4OCkiKTsNCiAgICAgICAgX3RoaXMuZHJhd1R4dChzdmcsICh0cmlMaVt0XVsnb2QnXSkgKiB4U3RlcCwgLTIzLCAiVCIsICJ3aGl0ZSIsIDAsICJtaWRkbGUiLCAxOCkNCiAgICAgIH0NCiAgICAgIGZvciAobGV0IHQgaW4gZXhlTGkpIHsNCiAgICAgICAgbGV0IGFyZWEgPSB0b29scy5jYWxjVHJpYW5nbGUoKGV4ZUxpW3RdWydvZCddKSAqIHhTdGVwLCAtMzAsIDE0KTsNCiAgICAgICAgX3RoaXMuZHJhd1RyaWFuZ2xlKHN2ZywgInJnYigyNTAsIDE5OSwgODgpIiwgYXJlYSwgInJnYigyNTAsIDE5OSwgODgpIik7DQogICAgICAgIF90aGlzLmRyYXdUeHQoc3ZnLCAoZXhlTGlbdF1bJ29kJ10pICogeFN0ZXAsIC0yMywgIkUiLCAid2hpdGUiLCAwLCAibWlkZGxlIiwgMTgpDQogICAgICB9DQogICAgfSwNCiAgICBkcmF3VHJpYW5nbGUoc3ZnLCBjb2xvciwgcG9pbnRzLCBzdHJva2UsIG9wYWNpdHkgPSAxKSB7DQogICAgICBzdmcuYXBwZW5kKCJwb2x5Z29uIikNCiAgICAgICAgLmF0dHIoInBvaW50cyIsIHBvaW50cykNCiAgICAgICAgLmF0dHIoImZpbGwiLCBjb2xvcikNCiAgICAgICAgLmF0dHIoInN0cm9rZS1saW5lam9pbiIsICJyb3VuZCIpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsICI1cHgiKTsNCiAgICB9LA0KICAgIGRyYXdTdW5UcmVlKHN2ZywgeCwgeSwgZGF0YSwgbGF5b3V0LCB0b3RhbER1ciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHN0YXJ0SGVpZ2h0LCBjdXJjb2xvciwgZmF0aGVyKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICAvLyB0b3RhbER1cis9MTUNCiAgICAgIHZhciBjdXJTdGFydFIgPSB0b29scy5kZWVwQ2xvbmUoc3RhcnRBbmdsZSk7Ly9NYXRoLlBJLzQ7DQogICAgICBsZXQgY29sb3JMaXN0ID0gdGhpcy5tY29sb3I7DQogICAgICBsZXQgc3RlcExheUhpZ2h0ID0gMTAwOw0KICAgICAgaWYgKGxheW91dCA9PSAnLTEnKSB7DQogICAgICAgIC8vIHN0ZXBMYXlIaWdodCA9IDQwMDsvL2MzDQogICAgICAgIHN0ZXBMYXlIaWdodCA9IDQ1MDsvL2M1DQogICAgICB9DQogICAgICBpZiAobGF5b3V0ID09ICcwJykgew0KICAgICAgICAvLyBzdGVwTGF5SGlnaHQgPSA4MDsvL2MzDQogICAgICAgIHN0ZXBMYXlIaWdodCA9IDEyMDsvL2M1DQogICAgICB9DQogICAgICBpZiAobGF5b3V0ID09ICcxJykgew0KICAgICAgICAvLyBzdGVwTGF5SGlnaHQgPSAzMDsvL2MzDQogICAgICAgIHN0ZXBMYXlIaWdodCA9IDIwOy8vYzUNCiAgICAgICAgDQogICAgICB9DQogICAgICBpZiAobGF5b3V0ID09ICcyJykgew0KICAgICAgICBzdGVwTGF5SGlnaHQgPSAzMDsNCiAgICAgIH0NCiAgICAgIGlmIChsYXlvdXQgPT0gJzMnKSB7DQogICAgICAgIHN0ZXBMYXlIaWdodCA9IDE7DQogICAgICB9DQogICAgICBsZXQgZW5kSGVpZ2h0ID0gc3RhcnRIZWlnaHQgKyBzdGVwTGF5SGlnaHQ7DQogICAgICAvLyBjb25zb2xlLmxvZyhlbmRIZWlnaHQsbGF5b3V0LHN0ZXBMYXlIaWdodCkNCiAgICAgIGxldCBDb2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgdG90YWxEdXJdKS5yYW5nZShbMC4zLCAxXSk7DQogICAgICBsZXQgQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKCJ3aGl0ZSIsIGN1cmNvbG9yKTsNCiAgICAgIGxldCBwZXJEdXIgPSAwOw0KICAgICAgbGV0IGN1ckFyY1NjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCB0b3RhbER1cl0sIFtzdGFydEFuZ2xlLCBlbmRBbmdsZV0pOw0KICAgICAgbGV0IGN1ckhlaWdodFNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBNYXRoLnNxcnQodG90YWxEdXIpXSwgW3N0YXJ0SGVpZ2h0ICogMSwgZW5kSGVpZ2h0XSk7DQogICAgICBmb3IgKGxldCBjIGluIGRhdGFbJ2NoaWxkcmVuJ10pIHsNCiAgICAgICAgX3RoaXMuZmF0aGVyTWFwW2RhdGFbJ2NoaWxkcmVuJ11bY11bJ2lkJ11dID0gZmF0aGVyOw0KICAgICAgICBpZiAoKGRhdGFbJ2NoaWxkcmVuJ11bY11bJ25hbWUnXSAhPSAnVGVzdCcpIHx8IChkYXRhWydjaGlsZHJlbiddW2NdWydsYXlvdXQnXSAhPSAnMCcpKSB7DQogICAgICAgICAgbGV0IGN1clRvdGFsRHVyID0gZGF0YVsnY2hpbGRyZW4nXVtjXVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgICAgIC8vIGlmKGN1clRvdGFsRHVyPDIwKXtjdXJUb3RhbER1cj0yMH0NCiAgICAgICAgICBsZXQgZW5kQW5nbGV0ID0gY3VyQXJjU2NhbGVfbGluZWFyKHBlckR1ciArIGN1clRvdGFsRHVyKTsNCiAgICAgICAgICBwZXJEdXIgKz0gY3VyVG90YWxEdXINCiAgICAgICAgICB2YXIgZGF0YXNldCA9IHsgc3RhcnRBbmdsZTogY3VyU3RhcnRSICsgMC4wNSwgZW5kQW5nbGU6IGVuZEFuZ2xldCAtIDAuMDUgfTsNCiAgICAgICAgICBsZXQgaCA9ICgoY3VySGVpZ2h0U2NhbGVfbGluZWFyKChNYXRoLnNxcnQoY3VyVG90YWxEdXIpKSkpKTsNCiAgICAgICAgICBpZihoIC0gc3RhcnRIZWlnaHQgPjIwMCl7aD1zdGFydEhlaWdodCArIDE2MH0NCiAgICAgICAgICBpZihoIC0gc3RhcnRIZWlnaHQgPDMwKXtoPXN0YXJ0SGVpZ2h0ICszMH0NCiAgICAgICAgICBjb25zb2xlLmxvZyhsYXlvdXQpDQogICAgICAgICAgaWYobGF5b3V0ID09ICIyIil7aD1zdGFydEhlaWdodCArMjB9DQogICAgICAgICAgdmFyIGFyY1BhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgICAgLmlubmVyUmFkaXVzKHN0YXJ0SGVpZ2h0ICsgMTUpDQogICAgICAgICAgICAub3V0ZXJSYWRpdXMoaCkNCiAgICAgICAgICB2YXIgcGF0aEFyYyA9IGFyY1BhdGgoZGF0YXNldCk7DQogICAgICAgICAgbGV0IGNvbG9yID0gIiI7DQogICAgICAgICAgaWYgKGxheW91dCA9PSAtMSkgew0KICAgICAgICAgICAgY29sb3IgPSBfdGhpcy5yb290Q29sb3JNYXBbZGF0YVsnY2hpbGRyZW4nXVtjXVsnaWQnXV07Ly9jb2xvckxpc3RbY107DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgeyBjb2xvciA9IENvbXB1dGVfY29sb3IoQ29sb3JfbGluZWFyKGN1clRvdGFsRHVyKSkgfQ0KICAgICAgICAgIF90aGlzLmNvbG9yTWFwW2RhdGFbJ2NoaWxkcmVuJ11bY11bJ2lkJ11dID0gY29sb3I7DQogICAgICAgICAgX3RoaXMuZHJhd0FyYyhzdmcsIHgsIHksIHBhdGhBcmMsIGNvbG9yLCBjb2xvciwgYGN1ck92ZXJBcmMgZmFfJHtmYXRoZXJ9IG5hXyR7ZGF0YVsnY2hpbGRyZW4nXVtjXVsnaWQnXX1gLCAnMCcsIDEwKTsNCiAgICAgICAgICBfdGhpcy5kcmF3U3VuVHJlZShzdmcsIHgsIHksIGRhdGFbJ2NoaWxkcmVuJ11bY10sIGxheW91dCArIDEsIGN1clRvdGFsRHVyLCBkYXRhc2V0LnN0YXJ0QW5nbGUsIGRhdGFzZXQuZW5kQW5nbGUsIGgsIGNvbG9yLCBkYXRhWydjaGlsZHJlbiddW2NdWydpZCddKTsNCg0KICAgICAgICAgIGlmICgocGFyc2VJbnQobGF5b3V0KSA8IDEpKSB7DQogICAgICAgICAgICBsZXQgbmFtZSA9IGRhdGFbJ2NoaWxkcmVuJ11bY11bJ25hbWUnXTsNCg0KICAgICAgICAgICAgbGV0IG5hbWVzID0gbmFtZS5zcGxpdCgiICIpDQogICAgICAgICAgICBsZXQgbmFtZUxlbiA9IG5hbWVzLmxlbmd0aDsNCiAgICAgICAgICAgIGxldCBhbmNob3IgPSAiZW5kIg0KICAgICAgICAgICAgbGV0IHN0ZXBSID0gKGVuZEFuZ2xldCAtIGN1clN0YXJ0UikgLyAobmFtZUxlbiArIDEpOw0KICAgICAgICAgICAgbGV0IGNvbG9yViA9IHRvb2xzLmdldFJnYlZhbHVlKGNvbG9yKQ0KICAgICAgICAgICAgbGV0IHRleHRDb2xvciA9ICd3aGl0ZSc7DQogICAgICAgICAgICBsZXQgdGV4dFN0YXJ0UiA9IGN1clN0YXJ0UjsNCiAgICAgICAgICAgIGxldCB2ID0gMDsNCiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gY29sb3JWKSB7DQogICAgICAgICAgICAgIHYgKz0gcGFyc2VJbnQoY29sb3JWW2ldKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICh2ID4gNjIwKSB7DQogICAgICAgICAgICAgIHRleHRDb2xvciA9ICdncmV5JzsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICgocGFyc2VJbnQobGF5b3V0KSA9PSAtMSkgJiYgKChlbmRBbmdsZXQgLSBjdXJTdGFydFIpID4gKE1hdGguUEkgLyA1KSkpIHsNCiAgICAgICAgICAgICAgaWYgKChlbmRBbmdsZXQgLSBjdXJTdGFydFIpID4gKE1hdGguUEkgLyA0KSkgew0KICAgICAgICAgICAgICAgIHN0ZXBSID0gTWF0aC5QSSAvIDIwOw0KICAgICAgICAgICAgICAgIHRleHRTdGFydFIgPSAoZW5kQW5nbGV0ICsgY3VyU3RhcnRSKSAvIDIgLSAobmFtZUxlbikgLyAyICogc3RlcFI7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBuYW1lTGVuOyBuKyspIHsNCiAgICAgICAgICAgICAgICBsZXQgbm4gPSBuOw0KICAgICAgICAgICAgICAgIGxldCBhcmNTY2FsZSA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBNYXRoLlBJICogMl0pLnJhbmdlKFswLCAzNjBdKTsNCiAgICAgICAgICAgICAgICBpZiAoYXJjU2NhbGUoY3VyU3RhcnRSKSA+IDE4MCkgew0KICAgICAgICAgICAgICAgICAgbm4gPSBuYW1lTGVuIC0gbiAtIDE7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGxldCBtaWRSID0gdGV4dFN0YXJ0UiArIHN0ZXBSICogKG5uICsgMSk7DQoNCiAgICAgICAgICAgICAgICBsZXQgcm9hdCA9IGFyY1NjYWxlKG1pZFIpOw0KICAgICAgICAgICAgICAgIHJvYXQgLT0gOTA7DQogICAgICAgICAgICAgICAgaWYgKHJvYXQgPiA5MCkgew0KICAgICAgICAgICAgICAgICAgcm9hdCArPSAxODA7DQogICAgICAgICAgICAgICAgICBhbmNob3IgPSAic3RhcnQiDQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIC8vIGggPSAoaCArIHN0YXJ0SGVpZ2h0KSAvIDIgKyAxMDsNCiAgICAgICAgICAgICAgICBsZXQgdHggPSB4ICsgaCAqIE1hdGguc2luKG1pZFIpOw0KICAgICAgICAgICAgICAgIGxldCB0eSA9IHkgLSBoICogTWF0aC5jb3MobWlkUik7DQogICAgICAgICAgICAgICAgX3RoaXMuZHJhd1R4dChfdGhpcy50ZXh0RywgdHgsIHR5LCBuYW1lc1tuXSwgdGV4dENvbG9yLCByb2F0LCBhbmNob3IpDQoNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICBlbHNlIGlmICgocGFyc2VJbnQobGF5b3V0KSA9PSAwKSAmJiAoKGVuZEFuZ2xldCAtIGN1clN0YXJ0UikgPiAoTWF0aC5QSSAvIDE1KSkgJiYgKG5hbWVMZW4gPCA0KSAmJiAobmFtZS5sZW5ndGggPCAxMCkpIHsNCiAgICAgICAgICAgICAgbGV0IHN0ZXBoID0gKGggLSBzdGFydEhlaWdodCAtIDIwKSAvIG5hbWVMZW47DQogICAgICAgICAgICAgIGFuY2hvciA9ICJtaWRkbGUiDQogICAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbmFtZUxlbjsgbisrKSB7DQogICAgICAgICAgICAgICAgbGV0IG5uID0gbjsNCiAgICAgICAgICAgICAgICBsZXQgYXJjU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgTWF0aC5QSSAqIDJdKS5yYW5nZShbMCwgMzYwXSk7DQogICAgICAgICAgICAgICAgLy8gaWYoYXJjU2NhbGUoY3VyU3RhcnRSKT4xODApew0KICAgICAgICAgICAgICAgIC8vICAgbm4gPSBuYW1lTGVuIC0gbi0xOw0KICAgICAgICAgICAgICAgIC8vIH0NCiAgICAgICAgICAgICAgICBsZXQgbWlkUiA9IChlbmRBbmdsZXQgKyBjdXJTdGFydFIpIC8gMjsNCg0KICAgICAgICAgICAgICAgIGxldCByb2F0ID0gYXJjU2NhbGUobWlkUik7DQogICAgICAgICAgICAgICAgLy8gcm9hdCAtPSA5MDsNCiAgICAgICAgICAgICAgICAvLyBpZihyb2F0PjkwKXsNCiAgICAgICAgICAgICAgICAvLyAgIHJvYXQrPTE4MDsNCiAgICAgICAgICAgICAgICAvLyAgIGFuY2hvciA9ICJzdGFydCINCiAgICAgICAgICAgICAgICAvLyB9DQogICAgICAgICAgICAgICAgaCA9IGggLSAxMCAtIDEgKiBuOy8vKGggKyBzdGFydEhlaWdodCkgLyAyICsgMTA7DQogICAgICAgICAgICAgICAgbGV0IHR4ID0geCArIGggKiBNYXRoLnNpbihtaWRSKTsNCiAgICAgICAgICAgICAgICBsZXQgdHkgPSB5IC0gaCAqIE1hdGguY29zKG1pZFIpOw0KICAgICAgICAgICAgICAgIF90aGlzLmRyYXdUeHQoX3RoaXMudGV4dEcsIHR4LCB0eSwgbmFtZXNbbl0sIHRleHRDb2xvciwgcm9hdCwgYW5jaG9yKQ0KDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlSW50KGxheW91dCkgPT0gMSkgew0KICAgICAgICAgICAgICBsZXQgbWlkUiA9IChlbmRBbmdsZXQgKyBjdXJTdGFydFIpIC8gMjsNCg0KICAgICAgICAgICAgICBsZXQgYXJjU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgTWF0aC5QSSAqIDJdKS5yYW5nZShbMCwgMzYwXSk7DQogICAgICAgICAgICAgIGxldCByb2F0ID0gYXJjU2NhbGUobWlkUikNCiAgICAgICAgICAgICAgaWYgKGxheW91dCA9PSAnLTEnKSB7DQogICAgICAgICAgICAgICAgcm9hdCArPSA5MDsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBoID0gKGggKyBzdGFydEhlaWdodCkgLyAyICsgMTA7DQogICAgICAgICAgICAgIGxldCB0eCA9IHggKyBoICogTWF0aC5zaW4obWlkUik7DQogICAgICAgICAgICAgIGxldCB0eSA9IHkgLSBoICogTWF0aC5jb3MobWlkUik7DQogICAgICAgICAgICAgIC8vIGlmIChsYXlvdXQgIT0gJy0xJykgew0KICAgICAgICAgICAgICAvLyAgIGZvcihsZXQgdyA9IDA7dzxuYW1lcy5sZW5ndGg7dysrKXsNCiAgICAgICAgICAgICAgLy8gICAgIGgtPSh3KzEpKjE7DQogICAgICAgICAgICAgIC8vICAgICB0eCA9IHggKyBoICogTWF0aC5zaW4obWlkUik7DQogICAgICAgICAgICAgIC8vICAgICB0eSA9IHkgLSBoICogTWF0aC5jb3MobWlkUik7DQogICAgICAgICAgICAgIC8vICAgICBfdGhpcy5kcmF3VHh0KF90aGlzLnRleHRHLCB0eCx0eSAsIG5hbWVzW3ddLCB0ZXh0Q29sb3IsIHJvYXQsIm1pZGRsZSIpDQoNCiAgICAgICAgICAgICAgLy8gICAgIH0NCiAgICAgICAgICAgICAgLy8gfQ0KICAgICAgICAgICAgICAvLyBlbHNlew0KICAgICAgICAgICAgICBfdGhpcy5kcmF3VHh0KF90aGlzLnRleHRHLCB0eCwgdHksIGRhdGFbJ2NoaWxkcmVuJ11bY11bJ25hbWUnXSwgdGV4dENvbG9yLCByb2F0LCAibWlkZGxlIikNCiAgICAgICAgICAgICAgLy8gfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCg0KICAgICAgICAgIGN1clN0YXJ0UiA9IGVuZEFuZ2xldDsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0sDQogICAgZHJhd1JlY3Qoc3ZnLCB4LCB5LCB3LCBoLCByeCwgcnksIGZpbGwsIG9wYWNpdHksIHN0cm9rZSkgew0KICAgICAgc3ZnLmFwcGVuZCgicmVjdCIpDQogICAgICAgIC5hdHRyKCJ4IiwgeCkNCiAgICAgICAgLmF0dHIoInkiLCB5KQ0KICAgICAgICAuYXR0cigicngiLCByeCkNCiAgICAgICAgLmF0dHIoInJ5IiwgcnkpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3KQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsICIxLjVweCIpOw0KICAgIH0sDQogICAgZHJhd1R4dChzdmcsIHR4LCB0eSwgdHh0cywgZmlsbCwgcm9hdCwgYW5jaG9yLCBmb250c2l6ZSA9IDE0KSB7DQogICAgICBzdmcuYXBwZW5kKCJ0ZXh0IikNCiAgICAgICAgLmF0dHIoInkiLCB0eSkNCiAgICAgICAgLmF0dHIoIngiLCB0eCkNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgICAgICAuYXR0cigiZm9udC1zaXplIiwgZm9udHNpemUpDQogICAgICAgIC50ZXh0KHR4dHMpDQogICAgICAgIC5zdHlsZSgidGV4dC1hbmNob3IiLCBhbmNob3IpLy8ibWlkZGxlIikNCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGByb3RhdGUoJHtyb2F0fSAke3R4fSAke3R5fSlgKTsNCiAgICB9LA0KICAgIGRyYXdBcmMoc3ZnLCB4LCB5LCBhcmNQYXRoLCBzdHJva2UsIGZpbGwsIGNsYXNzTmFtZSwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgd2lkdGggPSAzKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBzdmcuYXBwZW5kKCJwYXRoIikNCiAgICAgICAgLmF0dHIoImQiLCBhcmNQYXRoKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyB4ICsgIiwiICsgeSArICIpIikNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIDEpDQogICAgICAgIC5hdHRyKCJzdHJva2UtZGFzaGFycmF5Iiwgc3Ryb2tlX2Rhc2hhcnJheSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1saW5lam9pbiIsICJyb3VuZCIpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgLm9uKCJtb3VzZW1vdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCB0cmFuc2Zvcm1kID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoInRyYW5zZm9ybSIpDQogICAgICAgICAgbGV0IGlkID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIikuc3BsaXQoIiAiKVtkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiKS5zcGxpdCgiICIpLmxlbmd0aCAtIDFdOw0KICAgICAgICAgIGlkID0gaWQuc3BsaXQoIl8iKVsxXQ0KICAgICAgICAgIGxldCBjdXJFbnQgPSBfdGhpcy5kYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gaWQgfSkNCg0KDQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpDQogICAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWQuc3BsaXQoIiAiKVswXSArICIgc2NhbGUoMS4wNCkiDQogICAgICAgICAgICB9KQ0KICAgICAgICAgIC8vIHZhciB0cmFuc2Zvcm0gPSBkMy5ldmVudDsNCiAgICAgICAgICB2YXIgeVBvc2l0aW9uID0gZC5jbGllbnRZICsgMjA7DQogICAgICAgICAgdmFyIHhQb3NpdGlvbiA9IGQuY2xpZW50WCArIDIwOw0KICAgICAgICAgIHZhciBjaGFydFRvb2x0aXAgPSBkMw0KICAgICAgICAgICAgLnNlbGVjdCgiLmNoYXJ0VG9vbHRpcCIpDQogICAgICAgICAgICAuc3R5bGUoImxlZnQiLCB4UG9zaXRpb24gKyAicHgiKQ0KICAgICAgICAgICAgLnN0eWxlKCJ0b3AiLCB5UG9zaXRpb24gKyAicHgiKTsNCiAgICAgICAgICAvLyDmm7TmlrDmta7lsYLlhoXlrrkNCiAgICAgICAgICBjaGFydFRvb2x0aXAuc2VsZWN0KCIubmFtZSIpLnRleHQoY3VyRW50WyduYW1lJ10pOw0KICAgICAgICAgIC8vIOenu+mZpOa1ruWxgmhpZGRlbuagt+W8j++8jOWxleekuua1ruWxgg0KICAgICAgICAgIGNoYXJ0VG9vbHRpcC5jbGFzc2VkKCJoaWRkZW4iLCBmYWxzZSk7DQogICAgICAgICAgbGV0IHRleHRJZCA9IHRvb2xzLmRlZXBDbG9uZShpZCk7DQogICAgICAgICAgaWYgKF90aGlzLm5hbWVUZXh0SWRzLmluZGV4T2YodGV4dElkKSA9PSAtMSkgew0KICAgICAgICAgICAgd2hpbGUgKHRleHRJZCAhPSAncm9vdCcpIHsNCiAgICAgICAgICAgICAgX3RoaXMubmFtZVRleHRJZHMucHVzaCh0ZXh0SWQpOw0KICAgICAgICAgICAgICB0ZXh0SWQgPSBfdGhpcy5mYXRoZXJNYXBbdGV4dElkXTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2VsZWF2ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgX3RoaXMubmFtZVRleHRJZHMgPSBbXTsNCiAgICAgICAgICBsZXQgdHJhbnNmb3JtZCA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJ0cmFuc2Zvcm0iKQ0KICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKQ0KICAgICAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1kLnNwbGl0KCIgIilbMF0gKyAiIHNjYWxlKDEpIg0KICAgICAgICAgICAgfSkNCiAgICAgICAgICBkMy5zZWxlY3QoIi5jaGFydFRvb2x0aXAiKS5jbGFzc2VkKCJoaWRkZW4iLCB0cnVlKTsNCiAgICAgICAgfSkNCiAgICB9LA0KICB9LA0KICBjcmVhdGVkKCkgew0KDQoNCg0KICAgIGNvbnN0IF90aGlzID0gdGhpczsNCg0KICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsNCiAgICAgIF90aGlzLmRyYXdvdmVyVmlldygpOw0KICAgIH0pOw0KICB9LA0KICBtb3VudGVkKCkgew0KICAgIGNvbnN0IF90aGlzID0gdGhpcw0KDQogICAgdGhpcy4kYnVzLiRvbignZ3JhcGhEYXRhJywgKHZhbCkgPT4gew0KICAgICAgLy8gY29uc29sZS5sb2codmFsKQ0KICAgICAgX3RoaXMuZGF0YSA9IHZhbDsNCiAgICB9KTsNCiAgICB0aGlzLiRidXMuJG9uKCdvdmVyRW50aXR5SWQnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5vdmVyRW50aXR5SWQgPSB2YWw7DQogICAgfSk7DQogICAgdGhpcy4kYnVzLiRvbigndHJlZURhdGEnLCAodmFsKSA9PiB7DQogICAgICBjb25zb2xlLmxvZyh2YWwpDQogICAgICBfdGhpcy50cmVlRGF0YSA9IHZhbFswXTsNCiAgICAgIF90aGlzLnJvb3RDb2xvck1hcCA9IHZhbFsxXTsNCiAgICAgIC8vIF90aGlzLmRyYXdvdmVyVmlldygpOw0KICAgIH0pOw0KDQogICAgLy8gZGlzYWJsZWQgaW4gdGhlIG9ubGluZSBkZW1vDQogICAgLy8gdGhpcy4kYnVzLiRvbignZW50RGF0YScsICh2YWwpID0+IHsNCiAgICAvLyAgIF90aGlzLmRhdGEgPSB2YWw7DQogICAgLy8gfSk7DQogICAgLy8gdGhpcy4kYnVzLiRvbigncmVsRGF0YScsICh2YWwpID0+IHsNCiAgICAvLyAgIF90aGlzLnJlbERhdGEgPSB2YWw7DQogICAgLy8gfSk7DQoNCiAgfSwNCiAgLy8gYmVmb3JlRGVzdHJveSgpIHsNCiAgLy8gICBjbGVhckludGVydmFsKHRoaXMubW92ZVRpbWVyKTsNCiAgLy8gfSwNCn0gDQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/OverviewPanel","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"overviewPanel\">\r\n    <div class=\"panelHead\">Overview</div>\r\n    <div id=\"overviewPanelDiv\" class=\"panelBody\" ref=\"overviewPanelDiv\">\r\n\r\n      <div class=\"chartTooltip\">\r\n        <p>\r\n          <br /><strong class=\"name\"></strong>\r\n        </p>\r\n      </div>\r\n\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport domtoimage from 'dom-to-image';\r\nimport TestJson from \"@/assets/json/case3_fin.json\";\r\nimport TestRelJson from \"@/assets/json/case3_fin_rel.json\";\r\nimport tools from \"@/utils/tools.js\";\r\nimport { color } from 'd3';\r\n\r\nexport default {\r\n  props: [\"videoTime\"],\r\n  data() {\r\n    return {\r\n      data: TestJson,//test in the online demo\r\n      relData: TestRelJson,//test in the online demo\r\n      fatherMap: {},\r\n      treeData: [],\r\n      nameTextIds: [],\r\n      textG: '',\r\n      colorMap: {},\r\n      rootColorMap: {},\r\n      overEntityId: \"\",\r\n      margin: { top: 15, right: 5, bottom: 5, left: 5 },\r\n      // mcolor: [\r\n      //   \"rgb(255,60,60)\",\r\n      //   \"rgb(155,20,100)\",\r\n      //   \"rgb(255,83,255)\",\r\n      //   \"rgb(200,100,50)\",\r\n      //   \"rgb(235,135,162)\",\r\n      //   \"rgb(200,200,102)\",\r\n      //   \"rgb(255,178,101)\",\r\n      //   \"rgb(63,151,134)\",\r\n      //   \"rgb(83,155,255)\",\r\n      //   \"rgb(50,200,120)\",\r\n      //   \"rgb(2,50,200)\",\r\n      //   \"rgb(0,122,244)\",\r\n      //   \"rgb(150,122,244)\",\r\n      //   \"rgb(168,168,255)\",\r\n      //   \"rgb(200,200,200)\",\r\n      // ],\r\n      mcolor: [\r\n        \"rgb(91, 107, 255)\",\r\n        \"rgb(6, 214, 160)\",\r\n        \"rgb(255, 120, 90)\",\r\n        \"rgb(125, 98, 211)\",\r\n        \"rgb(255, 113, 212)\",\r\n        \"rgb(112, 214, 255)\",\r\n        \"rgb(255, 159, 28)\",\r\n        \"rgb(255, 77, 109)\",\r\n      ],\r\n      mLightcolor: [\r\n        \"#ff9c9c\",\r\n        \"#cc88b0\",\r\n        \"#ffa8ff\",\r\n        \"#e3b097\",\r\n        \"#f4c3d0\",\r\n        \"#f4f4d0\",\r\n        \"#ffd8b1\",\r\n        \"#9ecac2\",\r\n        \"#a8ccff\",\r\n        \"#97e3ba\",\r\n        \"#6f8be0\",\r\n        \"rgb(0,122,244)\",\r\n        \"#b6a2f7\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n    };\r\n  },\r\n  watch: {\r\n    type(val) {\r\n    },\r\n    treeData(val) {\r\n      this.drawoverView();\r\n    },\r\n    overEntityId(val) {\r\n      const _this = this;\r\n\r\n      if (val != '') {\r\n        let textId = tools.deepClone(val);\r\n        if (_this.nameTextIds.indexOf(textId) == -1) {\r\n          while (textId != 'root') {\r\n            _this.nameTextIds.push(textId);\r\n            textId = _this.fatherMap[textId];\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        _this.nameTextIds = []\r\n      }\r\n\r\n    },\r\n    nameTextIds(ids) {\r\n      const _this = this;\r\n      let data = _this.data;\r\n      let tx = 50;\r\n      let ty = 600;\r\n      let colorMap = this.colorMap;\r\n      _this.textPathG.select(\"g\").remove();\r\n      let g = _this.textPathG.append(\"g\");\r\n      d3.selectAll(`.curOverArc`).style(\"filter\", \"url()\")\r\n      for (let i = ids.length - 1; i >= 0; i--) {\r\n      d3.selectAll(`.na_${ids[i]}`).style(\"filter\", \"url(#coolShadow)\")\r\n        let curd = data.find(function (d) { return d['id'] == ids[i]; });\r\n        let name = curd['name'].split(\"_\")[0];\r\n        let nameS = name.split(\" \")\r\n        if(nameS.length>4){\r\n          name = nameS.splice(0,4).join(\" \")+\" ...\"\r\n\r\n        }\r\n        let w = name.length * 10;\r\n        let h = 4;\r\n        let rx = 5;\r\n        let ry = 5;\r\n        let color = colorMap[ids[i]];\r\n        _this.drawRect(g, tx, ty + 5, w, h, rx, ry, color, 0.5, color)\r\n        _this.drawTxt(g, tx, ty, name, \"rgb(60,60,60)\", 0, \"start\", 18);\r\n        tx += name.length * 12;\r\n        if (tx > 900) {\r\n          tx = 10;\r\n          ty += 30;\r\n        }\r\n      }\r\n    },\r\n    data(val) {\r\n    }\r\n  },\r\n  methods: {\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n    drawoverView() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      let data = _this.treeData;\r\n      let width = this.$refs.overviewPanelDiv.offsetWidth - margin.left - margin.right;\r\n      let height = this.$refs.overviewPanelDiv.offsetHeight - margin.top - margin.bottom;\r\n\r\n      // var tree = d3.tree()\r\n      //   .size([width, height - 200]);\r\n      d3.select(\"#overviewPanelDiv\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#overviewPanelDiv\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n        .attr(\"transform\", \"translate(5,10)\");\r\n      let sunTreeG = svg.append('g')\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      let riverG = svg.append('g')\r\n        .attr(\"width\", width + 20)\r\n        .attr(\"height\", height)\r\n        .attr(\"transform\", \"translate(35,600)\");\r\n      let textG = svg.append('g')\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      let textPathG = svg.append('g')\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      let toolTipG = svg.append('g')\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n      var defs = svg.append(\"defs\");\r\n\r\n      var filter = defs\r\n        .append(\"filter\")\r\n        .attr(\"id\", \"coolShadow\")\r\n        .attr(\"x\", \"-100%\")\r\n        .attr(\"y\", \"-100%\") //\r\n        .attr(\"width\", \"300%\")\r\n        .attr(\"height\", \"300%\"); //\r\n\r\n      filter\r\n        .append(\"feMorphology\")\r\n        .attr(\"in\", \"SourceGraphic\")\r\n        .attr(\"result\", \"upperLayer\")\r\n        .attr(\"operator\", \"dilate\")\r\n        .attr(\"radius\", \"0.2 0.2\");\r\n\r\n      filter\r\n        .append(\"feMorphology\")\r\n        .attr(\"in\", \"SourceAlpha\")\r\n        .attr(\"result\", \"enlargedAlpha\")\r\n        .attr(\"operator\", \"dilate\")\r\n        .attr(\"radius\", \"0.2 0.2\");\r\n\r\n      filter\r\n        .append(\"feGaussianBlur\")\r\n        .attr(\"in\", \"enlargedAlpha\")\r\n        .attr(\"result\", \"bluredAlpha\")\r\n        .attr(\"stdDeviation\", \"3\");\r\n\r\n      filter\r\n        .append(\"feOffset\")\r\n        .attr(\"in\", \"bluredAlpha\")\r\n        .attr(\"result\", \"lowerLayer\")\r\n        .attr(\"dy\", \"1\"); //\r\n\r\n      var feMerge = filter.append(\"feMerge\");\r\n      feMerge.append(\"feMergeNode\").attr(\"in\", \"lowerLayer\");\r\n      feMerge.append(\"feMergeNode\").attr(\"in\", \"upperLayer\");\r\n\r\n      _this.textG = textG;\r\n      _this.textPathG = textPathG;\r\n\r\n      let centerX = margin.left + (width / 2);\r\n      let centerY = margin.top + (height / 2) - 50;\r\n      const gCircle = svg.append(\"g\");\r\n      // .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\r\n      let curD = tools.deepClone(data);\r\n      // console.log(data,curD)\r\n      // curD['layout'] = '-1';\r\n\r\n      let layout = -1;\r\n      let totalDur = 0\r\n      for (let c in data['children']) {\r\n        if (data['children'][c]['name'] != 'Test') {\r\n          totalDur += data['children'][c]['totalDuration'];\r\n        }\r\n      }\r\n      _this.drawSunTree(sunTreeG, centerX, centerY, curD, layout, totalDur, 0, Math.PI * 2, 0, \"\", \"root\");\r\n      // _this.drawTypeRiver(riverG);\r\n    },\r\n    drawTypeRiver(svg) {\r\n      const _this = this;\r\n      let oriData = _this.data;\r\n      let resData = [];\r\n      let triLi = [];\r\n      let exeLi = [];\r\n\r\n      for (let i = 0; i < oriData.length; i++) {\r\n        let curEnt = oriData[i];\r\n        let tp = {}\r\n        tp['od'] = i;\r\n        if ((curEnt['type'] == \"1\")) {\r\n          triLi.push(tp);\r\n        }\r\n        if (curEnt['type'] == \"2\") {\r\n          exeLi.push(tp);\r\n        }\r\n        let typeData = curEnt[\"attribute\"][\"expressions\"];\r\n        let totalDur = 0;\r\n\r\n        for (let t in typeData) {\r\n          // let color = typeColor[i];\r\n          let typeDurition = typeData[t];\r\n          let totalTypeSeconds = 0;\r\n          for (let d in typeDurition) {\r\n            totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n          }\r\n          totalDur += totalTypeSeconds;\r\n          tp[t] = totalTypeSeconds;\r\n        }\r\n        for (let t in tp) {\r\n          if (t != 'od') {\r\n            tp[t] /= totalDur;\r\n            if (totalDur == 0) {\r\n              tp[t] = 0;\r\n            }\r\n          }\r\n        }\r\n        resData.push(tp)\r\n      }\r\n\r\n      let data = resData;\r\n      console.log(data)\r\n      var stack = d3.stack()\r\n        .keys(['1', '2', '3'])\r\n        .order(d3.stackOrderInsideOut)\r\n        .offset(d3.stackOffsetWiggle);\r\n\r\n      let yRangeWidth = 80;\r\n      let xStep = (svg.attr(\"width\") - 80) / oriData.length;\r\n      let yScale = d3.scaleLinear().domain([-1, 1]).range([0, 80]);\r\n      var area = d3.area()\r\n        .curve(d3.curveBasis)\r\n        .x(function (d) {\r\n          return d.data.od * xStep;\r\n        })\r\n        .y0(function (d) {\r\n          return yRangeWidth - yScale(d[0]);\r\n        })\r\n        .y1(function (d) {\r\n          return yRangeWidth - yScale(d[1]);\r\n        });\r\n      console.log(data)\r\n      let stackData = stack(data)\r\n      console.log(data, stackData)\r\n      let lenThreshold = 0.4;\r\n      let iconLi = {}\r\n      for (let s in stackData) {\r\n        iconLi[s] = []\r\n        for (let i in stackData[s]) {\r\n          let lenArea = stackData[s][i]\r\n          if ((lenArea[1] - lenArea[0]) > 0.4) {\r\n            iconLi[s].push([i, lenArea]);\r\n          }\r\n          for (let li in iconLi[s]) {\r\n            if (i < (iconLi[s][li][0] + 2)) {\r\n              let selectArea = iconLi[s][li][1]\r\n              if (((selectArea[1] - lenArea[1]) - (selectArea[0] - lenArea[0])) < 0.2) {\r\n                iconLi[s].splice(s, 1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // let areaG = svg.append(\"g\")\r\n      let typeColor = {\r\n        \"1\": \"#ff9c9c\",\r\n        \"2\": \"#f4f4d0\",\r\n        \"3\": \"#6f8be0\",\r\n      };\r\n      let colorLi = _this.mcolor;\r\n      svg.selectAll(\"path\")\r\n        .data(stackData)\r\n        .join(\"path\")\r\n        .attr(\"id\", function (d) { return d.key })\r\n        .attr(\"class\", \"river\")\r\n        .attr(\"d\", function (d) {\r\n          return area(d)\r\n        })\r\n        .attr(\"fill\", function (d, i) {\r\n          return typeColor[d.key]\r\n        })\r\n        .on(\"mouseover\", function (d) {\r\n          d3.selectAll(\".river\").style(\"filter\", \"url()\")\r\n          d3.select(this).style(\"filter\", \"url(#coolShadow)\")\r\n        })\r\n\r\n      for (let t in triLi) {\r\n        let area = tools.calcTriangle((triLi[t]['od']) * xStep, -30, 14);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n        _this.drawTxt(svg, (triLi[t]['od']) * xStep, -23, \"T\", \"white\", 0, \"middle\", 18)\r\n      }\r\n      for (let t in exeLi) {\r\n        let area = tools.calcTriangle((exeLi[t]['od']) * xStep, -30, 14);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n        _this.drawTxt(svg, (exeLi[t]['od']) * xStep, -23, \"E\", \"white\", 0, \"middle\", 18)\r\n      }\r\n    },\r\n    drawTriangle(svg, color, points, stroke, opacity = 1) {\r\n      svg.append(\"polygon\")\r\n        .attr(\"points\", points)\r\n        .attr(\"fill\", color)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", \"5px\");\r\n    },\r\n    drawSunTree(svg, x, y, data, layout, totalDur, startAngle, endAngle, startHeight, curcolor, father) {\r\n      const _this = this;\r\n      // totalDur+=15\r\n      var curStartR = tools.deepClone(startAngle);//Math.PI/4;\r\n      let colorList = this.mcolor;\r\n      let stepLayHight = 100;\r\n      if (layout == '-1') {\r\n        // stepLayHight = 400;//c3\r\n        stepLayHight = 450;//c5\r\n      }\r\n      if (layout == '0') {\r\n        // stepLayHight = 80;//c3\r\n        stepLayHight = 120;//c5\r\n      }\r\n      if (layout == '1') {\r\n        // stepLayHight = 30;//c3\r\n        stepLayHight = 20;//c5\r\n        \r\n      }\r\n      if (layout == '2') {\r\n        stepLayHight = 30;\r\n      }\r\n      if (layout == '3') {\r\n        stepLayHight = 1;\r\n      }\r\n      let endHeight = startHeight + stepLayHight;\r\n      // console.log(endHeight,layout,stepLayHight)\r\n      let Color_linear = d3.scaleLinear().domain([0, totalDur]).range([0.3, 1]);\r\n      let Compute_color = d3.interpolate(\"white\", curcolor);\r\n      let perDur = 0;\r\n      let curArcScale_linear = d3.scaleLinear([0, totalDur], [startAngle, endAngle]);\r\n      let curHeightScale_linear = d3.scaleLinear([0, Math.sqrt(totalDur)], [startHeight * 1, endHeight]);\r\n      for (let c in data['children']) {\r\n        _this.fatherMap[data['children'][c]['id']] = father;\r\n        if ((data['children'][c]['name'] != 'Test') || (data['children'][c]['layout'] != '0')) {\r\n          let curTotalDur = data['children'][c]['totalDuration'];\r\n          // if(curTotalDur<20){curTotalDur=20}\r\n          let endAnglet = curArcScale_linear(perDur + curTotalDur);\r\n          perDur += curTotalDur\r\n          var dataset = { startAngle: curStartR + 0.05, endAngle: endAnglet - 0.05 };\r\n          let h = ((curHeightScale_linear((Math.sqrt(curTotalDur)))));\r\n          if(h - startHeight >200){h=startHeight + 160}\r\n          if(h - startHeight <30){h=startHeight +30}\r\n          console.log(layout)\r\n          if(layout == \"2\"){h=startHeight +20}\r\n          var arcPath = d3.arc()\r\n            .innerRadius(startHeight + 15)\r\n            .outerRadius(h)\r\n          var pathArc = arcPath(dataset);\r\n          let color = \"\";\r\n          if (layout == -1) {\r\n            color = _this.rootColorMap[data['children'][c]['id']];//colorList[c];\r\n          }\r\n          else { color = Compute_color(Color_linear(curTotalDur)) }\r\n          _this.colorMap[data['children'][c]['id']] = color;\r\n          _this.drawArc(svg, x, y, pathArc, color, color, `curOverArc fa_${father} na_${data['children'][c]['id']}`, '0', 10);\r\n          _this.drawSunTree(svg, x, y, data['children'][c], layout + 1, curTotalDur, dataset.startAngle, dataset.endAngle, h, color, data['children'][c]['id']);\r\n\r\n          if ((parseInt(layout) < 1)) {\r\n            let name = data['children'][c]['name'];\r\n\r\n            let names = name.split(\" \")\r\n            let nameLen = names.length;\r\n            let anchor = \"end\"\r\n            let stepR = (endAnglet - curStartR) / (nameLen + 1);\r\n            let colorV = tools.getRgbValue(color)\r\n            let textColor = 'white';\r\n            let textStartR = curStartR;\r\n            let v = 0;\r\n            for (let i in colorV) {\r\n              v += parseInt(colorV[i]);\r\n            }\r\n            if (v > 620) {\r\n              textColor = 'grey';\r\n            }\r\n            if ((parseInt(layout) == -1) && ((endAnglet - curStartR) > (Math.PI / 5))) {\r\n              if ((endAnglet - curStartR) > (Math.PI / 4)) {\r\n                stepR = Math.PI / 20;\r\n                textStartR = (endAnglet + curStartR) / 2 - (nameLen) / 2 * stepR;\r\n              }\r\n              for (let n = 0; n < nameLen; n++) {\r\n                let nn = n;\r\n                let arcScale = d3.scaleLinear().domain([0, Math.PI * 2]).range([0, 360]);\r\n                if (arcScale(curStartR) > 180) {\r\n                  nn = nameLen - n - 1;\r\n                }\r\n                let midR = textStartR + stepR * (nn + 1);\r\n\r\n                let roat = arcScale(midR);\r\n                roat -= 90;\r\n                if (roat > 90) {\r\n                  roat += 180;\r\n                  anchor = \"start\"\r\n                }\r\n                // h = (h + startHeight) / 2 + 10;\r\n                let tx = x + h * Math.sin(midR);\r\n                let ty = y - h * Math.cos(midR);\r\n                _this.drawTxt(_this.textG, tx, ty, names[n], textColor, roat, anchor)\r\n\r\n              }\r\n            }\r\n\r\n            else if ((parseInt(layout) == 0) && ((endAnglet - curStartR) > (Math.PI / 15)) && (nameLen < 4) && (name.length < 10)) {\r\n              let steph = (h - startHeight - 20) / nameLen;\r\n              anchor = \"middle\"\r\n              for (let n = 0; n < nameLen; n++) {\r\n                let nn = n;\r\n                let arcScale = d3.scaleLinear().domain([0, Math.PI * 2]).range([0, 360]);\r\n                // if(arcScale(curStartR)>180){\r\n                //   nn = nameLen - n-1;\r\n                // }\r\n                let midR = (endAnglet + curStartR) / 2;\r\n\r\n                let roat = arcScale(midR);\r\n                // roat -= 90;\r\n                // if(roat>90){\r\n                //   roat+=180;\r\n                //   anchor = \"start\"\r\n                // }\r\n                h = h - 10 - 1 * n;//(h + startHeight) / 2 + 10;\r\n                let tx = x + h * Math.sin(midR);\r\n                let ty = y - h * Math.cos(midR);\r\n                _this.drawTxt(_this.textG, tx, ty, names[n], textColor, roat, anchor)\r\n\r\n              }\r\n            }\r\n            else if (parseInt(layout) == 1) {\r\n              let midR = (endAnglet + curStartR) / 2;\r\n\r\n              let arcScale = d3.scaleLinear().domain([0, Math.PI * 2]).range([0, 360]);\r\n              let roat = arcScale(midR)\r\n              if (layout == '-1') {\r\n                roat += 90;\r\n              }\r\n              h = (h + startHeight) / 2 + 10;\r\n              let tx = x + h * Math.sin(midR);\r\n              let ty = y - h * Math.cos(midR);\r\n              // if (layout != '-1') {\r\n              //   for(let w = 0;w<names.length;w++){\r\n              //     h-=(w+1)*1;\r\n              //     tx = x + h * Math.sin(midR);\r\n              //     ty = y - h * Math.cos(midR);\r\n              //     _this.drawTxt(_this.textG, tx,ty , names[w], textColor, roat,\"middle\")\r\n\r\n              //     }\r\n              // }\r\n              // else{\r\n              _this.drawTxt(_this.textG, tx, ty, data['children'][c]['name'], textColor, roat, \"middle\")\r\n              // }\r\n            }\r\n          }\r\n\r\n          curStartR = endAnglet;\r\n        }\r\n      }\r\n    },\r\n    drawRect(svg, x, y, w, h, rx, ry, fill, opacity, stroke) {\r\n      svg.append(\"rect\")\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"ry\", ry)\r\n        .attr(\"height\", h)\r\n        .attr(\"width\", w)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", \"1.5px\");\r\n    },\r\n    drawTxt(svg, tx, ty, txts, fill, roat, anchor, fontsize = 14) {\r\n      svg.append(\"text\")\r\n        .attr(\"y\", ty)\r\n        .attr(\"x\", tx)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"font-size\", fontsize)\r\n        .text(txts)\r\n        .style(\"text-anchor\", anchor)//\"middle\")\r\n        .attr(\"transform\", `rotate(${roat} ${tx} ${ty})`);\r\n    },\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3) {\r\n      const _this = this;\r\n      svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"opacity\", 1)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n        .on(\"mousemove\", function (d) {\r\n          let transformd = d3.select(this).attr(\"transform\")\r\n          let id = d3.select(this).attr(\"class\").split(\" \")[d3.select(this).attr(\"class\").split(\" \").length - 1];\r\n          id = id.split(\"_\")[1]\r\n          let curEnt = _this.data.find(function (d) { return d['id'] == id })\r\n\r\n\r\n          d3.select(this)\r\n            .attr(\"transform\", function (d) {\r\n              return transformd.split(\" \")[0] + \" scale(1.04)\"\r\n            })\r\n          // var transform = d3.event;\r\n          var yPosition = d.clientY + 20;\r\n          var xPosition = d.clientX + 20;\r\n          var chartTooltip = d3\r\n            .select(\".chartTooltip\")\r\n            .style(\"left\", xPosition + \"px\")\r\n            .style(\"top\", yPosition + \"px\");\r\n          // 更新浮层内容\r\n          chartTooltip.select(\".name\").text(curEnt['name']);\r\n          // 移除浮层hidden样式，展示浮层\r\n          chartTooltip.classed(\"hidden\", false);\r\n          let textId = tools.deepClone(id);\r\n          if (_this.nameTextIds.indexOf(textId) == -1) {\r\n            while (textId != 'root') {\r\n              _this.nameTextIds.push(textId);\r\n              textId = _this.fatherMap[textId];\r\n            }\r\n          }\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          _this.nameTextIds = [];\r\n          let transformd = d3.select(this).attr(\"transform\")\r\n          d3.select(this)\r\n            .attr(\"transform\", function (d) {\r\n              return transformd.split(\" \")[0] + \" scale(1)\"\r\n            })\r\n          d3.select(\".chartTooltip\").classed(\"hidden\", true);\r\n        })\r\n    },\r\n  },\r\n  created() {\r\n\r\n\r\n\r\n    const _this = this;\r\n\r\n    this.$nextTick(() => {\r\n      _this.drawoverView();\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this\r\n\r\n    this.$bus.$on('graphData', (val) => {\r\n      // console.log(val)\r\n      _this.data = val;\r\n    });\r\n    this.$bus.$on('overEntityId', (val) => {\r\n      _this.overEntityId = val;\r\n    });\r\n    this.$bus.$on('treeData', (val) => {\r\n      console.log(val)\r\n      _this.treeData = val[0];\r\n      _this.rootColorMap = val[1];\r\n      // _this.drawoverView();\r\n    });\r\n\r\n    // disabled in the online demo\r\n    // this.$bus.$on('entData', (val) => {\r\n    //   _this.data = val;\r\n    // });\r\n    // this.$bus.$on('relData', (val) => {\r\n    //   _this.relData = val;\r\n    // });\r\n\r\n  },\r\n  // beforeDestroy() {\r\n  //   clearInterval(this.moveTimer);\r\n  // },\r\n} \r\n</script>\r\n\r\n<style>\r\n@import './index.css';\r\n</style>\r\n"]}]}