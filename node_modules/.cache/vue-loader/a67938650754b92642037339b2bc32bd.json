{"remainingRequest":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\EditPanel\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\EditPanel\\index.vue","mtime":1689129713303},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\babel-loader\\lib\\index.js","mtime":1688115046651},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js","mtime":1688115046800}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBmaWxlbmFtZXMgZnJvbSAiQC91dGlscy9maWxlTmFtZSI7DQppbXBvcnQgZG9tdG9pbWFnZSBmcm9tICdkb20tdG8taW1hZ2UnOw0KaW1wb3J0IFRlc3RKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTFfZmluLmpzb24iOw0KaW1wb3J0IFRlc3RSZWxKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTFfZmluX3JlbC5qc29uIjsNCmltcG9ydCB0b29scyBmcm9tICJAL3V0aWxzL3Rvb2xzLmpzIjsNCg0KZXhwb3J0IGRlZmF1bHQgew0KICBwcm9wczogW10sDQogIGRhdGEoKSB7DQogICAgcmV0dXJuIHsNCiAgICAgIHR5cGVSYWRpbzogImNlbGwgU3RhdGUiLA0KICAgICAgZGF0YTogVGVzdEpzb24sDQogICAgICByZWxEYXRhOiBUZXN0UmVsSnNvbiwNCiAgICAgIHRyZWVEYXRhOiBudWxsLA0KICAgICAgdG9vbHNTdGF0ZTogJycsDQogICAgICBjb25maXJtVXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvY29uZmlybS5zdmciKSwNCiAgICAgIGNhbmNlbFVybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL2NhbmNlbC5zdmciKSwNCiAgICAgIHRvb2xzQnV0c1VybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL3Rvb2xzQnV0cy5wbmciKSwNCiAgICAgIGFkZE5vZGVTb25Vcmw6IHJlcXVpcmUoIkAvYXNzZXRzL2ltZy9hZGROb2RlMS5wbmciKSwNCiAgICAgIGFkZE5vZGVQZXJVcmw6IHJlcXVpcmUoIkAvYXNzZXRzL2ltZy9hZGROb2RlMi5wbmciKSwNCiAgICAgIGFkZExpbmtCYXNpY1VybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL2FkZExpbmsucG5nIiksDQogICAgICAvLyBuYW1laW5wdXQ6ICJSYW5kb20gVmFyaWFibGVzIiwNCiAgICAgIG5hbWVpbnB1dDogIkZ1bmRhbWVudGFsIEdyYXBocyIsDQogICAgICAvLyBuYW1laW5wdXQ6ICJUcmVlcyIsDQogICAgICBsZWN0dXJlU3R5bGVWYWx1ZTogWzAsIDgwXSwNCiAgICAgIHRhYmxlRGF0YTogW3sNCiAgICAgICAga2V5OiAndHlwZScsDQogICAgICAgIHZhbHVlOiAnJywNCiAgICAgIH0sIHsNCiAgICAgICAga2V5OiAnbmFtZScsDQogICAgICAgIHZhbHVlOiAnJywNCiAgICAgIH0sIHsNCiAgICAgICAga2V5OiAnbGVjdHVyZSBzdHlsZScsDQogICAgICAgIHZhbHVlOiAnJywNCiAgICAgIH1dLA0KICAgICAgY3VyRW50SWQ6ICIiLA0KICAgICAgaW5zZXJ0RW50SWQ6ICIiLA0KICAgICAgaW5zZXJ0U291cmNlRW50SWQ6ICItMSIsDQogICAgICBpbnNlcnRUYXJnZXRFbnRJZDogIi0xIiwNCiAgICAgIHNvbkxpc3Q6IFtdLA0KICAgICAgbWluREltcG9ydGFuY2U6IDAsDQogICAgICBtYXhESW1wb3J0YW5jZTogMCwNCiAgICAgIG1pbkRSZWxldmFuY2U6IDAsDQogICAgICBtYXhEUmVsZXZhbmNlOiAwLA0KICAgICAgbWF4RER1cmF0aW9uOiAwLA0KICAgICAgbWF4VG90YWxEdXJhdGlvbjogMCwNCiAgICAgIGltcG9ydGFuY2VNaW5Db2xvcjogInJnYigyMDMsIDIzMCwgMjA5KSIsDQogICAgICBpbXBvcnRhbmNlTWF4Q29sb3I6ICJyZ2IoMjIsIDE0NCwgMjA3KSIsDQogICAgICB0b3RhbER1cmF0aW9uOiAxMDAwLA0KICAgICAgaW1wb3J0YW5jZUNvbG9yX2xpbmVhcjogbnVsbCwNCiAgICAgIGltcG9ydGFuY2VDb21wdXRlX2NvbG9yOiBudWxsLA0KICAgICAgcmVsZXZhbmNlU2NhbGVfbGluZWFyOiBudWxsLA0KICAgICAgdG90YWxEdXJhdGlvblNjYWxlX2xpbmVhcjogbnVsbCwNCiAgICAgIERpdmlzaW9uRGF0YUxpc3Q6IFtdLA0KICAgICAgcm9vdERpdmlzaW9uRGF0YUxpc3Q6IFtdLA0KICAgICAgZW50RGl2aXNpb25EYXRhTGlzdDogW10sDQogICAgICBjb2xvck1hcDoge30sDQogICAgICByb290Q29sb3JNYXA6e30sDQogICAgICB2aWRlb0R1cmF0aW9uOiA1NzAsDQogICAgICBzZWxlY3RSZWN0SWQ6ICIiLA0KICAgICAgc2VsZWN0UmVjdENsYXNzOiAiIiwNCiAgICAgIHRvcGljTGluZVdpZHRoOiAxMDAwLA0KICAgICAgdG9waWNMaW5lSGVpZ2h0OiAxMDAwLA0KICAgICAgbW92ZUxpbmVXaWR0aDogMTAwMCwNCiAgICAgIGVudExpbmVXaWR0aDogMTAwMCwNCiAgICAgIHRvdGFsU29uRHVyYXRpb246IDAsDQogICAgICB0cmVlR1RyYW5zZm9ybUs6MSwNCiAgICAgIHRyZWVHVHJhbnNmb3JtWDoxMCwNCiAgICAgIHRyZWVHVHJhbnNmb3JtWToxMDAsDQogICAgICBtYXJnaW46IHsgdG9wOiA1LCByaWdodDogNSwgYm90dG9tOiA1LCBsZWZ0OiA1IH0sDQogICAgICAvLyBtY29sb3I6IFsNCiAgICAgIC8vICAgInJnYigyNTUsNjAsNjApIiwNCiAgICAgIC8vICAgInJnYigxNTUsMjAsMTAwKSIsDQogICAgICAvLyAgICJyZ2IoMjU1LDgzLDI1NSkiLA0KICAgICAgLy8gICAicmdiKDIwMCwxMDAsNTApIiwNCiAgICAgIC8vICAgInJnYigyMzUsMTM1LDE2MikiLA0KICAgICAgLy8gICAicmdiKDIwMCwyMDAsMTAyKSIsDQogICAgICAvLyAgICJyZ2IoMjU1LDE3OCwxMDEpIiwNCiAgICAgIC8vICAgInJnYig2MywxNTEsMTM0KSIsDQogICAgICAvLyAgICJyZ2IoODMsMTU1LDI1NSkiLA0KICAgICAgLy8gICAicmdiKDUwLDIwMCwxMjApIiwNCiAgICAgIC8vICAgInJnYigyLDUwLDIwMCkiLA0KICAgICAgLy8gICAicmdiKDAsMTIyLDI0NCkiLA0KICAgICAgLy8gICAicmdiKDE1MCwxMjIsMjQ0KSIsDQogICAgICAvLyAgICJyZ2IoMTY4LDE2OCwyNTUpIiwNCiAgICAgIC8vICAgInJnYigyMDAsMjAwLDIwMCkiLA0KICAgICAgLy8gXSwNCiAgICAgIG1jb2xvcjogWw0KICAgICAgICAicmdiKDkxLCAxMDcsIDI1NSkiLA0KICAgICAgICAicmdiKDYsIDIxNCwgMTYwKSIsDQogICAgICAgICJyZ2IoMjU1LCAxMjAsIDkwKSIsDQogICAgICAgICJyZ2IoMTI1LCA5OCwgMjExKSIsDQogICAgICAgICJyZ2IoMjU1LCAxMTMsIDIxMikiLA0KICAgICAgICAicmdiKDExMiwgMjE0LCAyNTUpIiwNCiAgICAgICAgInJnYigyNTUsIDE1OSwgMjgpIiwNCiAgICAgICAgInJnYigyNTUsIDc3LCAxMDkpIiwNCiAgICAgIF0sDQogICAgICBtTGlnaHRjb2xvcjogWw0KICAgICAgICAiI2ZmOWM5YyIsDQogICAgICAgICIjY2M4OGIwIiwNCiAgICAgICAgIiNmZmE4ZmYiLA0KICAgICAgICAiI2UzYjA5NyIsDQogICAgICAgICIjZjRjM2QwIiwNCiAgICAgICAgIiNmNGY0ZDAiLA0KICAgICAgICAiI2ZmZDhiMSIsDQogICAgICAgICIjOWVjYWMyIiwNCiAgICAgICAgIiNhOGNjZmYiLA0KICAgICAgICAiIzk3ZTNiYSIsDQogICAgICAgICIjNmY4YmUwIiwNCiAgICAgICAgInJnYigwLDEyMiwyNDQpIiwNCiAgICAgICAgIiNiNmEyZjciLA0KICAgICAgICAicmdiKDE2OCwxNjgsMjU1KSIsDQogICAgICAgICJyZ2IoMjAwLDIwMCwyMDApIiwNCiAgICAgIF0sDQogICAgfTsNCiAgfSwNCiAgd2F0Y2g6IHsNCiAgICB0eXBlUmFkaW8odmFsKSB7DQogICAgfSwNCiAgICBsZWN0dXJlU3R5bGVWYWx1ZSh2YWwpew0KICAgICAgY29uc29sZS5sb2codmFsKTsNCiAgICAgIGxldCBtaWQgPSAodmFsWzBdK3ZhbFsxXSkvMjsNCiAgICAgIGQzLnNlbGVjdCgiI2VkaXREYXRhIC5lbC1zbGlkZXJfX3J1bndheSIpDQogICAgICAuYXR0cigic3R5bGUiLCJiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICNmZjljOWMgIittaWQrIiUsIzZmOGJlMCAiK21pZCsiJSkgIWltcG9ydGFudCIpDQogICAgfSwNCiAgICB0eXBlKHZhbCkgew0KICAgIH0sDQogICAgLy8gc2VsZWN0RW50KHZhbCl7DQogICAgLy8gICBjb25zb2xlLmxvZyh2YWwpOw0KICAgIC8vIH0sDQogICAgY3VyRW50SWQoY3VyRW50SWQpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBkYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCBjdXJFbnQgPSBkYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY3VyRW50SWQ7IH0pOw0KICAgICAgaWYgKGN1ckVudFsndHlwZSddID09ICcxJykgew0KICAgICAgICBfdGhpcy50eXBlUmFkaW8gPSAiaGlkZGVuIFN0YXRlIjsNCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KICAgICAgICBfdGhpcy50eXBlUmFkaW8gPSAiY2VsbCBTdGF0ZSI7DQogICAgICB9DQogICAgICBfdGhpcy5uYW1laW5wdXQgPSBjdXJFbnRbJ25hbWUnXTsNCiAgICAgIGxldCBkdXJhdGlvbiA9IHRvb2xzLnRpbWUyc2Vjb25kcyhjdXJFbnRbJ3RpbWUnXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHMoY3VyRW50Wyd0aW1lJ11bMF0pOw0KICAgICAgbGV0IHR5cGVEdXJTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgZHVyYXRpb25dLCBbMCwgMTAwXSk7DQogICAgICBsZXQgdHlwZURhdGEgPSBjdXJFbnRbImF0dHJpYnV0ZSJdWyJleHByZXNzaW9ucyJdOw0KICAgICAgbGV0IHR5cGVEdXIgPSAwOw0KICAgICAgbGV0IHN0eWxlVmFsdWUgPSBbXTsNCiAgICAgIGZvciAobGV0IGkgaW4gdHlwZURhdGEpIHsNCiAgICAgICAgLy8gbGV0IGNvbG9yID0gdHlwZUNvbG9yW2ldOw0KICAgICAgICBsZXQgdHlwZUR1cml0aW9uID0gdHlwZURhdGFbaV07DQogICAgICAgIGxldCB0b3RhbFR5cGVTZWNvbmRzID0gMDsNCiAgICAgICAgZm9yIChsZXQgZCBpbiB0eXBlRHVyaXRpb24pIHsNCiAgICAgICAgICB0b3RhbFR5cGVTZWNvbmRzICs9ICh0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMF0pKQ0KICAgICAgICB9DQogICAgICAgIHR5cGVEdXIgKz0gdG90YWxUeXBlU2Vjb25kczsNCiAgICAgICAgc3R5bGVWYWx1ZS5wdXNoKHR5cGVEdXJTY2FsZV9saW5lYXIodHlwZUR1cikpDQogICAgICB9DQoNCiAgICAgIF90aGlzLmxlY3R1cmVTdHlsZVZhbHVlID0gc3R5bGVWYWx1ZQ0KICAgICAgX3RoaXMuZHJhd0VudGl0eShjdXJFbnQpOw0KICAgICAgX3RoaXMuZHJhd1NvbkxpbmUoY3VyRW50KTsNCiAgICB9DQogIH0sDQogIG1ldGhvZHM6IHsNCiAgICBzZWxlY3RUeXBlKHYpIHsNCiAgICAgIC8vIGNvbnNvbGUubG9nKHYpDQogICAgfSwNCiAgICBjYW5jZWxDbGsoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZGF0YSA9IF90aGlzLmRhdGE7DQogICAgICBsZXQgY3VyRW50SWQgPSBfdGhpcy5jdXJFbnRJZDsNCiAgICAgIGxldCBjdXJFbnQgPSBkYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY3VyRW50SWQ7IH0pOw0KICAgICAgX3RoaXMuZHJhd0VudGl0eShjdXJFbnQpOw0KICAgICAgX3RoaXMuZHJhd1NvbkxpbmUoY3VyRW50KTsNCiAgICAgIF90aGlzLmRyYXdyb290VHJlZSgpOw0KDQogICAgfSwNCiAgICBjb25maXJtQ2xrKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IGN1ckVudElkID0gX3RoaXMuY3VyRW50SWQ7DQogICAgICBsZXQgY3VyRW50ID0gZGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGN1ckVudElkOyB9KTsNCiAgICAgIGlmIChfdGhpcy50eXBlUmFkaW8gPT0gImhpZGRlbiBTdGF0ZSIpIHsNCiAgICAgICAgY3VyRW50Wyd0eXBlJ10gPSAnMScNCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KICAgICAgICBjdXJFbnRbJ3R5cGUnXSA9ICcwJzsNCiAgICAgIH0NCiAgICAgIGN1ckVudFsnbmFtZSddID0gX3RoaXMubmFtZWlucHV0Ow0KDQogICAgICBsZXQgc3R5bGVWYWx1ZSA9IF90aGlzLmxlY3R1cmVTdHlsZVZhbHVlOw0KICAgICAgbGV0IHN0YXJ0U2Vjb25kcyA9IHRvb2xzLnRpbWUyc2Vjb25kcyhjdXJFbnRbJ3RpbWUnXVswXSk7DQogICAgICBsZXQgZW5kU2Vjb25kcyA9IHRvb2xzLnRpbWUyc2Vjb25kcyhjdXJFbnRbJ3RpbWUnXVsxXSk7DQogICAgICBsZXQgdG90YWxTZWNvbmRzID0gZW5kU2Vjb25kcyAtIHN0YXJ0U2Vjb25kczsNCiAgICAgIGxldCB0eXBlRHVyUmVTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgMTAwXSwgW3N0YXJ0U2Vjb25kcywgZW5kU2Vjb25kc10pOw0KICAgICAgbGV0IHR5cGVEYXRhID0geyAiMSI6IFtdLCAiMiI6IFtdLCAiMyI6IFtdIH07Ly87DQogICAgICBsZXQgdDEgPSB0b29scy5zZWNvbmRzMnRpbWUodHlwZUR1clJlU2NhbGVfbGluZWFyKHN0eWxlVmFsdWVbMF0pKTsNCiAgICAgIGxldCB0MiA9IHRvb2xzLnNlY29uZHMydGltZSh0eXBlRHVyUmVTY2FsZV9saW5lYXIoc3R5bGVWYWx1ZVsxXSkpOw0KICAgICAgdHlwZURhdGFbJzEnXS5wdXNoKFtjdXJFbnRbJ3RpbWUnXVswXSwgdDFdKTsNCiAgICAgIHR5cGVEYXRhWycyJ10ucHVzaChbdDEsIHQyXSk7DQogICAgICB0eXBlRGF0YVsnMyddLnB1c2goW3QyLCBjdXJFbnRbJ3RpbWUnXVsxXV0pOw0KICAgICAgY3VyRW50WyJhdHRyaWJ1dGUiXVsiZXhwcmVzc2lvbnMiXSA9IHR5cGVEYXRhOw0KDQogICAgICBsZXQgZW50UmVjdHMgPSBkMy5zZWxlY3RBbGwoIi5lZGl0RW50Iikubm9kZXMoKTsNCiAgICAgIGNvbnNvbGUubG9nKGVudFJlY3RzKQ0KICAgICAgbGV0IHRvdGFsU29uRHVyYXRpb24gPSBfdGhpcy50b3RhbFNvbkR1cmF0aW9uOw0KICAgICAgbGV0IHdpZCA9IF90aGlzLmVudExpbmVXaWR0aDsNCiAgICAgIGxldCBjeFJlTGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHdpZF0sIFswLCB0b3RhbFNvbkR1cmF0aW9uXSk7DQogICAgICBsZXQgcHJlVGltZSA9ICcnOw0KICAgICAgbGV0IHR5cGVUb3RhbERhdGEgPSB7ICIxIjogW10sICIyIjogW10sICIzIjogW10gfTsvLzsNCiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZW50UmVjdHMubGVuZ3RoOyBuKyspIHsNCiAgICAgICAgbGV0IGN1clJlY3QgPSBlbnRSZWN0c1tuXTsNCiAgICAgICAgbGV0IHJlY3RJZCA9IGN1clJlY3QuaWQuc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgbGV0IHJlY3REYXRhID0gZGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHJlY3RJZDsgfSk7DQogICAgICAgIGxldCBwZXJEdXIgPSB0b29scy50aW1lMnNlY29uZHMocmVjdERhdGFbJ3RpbWUnXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHMocmVjdERhdGFbJ3RpbWUnXVswXSk7DQogICAgICAgIGlmIChuID09IDApIHsNCiAgICAgICAgICBwcmVUaW1lID0gcmVjdERhdGFbJ3RpbWUnXVswXTsNCiAgICAgICAgfQ0KICAgICAgICBsZXQgcHJlU2Vjb25kID0gdG9vbHMudGltZTJzZWNvbmRzKHByZVRpbWUpOw0KICAgICAgICBsZXQgeCA9IGN1clJlY3QueC5iYXNlVmFsLnZhbHVlOw0KICAgICAgICBsZXQgdyA9IGN1clJlY3Qud2lkdGguYmFzZVZhbC52YWx1ZTsNCiAgICAgICAgbGV0IGR1clNlY29uZCA9IGN4UmVMaW5lYXIodyk7DQogICAgICAgIGxldCBlbmRUaW1lID0gdG9vbHMuc2Vjb25kczJ0aW1lKHByZVNlY29uZCArIGR1clNlY29uZCk7DQogICAgICAgIHJlY3REYXRhWyd0aW1lJ10gPSBbcHJlVGltZSwgZW5kVGltZV07DQogICAgICAgIHJlY3REYXRhWyd0b3RhbER1cmF0aW9uJ10gKz0gZHVyU2Vjb25kIC0gcGVyRHVyOw0KICAgICAgICBwcmVUaW1lID0gZW5kVGltZTsNCiAgICAgICAgZm9yIChsZXQgdCBpbiB0eXBlVG90YWxEYXRhKSB7DQogICAgICAgICAgdHlwZVRvdGFsRGF0YVt0XSA9IFsuLi50eXBlVG90YWxEYXRhW3RdLCAuLi5yZWN0RGF0YVsnYXR0cmlidXRlJ11bJ2V4cHJlc3Npb25zJ11bdF1dDQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIGNvbnNvbGUubG9nKHR5cGVUb3RhbERhdGEpDQogICAgICBfdGhpcy5kYXRhID0gZGF0YTsNCiAgICAgIC8vIGNvbnNvbGUubG9nKGVudFJlY3RzLGVudFJlY3RzWzBdKQ0KDQogICAgICBfdGhpcy5kcmF3RW50aXR5KGN1ckVudCk7DQogICAgICBfdGhpcy5kcmF3U29uTGluZShjdXJFbnQpOw0KICAgICAgX3RoaXMuZHJhd3Jvb3RUcmVlKCk7DQogICAgICBfdGhpcy4kYnVzLiRlbWl0KCJncmFwaERhdGEiLCBkYXRhKTsNCiAgICB9LA0KICAgIGNsaWNrX25vZGUoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgbm9kZUlkID0gX3RoaXMuY3VyRW50SWQ7DQogICAgICBsZXQgYWRkRGF0YUlkID0gX3RoaXMuaW5zZXJ0RW50SWQ7Ly9wYXJzZUludChub2RlSWQpKzErJyc7DQogICAgICBsZXQgb3JpRGF0YSA9IF90aGlzLmRhdGE7DQogICAgICBsZXQgc3RhdGUgPSBfdGhpcy50b29sc1N0YXRlOw0KICAgICAgbGV0IHJldHVybkRhdGEgPSBbXTsNCiAgICAgIGxldCByZXR1cm5SZWxEYXRhID0ge307DQogICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQoNCiAgICAgIGlmIChzdGF0ZSA9PSAnYWRkTm9kZVNvbicpIHsNCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlEYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgbGV0IGNEYXRhID0gb3JpRGF0YVtpXTsNCiAgICAgICAgICBsZXQgY0RhdGFJZCA9IGNEYXRhWydpZCddDQogICAgICAgICAgDQogICAgICAgICAgbGV0IHNvbnMgPSBjRGF0YVsnc29uJ107DQogICAgICAgICAgbGV0IHNvbnNOZXcgPSBbXTsNCiAgICAgICAgICBmb3IobGV0IHM9MDtzPHNvbnMubGVuZ3RoO3MrKyl7DQogICAgICAgICAgICBsZXQgc3MgPSBzb25zW3NdDQogICAgICAgICAgICAgIGlmKHBhcnNlSW50KHNzKT49cGFyc2VJbnQoYWRkRGF0YUlkKSkgc3MgPSBwYXJzZUludChzcykrMQ0KICAgICAgICAgICAgICBzb25zTmV3LnB1c2goc3MrJycpDQogICAgICAgICAgfQ0KICAgICAgICAgIGNEYXRhWydzb24nXSA9IHNvbnNOZXc7DQoNCiAgICAgICAgICBpZiAocGFyc2VJbnQoY0RhdGFJZCkgPT0gcGFyc2VJbnQoYWRkRGF0YUlkKSkgew0KICAgICAgICAgICAgbGV0IHBlckRhdGEgPSB0b29scy5kZWVwQ2xvbmUoY0RhdGEpOw0KICAgICAgICAgICAgbGV0IGFkZERhdGEgPSB0b29scy5kZWVwQ2xvbmUocGVyRGF0YSk7DQogICAgICAgICAgICBhZGREYXRhWydpZCddID0gYWRkRGF0YUlkOw0KICAgICAgICAgICAgcGVyRGF0YVsnaWQnXSA9IChwYXJzZUludChhZGREYXRhSWQpICsgMSkrJyc7DQogICAgICAgICAgICBjb25zb2xlLmxvZyhhZGREYXRhLHBlckRhdGEpDQogICAgICAgICAgICBsZXQgc3RhcnRUID0gY0RhdGFbJ3RpbWUnXVswXTsNCiAgICAgICAgICAgIGxldCBlbmRUID0gY0RhdGFbJ3RpbWUnXVsxXTsNCiAgICAgICAgICAgIGxldCBtaWRUID0gdG9vbHMuc2Vjb25kczJ0aW1lKCh0b29scy50aW1lMnNlY29uZHMoZW5kVCkgKyB0b29scy50aW1lMnNlY29uZHMoc3RhcnRUKSkgLyAyKTsNCiAgICAgICAgICAgIGFkZERhdGFbJ3RpbWUnXSA9IFtzdGFydFQsIG1pZFRdOw0KICAgICAgICAgICAgcGVyRGF0YVsndGltZSddID0gW21pZFQsIGVuZFRdOw0KICAgICAgICAgICAgYWRkRGF0YVsnc29uJ10gPSBbXTsNCiAgICAgICAgICAgIGFkZERhdGFbJ3RvdGFsRHVyYXRpb24nXSA9ICh0b29scy50aW1lMnNlY29uZHMobWlkVCkgLSB0b29scy50aW1lMnNlY29uZHMoc3RhcnRUKSk7DQogICAgICAgICAgICBwZXJEYXRhWyd0b3RhbER1cmF0aW9uJ10gLT0gYWRkRGF0YVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgICAgICAgbGV0IHR5cGVUaW1lcyA9IHBlckRhdGFbJ2F0dHJpYnV0ZSddWydleHByZXNzaW9ucyddOw0KICAgICAgICAgICAgbGV0IHR5cGVQcmVEYXRhID0geyAiMSI6IFtdLCAiMiI6IFtdLCAiMyI6IFtdIH07DQogICAgICAgICAgICBsZXQgdHlwZUFkZERhdGEgPSB7ICIxIjogW10sICIyIjogW10sICIzIjogW10gfTsNCiAgICAgICAgICAgIGZvciAobGV0IHQgaW4gdHlwZVRpbWVzKSB7DQogICAgICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdHlwZVRpbWVzW3RdLmxlbmd0aDsgYSsrKSB7DQogICAgICAgICAgICAgICAgbGV0IHN0ID0gdHlwZVRpbWVzW3RdW2FdWzBdOw0KICAgICAgICAgICAgICAgIGxldCBldCA9IHR5cGVUaW1lc1t0XVthXVsxXTsNCiAgICAgICAgICAgICAgICBpZiAodG9vbHMudGltZTJzZWNvbmRzKGV0KSA8PSB0b29scy50aW1lMnNlY29uZHMobWlkVCkpIHsgdHlwZUFkZERhdGFbdF0ucHVzaChbc3QsIGV0XSkgfQ0KICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb2xzLnRpbWUyc2Vjb25kcyhzdCkgPj0gdG9vbHMudGltZTJzZWNvbmRzKG1pZFQpKSB7IHR5cGVQcmVEYXRhW3RdLnB1c2goW3N0LCBldF0pIH0NCiAgICAgICAgICAgICAgICBlbHNlIGlmICgodG9vbHMudGltZTJzZWNvbmRzKHN0KSA8IHRvb2xzLnRpbWUyc2Vjb25kcyhtaWRUKSkgJiYgKHRvb2xzLnRpbWUyc2Vjb25kcyhldCkgPiB0b29scy50aW1lMnNlY29uZHMobWlkVCkpKSB7DQogICAgICAgICAgICAgICAgICB0eXBlQWRkRGF0YVt0XS5wdXNoKFtzdCwgbWlkVF0pOw0KICAgICAgICAgICAgICAgICAgdHlwZVByZURhdGFbdF0ucHVzaChbbWlkVCwgZXRdKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHBlckRhdGFbJ2F0dHJpYnV0ZSddWydleHByZXNzaW9ucyddID0gdHlwZVByZURhdGE7DQogICAgICAgICAgICBhZGREYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXSA9IHR5cGVBZGREYXRhOw0KICAgICAgICAgICAgcmV0dXJuRGF0YS5wdXNoKGFkZERhdGEpOw0KICAgICAgICAgICAgcmV0dXJuRGF0YS5wdXNoKHBlckRhdGEpOw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIGlmIChwYXJzZUludChjRGF0YVsnaWQnXSkgPCBwYXJzZUludChhZGREYXRhSWQpKSB7DQogICAgICAgICAgICByZXR1cm5EYXRhLnB1c2godG9vbHMuZGVlcENsb25lKGNEYXRhKSk7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKHBhcnNlSW50KGNEYXRhWydpZCddKSA+IHBhcnNlSW50KGFkZERhdGFJZCkpew0KICAgICAgICAgICAgbGV0IHBlckRhdGEgPSB0b29scy5kZWVwQ2xvbmUoY0RhdGEpOw0KICAgICAgICAgICAgcGVyRGF0YVsnaWQnXSA9IChwYXJzZUludChjRGF0YUlkKSArIDEpICsgJyc7DQogICAgICAgICAgICByZXR1cm5EYXRhLnB1c2gocGVyRGF0YSk7DQogICAgICAgICAgfQ0KDQogICAgICAgIH0NCiAgICAgIA0KICAgICAgbGV0IGJzTmV3ID0gW107DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBiYXNpY1JlbC5sZW5ndGg7IHIrKykgew0KICAgICAgICBsZXQgc291cmNlSWQgPSBiYXNpY1JlbFtyXVswXTsNCiAgICAgICAgbGV0IHRhcmdldElkID0gYmFzaWNSZWxbcl1bMV07DQogICAgICAgIGlmKHBhcnNlSW50KHNvdXJjZUlkKT49cGFyc2VJbnQoYWRkRGF0YUlkKSkgc291cmNlSWQgPSBwYXJzZUludChzb3VyY2VJZCkrMTsNCiAgICAgICAgaWYocGFyc2VJbnQodGFyZ2V0SWQpPj1wYXJzZUludChhZGREYXRhSWQpKSB0YXJnZXRJZCA9IHBhcnNlSW50KHRhcmdldElkKSsxOw0KICAgICAgICBic05ldy5wdXNoKFtzb3VyY2VJZCsnJyx0YXJnZXRJZCsnJ10pDQogICAgICB9DQogICAgICBsZXQgc3NOZXcgPSBbXQ0KICAgICAgbGV0IHNpbWlsYXJpdHlSZWwgPSByZWxEYXRhWydzaW1pbGFyaXR5UmVsJ107DQogICAgICBmb3IgKGxldCByID0gMDsgciA8IHNpbWlsYXJpdHlSZWwubGVuZ3RoOyByKyspIHsNCiAgICAgICAgbGV0IHNvdXJjZUlkID0gc2ltaWxhcml0eVJlbFtyXVswXTsNCiAgICAgICAgbGV0IHRhcmdldElkID0gc2ltaWxhcml0eVJlbFtyXVsxXTsNCiAgICAgICAgaWYocGFyc2VJbnQoc291cmNlSWQpPj1wYXJzZUludChhZGREYXRhSWQpKSBzb3VyY2VJZCA9IHBhcnNlSW50KHNvdXJjZUlkKSsxOw0KICAgICAgICBpZihwYXJzZUludCh0YXJnZXRJZCk+PXBhcnNlSW50KGFkZERhdGFJZCkpIHRhcmdldElkID0gcGFyc2VJbnQodGFyZ2V0SWQpKzE7DQogICAgICAgIHNzTmV3LnB1c2goW3NvdXJjZUlkKycnLHRhcmdldElkKycnXSkNCiAgICAgIH0NCiAgICAgIHJldHVyblJlbERhdGEgPSB7J2Jhc2ljUmVsJzpic05ldywnc2ltaWxhcml0eVJlbCc6c3NOZXd9Ow0KICAgICAgbGV0IG5EYXRhID0gcmV0dXJuRGF0YS5maW5kKGZ1bmN0aW9uKGQpe3JldHVybiBkWydpZCddID09IG5vZGVJZH0pOw0KICAgICAgbGV0IGFEYXRhID0gcmV0dXJuRGF0YS5maW5kKGZ1bmN0aW9uKGQpe3JldHVybiBkWydpZCddID09IGFkZERhdGFJZH0pOw0KICAgICAgaWYobm9kZUlkIT0nLTEnKXsNCiAgICAgICAgbkRhdGFbJ3NvbiddLnB1c2goYWRkRGF0YUlkKTsNCiAgICAgICAgYURhdGFbJ2xheW91dCddID0gcGFyc2VJbnQobkRhdGFbJ2xheW91dCddKzEpOw0KICAgICAgICBhRGF0YVsnZmF0aGVyJ10gPSBbbm9kZUlkXTsNCiAgICAgIH0NCiAgICAgIGVsc2V7DQogICAgICAgIGFEYXRhWydsYXlvdXQnXSA9ICcwJzsNCiAgICAgIH0NCiAgICAgIF90aGlzLmRhdGEgPSAocmV0dXJuRGF0YSk7DQogICAgICBfdGhpcy5yZWxEYXRhID0gcmV0dXJuUmVsRGF0YTsNCiAgICAgIF90aGlzLmdldFRyZWVEYXRhKCk7DQogICAgICBfdGhpcy51cGRhdGEoKTsNCiAgICAgIH0NCiAgICAgIGlmIChzdGF0ZSA9PSAnYWRkTGlua0Jhc2ljJykgew0KICAgICAgICBsZXQgYWRkU291cmNlRGF0YUlkID0gX3RoaXMuaW5zZXJ0U291cmNlRW50SWQ7DQogICAgICAgIGxldCBhZGRUYXJnZXREYXRhSWQgPSBfdGhpcy5pbnNlcnRUYXJnZXRFbnRJZDsNCiAgICAgICAgaWYoKGFkZFNvdXJjZURhdGFJZCAhPSAnLTEnKSYmKGFkZFRhcmdldERhdGFJZCAhPSAnLTEnKSl7DQogICAgICAgICAgcmV0dXJuUmVsRGF0YSA9ICB0b29scy5kZWVwQ2xvbmUocmVsRGF0YSk7DQogICAgICAgICAgcmV0dXJuUmVsRGF0YVsnYmFzaWNSZWwnXS5wdXNoKFthZGRTb3VyY2VEYXRhSWQsYWRkVGFyZ2V0RGF0YUlkXSk7DQogICAgICAgICAgX3RoaXMuaW5zZXJ0U291cmNlRW50SWQgPSAnLTEnOw0KICAgICAgICAgIF90aGlzLmluc2VydFRhcmdldEVudElkID0gJy0xJzsNCiAgICAgICAgICBfdGhpcy5yZWxEYXRhID0gcmV0dXJuUmVsRGF0YTsNCiAgICAgICAgICBfdGhpcy5nZXRUcmVlRGF0YSgpOw0KICAgICAgICAgIF90aGlzLnVwZGF0YSgpOw0KICAgICAgICB9DQogICAgICB9DQogICAgfSwNCiAgICBhZGROb2RlU29uQ2xrKCkgew0KICAgICAgdGhpcy50b29sc1N0YXRlID0gJ2FkZE5vZGVTb24nOw0KICAgIH0sDQogICAgYWRkTm9kZVBlckNsaygpIHsNCiAgICAgIHRoaXMudG9vbHNTdGF0ZSA9ICdhZGROb2RlUGVyJzsNCiAgICB9LA0KICAgIGFkZExpbmtCYXNpY0NsaygpIHsNCiAgICAgIHRoaXMudG9vbHNTdGF0ZSA9ICdhZGRMaW5rQmFzaWMnOw0KICAgIH0sDQogICAgZHJhd3RvcGljTGluZSgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGNvbnN0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGNvbnN0IGNvbG9yID0gX3RoaXMubWNvbG9yOw0KDQogICAgICBsZXQgd2lkdGggPSB0aGlzLiRyZWZzLnRvcGljTGluZS5vZmZzZXRXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0Ow0KICAgICAgbGV0IGhlaWdodCA9IHRoaXMuJHJlZnMudG9waWNMaW5lLm9mZnNldEhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tOw0KICAgICAgX3RoaXMudG9waWNMaW5lV2lkdGggPSB3aWR0aDsNCiAgICAgIF90aGlzLnRvcGljTGluZUhlaWdodCA9IGhlaWdodDsNCiAgICAgIGQzLnNlbGVjdCgiI3RvcGljTGluZSIpLnNlbGVjdCgic3ZnIikucmVtb3ZlKCk7DQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjdG9waWNMaW5lIikuYXBwZW5kKCJzdmciKQ0KICAgICAgICAuYXR0cigiaWQiLCAidG9waWNMaW5lU3ZnIikNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICBsZXQgZ3JvdXBzID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImdyb3VwcyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgcm9vdEVudEcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAicm9vdEVudEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IG9yaUxpbmVHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgIm9yaUxpbmVHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCg0KICAgICAgb3JpTGluZUcuYXBwZW5kKCJsaW5lIikNCiAgICAgICAgLmF0dHIoIngxIiwgMCkNCiAgICAgICAgLmF0dHIoInkxIiwgaGVpZ2h0IC8gMikNCiAgICAgICAgLmF0dHIoIngyIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJ5MiIsIGhlaWdodCAvIDIpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCAicmdiKDIwMCwyMDAsMjAwKSIpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCAiNXB4Iik7DQoNCiAgICAgIGxldCBjeExpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBfdGhpcy52aWRlb0R1cmF0aW9uXSwgW21hcmdpbi5sZWZ0LCB3aWR0aF0pDQoNCiAgICAgIGxldCBkYXRhID0gdG9vbHMuZGVlcENsb25lKF90aGlzLmRhdGEpOw0KICAgICAgbGV0IERpdmlzaW9uRGF0YUxpc3QgPSBbXTsNCiAgICAgIGxldCBjb2xvckluZGV4ID0gMDsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykgew0KICAgICAgICBpZiAoZGF0YVtpXVsnbGF5b3V0J10gPT0gJzAnKSB7DQogICAgICAgICAgaWYgKERpdmlzaW9uRGF0YUxpc3QubGVuZ3RoICE9IDApIHsNCiAgICAgICAgICAgIERpdmlzaW9uRGF0YUxpc3RbRGl2aXNpb25EYXRhTGlzdC5sZW5ndGggLSAxXVsnbmV4dElkJ10gPSBkYXRhW2ldWydpZCddOw0KICAgICAgICAgICAgZGF0YVtpXVsncHJlSWQnXSA9IERpdmlzaW9uRGF0YUxpc3RbRGl2aXNpb25EYXRhTGlzdC5sZW5ndGggLSAxXVsnaWQnXTsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7IGRhdGFbaV1bJ3ByZUlkJ10gPSAiLTEiOyB9DQogICAgICAgICAgRGl2aXNpb25EYXRhTGlzdC5wdXNoKGRhdGFbaV0pOw0KICAgICAgICAgIGxldCB0aW1lID0gdG9vbHMudGltZTJzZWNvbmRzKGRhdGFbaV1bJ3RpbWUnXVswXSk7DQogICAgICAgICAgbGV0IGVuZFRpbWUgPSB0b29scy50aW1lMnNlY29uZHMoZGF0YVtpXVsndGltZSddWzBdKSArIGRhdGFbaV1bJ3RvdGFsRHVyYXRpb24nXTsNCiAgICAgICAgICBsZXQgY3ggPSBjeExpbmVhcih0aW1lKTsNCiAgICAgICAgICBsZXQgZW5keCA9IGN4TGluZWFyKGVuZFRpbWUpOw0KICAgICAgICAgIF90aGlzLmNvbG9yTWFwW2RhdGFbaV1bJ2lkJ11dID0gY29sb3JJbmRleCAlIGNvbG9yLmxlbmd0aDsNCiAgICAgICAgICBfdGhpcy5kcmF3UmVjdChvcmlMaW5lRywgY3ggLSA1LCBoZWlnaHQgLyAyIC0gNSwgMTAsIDEwLCBoZWlnaHQgLyAyLCAiZGl2aXNpb25fIiArIGRhdGFbaV1bImlkIl0sICJyb290ZGl2aXNpb25MaW5lIiwgInJnYigyNTAsMjUwLDI1MCkiLCAwLCAnJywgMSkNCiAgICAgICAgICBfdGhpcy5kcmF3UmVjdChyb290RW50RywgY3gsIG1hcmdpbi50b3AsIGVuZHggLSBjeCwgaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sIGhlaWdodCAvIDIsICJyb290RW50XyIgKyBkYXRhW2ldWydpZCddLCAicm9vdEVudCIsIGNvbG9yW190aGlzLmNvbG9yTWFwW2RhdGFbaV1bJ2lkJ11dXSwgNSwgInJnYigxNTAsMTUwLDE1MCkiLCAwLjEpDQogICAgICAgICAgY29sb3JJbmRleCsrOw0KICAgICAgICB9DQogICAgICB9DQogICAgICBEaXZpc2lvbkRhdGFMaXN0W0RpdmlzaW9uRGF0YUxpc3QubGVuZ3RoIC0gMV1bJ25leHRJZCddID0gIi0xIjsNCiAgICAgIF90aGlzLnJvb3REaXZpc2lvbkRhdGFMaXN0ID0gRGl2aXNpb25EYXRhTGlzdDsNCg0KICAgICAgLy8gb3JpTGluZUcuYXBwZW5kKCJlbGxpcHNlIikNCiAgICAgIC8vIC5hdHRyKCJjeCIsNTApDQogICAgICAvLyAuYXR0cigiY3kiLGhlaWdodC8yKQ0KICAgICAgLy8gLmF0dHIoInJ4Iiw1MCkNCiAgICAgIC8vIC5hdHRyKCJyeSIsaGVpZ2h0LzIpDQogICAgICAvLyAuYXR0cigiZmlsbCIsY29sb3JbM10pDQogICAgICAvLyAuYXR0cigic3Ryb2tlIiwgY29sb3JbM10pDQoNCiAgICAgIC8vIC5hdHRyKCJzdHJva2Utd2lkdGgiLCAiNXB4Iik7DQogICAgICAvLyBjb25zb2xlLmxvZyhkYXRhKQ0KICAgICAgLy8gdGhpcy4kYnVzLiRlbWl0KCJnZXREYXRhIixkYXRhKQ0KICAgIH0sDQogICAgZHJhd1JlY3Qoc3ZnLCB4LCB5LCB3LCBoLCByeCwgaWROYW1lLCBjbGFzc05hbWUsIGZpbGwsIHN0cm9rZVdpZHRoLCBzdHJva2UsIG9wYWNpdHkpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIHN2Zy5hcHBlbmQoInJlY3QiKQ0KICAgICAgICAuYXR0cigieCIsIHgpDQogICAgICAgIC5hdHRyKCJ5IiwgeSkNCiAgICAgICAgLmF0dHIoImlkIiwgaWROYW1lKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgdykNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGgpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgLmF0dHIoInJ4IiwgcngpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpLy8icmdiKDE1MCwxNTAsMTUwKSIpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCBzdHJva2VXaWR0aCkNCiAgICAgICAgLm9uKCJtb3VzZWRvd24iLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIF90aGlzLnNlbGVjdFJlY3RJZCA9IGlkTmFtZS5zcGxpdCgiXyIpWzFdIC8vZDMuc2VsZWN0KHRoaXMpLmF0dHIoImlkIik7DQogICAgICAgICAgaWYgKGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpID09ICJyb290ZGl2aXNpb25MaW5lIikgew0KICAgICAgICAgICAgX3RoaXMuc2VsZWN0UmVjdENsYXNzID0gInJvb3RFbnQiOw0KICAgICAgICAgICAgX3RoaXMubW92ZUxpbmVXaWR0aCA9IF90aGlzLnRvcGljTGluZVdpZHRoOw0KICAgICAgICAgICAgX3RoaXMuRGl2aXNpb25EYXRhTGlzdCA9IF90aGlzLnJvb3REaXZpc2lvbkRhdGFMaXN0Ow0KICAgICAgICAgICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvcGljTGluZVN2ZycpLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbW92ZSIsIF90aGlzLm1vdmVSZWN0KTsgLy8g55uR5ZCs54K55Ye75LqL5Lu2DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpID09ICJlbnRkaXZpc2lvbkxpbmUiKSB7DQogICAgICAgICAgICBfdGhpcy5zZWxlY3RSZWN0Q2xhc3MgPSAiZWRpdEVudCI7DQogICAgICAgICAgICBfdGhpcy5tb3ZlTGluZVdpZHRoID0gX3RoaXMuZW50TGluZVdpZHRoOw0KICAgICAgICAgICAgX3RoaXMuRGl2aXNpb25EYXRhTGlzdCA9IF90aGlzLmVudERpdmlzaW9uRGF0YUxpc3Q7DQogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdEVudCcpLmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbW92ZSIsIF90aGlzLm1vdmVSZWN0KTsgLy8g55uR5ZCs54K55Ye75LqL5Lu2DQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNldXAiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b3BpY0xpbmVTdmcnKS5yZW1vdmVFdmVudExpc3RlbmVyKCJtb3VzZW1vdmUiLCBfdGhpcy5tb3ZlUmVjdCk7IC8vIA0KICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0RW50JykucmVtb3ZlRXZlbnRMaXN0ZW5lcigibW91c2Vtb3ZlIiwgX3RoaXMubW92ZVJlY3QpOyAvLyANCiAgICAgICAgICAvLyBfdGhpcy4kYnVzLiRlbWl0KCJncmFwaERhdGEiLCBfdGhpcy5kYXRhKTsNCg0KICAgICAgICAgIF90aGlzLiRidXMuJGVtaXQoInRyZWVEYXRhIiwgX3RoaXMudHJlZURhdGEpOw0KICAgICAgICB9KQ0KICAgIH0sDQogICAgbW92ZVJlY3QoZSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHNlbGVjdFJlY3QgPSBfdGhpcy5EaXZpc2lvbkRhdGFMaXN0LmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gX3RoaXMuc2VsZWN0UmVjdElkOyB9KS8v5Y+z6L6555qEcmVjdA0KICAgICAgbGV0IHByZUlkID0gc2VsZWN0UmVjdFsncHJlSWQnXTsvL+W3pui+ueeahHJlY3QNCiAgICAgIGxldCBuZXh0SWQgPSBzZWxlY3RSZWN0WyduZXh0SWQnXTsvL+WPs+i+ueeahOWPs+i+uXJlY3QNCiAgICAgIGxldCByZWN0Q2xhc3MgPSBfdGhpcy5zZWxlY3RSZWN0Q2xhc3M7DQogICAgICBsZXQgcHJleCA9IDA7DQogICAgICBpZiAocHJlSWQgIT0gJy0xJykgew0KICAgICAgICBwcmV4ID0gZDMuc2VsZWN0KCIjIiArIHJlY3RDbGFzcyArICJfIiArIHByZUlkKS5hdHRyKCJ4IikNCiAgICAgICAgZDMuc2VsZWN0KCIjIiArIHJlY3RDbGFzcyArICJfIiArIHByZUlkKQ0KICAgICAgICAgIC5hdHRyKCJ3aWR0aCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICByZXR1cm4gZS5vZmZzZXRYIC0gcHJleDsNCiAgICAgICAgICB9KQ0KICAgICAgfQ0KICAgICAgbGV0IG5leHRYID0gMTAwOw0KICAgICAgaWYgKG5leHRJZCA9PSAnLTEnKSB7DQogICAgICAgIG5leHRYID0gX3RoaXMubW92ZUxpbmVXaWR0aDsNCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KICAgICAgICBuZXh0WCA9IGQzLnNlbGVjdCgiIyIgKyByZWN0Q2xhc3MgKyAiXyIgKyBuZXh0SWQpLmF0dHIoIngiKTsNCiAgICAgIH0NCiAgICAgIGQzLnNlbGVjdCgiIyIgKyByZWN0Q2xhc3MgKyAiXyIgKyBfdGhpcy5zZWxlY3RSZWN0SWQpDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgcmV0dXJuIG5leHRYIC0gZS5vZmZzZXRYOw0KICAgICAgICB9KQ0KICAgICAgICAuYXR0cigieCIsIGUub2Zmc2V0WCkNCiAgICAgIGQzLnNlbGVjdCgiI2RpdmlzaW9uXyIgKyBfdGhpcy5zZWxlY3RSZWN0SWQpDQogICAgICAgIC5hdHRyKCJ4IiwgZS5vZmZzZXRYIC0gNSkNCg0KICAgICAgaWYgKChlLm9mZnNldFggPiAoX3RoaXMudG9waWNMaW5lV2lkdGgpKSB8fCAoZS5vZmZzZXRYIDwgKDApKSB8fCAoZS5vZmZzZXRZID4gKF90aGlzLnRvcGljTGluZUhlaWdodCkpIHx8IChlLm9mZnNldFkgPCAoMCkpKSB7DQogICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b3BpY0xpbmVTdmcnKS5yZW1vdmVFdmVudExpc3RlbmVyKCJtb3VzZW1vdmUiLCBfdGhpcy5tb3ZlUmVjdCk7IC8vIA0KICAgICAgfQ0KICAgIH0sDQogICAgZ2V0VHJlZURhdGEoKXsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBvcmlEYXRhID0gdG9vbHMuZGVlcENsb25lKHRoaXMuZGF0YSk7DQogICAgICB2YXIgZGF0YSA9IHsNCiAgICAgICAgIm5hbWUiOiAicm9vdCIsDQogICAgICAgICJjaGlsZHJlbiI6IFtdDQogICAgICB9Ow0KDQogICAgICBmb3IgKGxldCBpID0gb3JpRGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgew0KICAgICAgICBsZXQgc29ucyA9IG9yaURhdGFbaV1bJ3NvbiddOw0KICAgICAgICBvcmlEYXRhW2ldWydjaGlsZHJlbiddID0gW107DQogICAgICAgIGlmIChzb25zLmxlbmd0aCA+IDApIHsNCiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHNvbnMubGVuZ3RoOyBzKyspIHsNCiAgICAgICAgICAgIG9yaURhdGFbaV1bJ2NoaWxkcmVuJ10ucHVzaChvcmlEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29uc1tzXSB9KSkNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIGxldCBjID0gMCA7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaURhdGEubGVuZ3RoOyBpKyspIHsNCg0KICAgICAgICBsZXQgbGF5b3V0ID0gb3JpRGF0YVtpXVsnbGF5b3V0J107DQogICAgICAgIGlmIChsYXlvdXQgPT0gJzAnKSB7DQogICAgICAgICAgZGF0YVsnY2hpbGRyZW4nXS5wdXNoKG9yaURhdGFbaV0pOw0KICAgICAgICAgIGlmKG9yaURhdGFbaV1bJ25hbWUnXSE9IlRlc3QiKXsNCiAgICAgICAgICAgIF90aGlzLnJvb3RDb2xvck1hcFtvcmlEYXRhW2ldWydpZCddXSA9IF90aGlzLm1jb2xvcltjXTsNCiAgICAgICAgICAgIGMrKzsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZXsNCiAgICAgICAgICAgIF90aGlzLnJvb3RDb2xvck1hcFtvcmlEYXRhW2ldWydpZCddXSA9InJnYigyNTAsIDE5OSwgODgpIjsNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgIH0NCg0KICAgICAgdGhpcy50cmVlRGF0YSA9IGRhdGE7DQogICAgICBjb25zb2xlLmxvZyhfdGhpcy5yb290Q29sb3JNYXApDQogICAgICB0aGlzLiRidXMuJGVtaXQoInRyZWVEYXRhIiwgW2RhdGEsX3RoaXMucm9vdENvbG9yTWFwXSk7DQogICAgfSwNCiAgICBkcmF3cm9vdFRyZWUoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBjb25zdCBtYXJnaW4gPSBfdGhpcy5tYXJnaW47DQogICAgICBsZXQgd2lkdGggPSB0aGlzLiRyZWZzLnJvb3RUcmVlLm9mZnNldFdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7DQogICAgICBsZXQgaGVpZ2h0ID0gdGhpcy4kcmVmcy5yb290VHJlZS5vZmZzZXRIZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCg0KICAgICAgbGV0IGNvbG9yID0gX3RoaXMubWNvbG9yOw0KICAgICAgbGV0IGNvbG9yTWFwID0gX3RoaXMuY29sb3JNYXA7DQogICAgICAvLyB2YXIgdHJlZSA9IGQzLnRyZWUoKQ0KICAgICAgLy8gICAuc2l6ZShbd2lkdGgsIGhlaWdodCAtIDIwMF0pOw0KICAgICAgZDMuc2VsZWN0KCIjcm9vdFRyZWUiKS5zZWxlY3QoInN2ZyIpLnJlbW92ZSgpOw0KICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgiI3Jvb3RUcmVlIikuYXBwZW5kKCJzdmciKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCkNCg0KICAgICAgbGV0IHRyYW5zWSA9IGhlaWdodDsNCiAgICAgIGxldCB0cmVlR1RyYW5zZm9ybVggPSBfdGhpcy50cmVlR1RyYW5zZm9ybVg7DQogICAgICBsZXQgdHJlZUdUcmFuc2Zvcm1ZID0gX3RoaXMudHJlZUdUcmFuc2Zvcm1ZOw0KICAgICAgbGV0IHRyZWVHVHJhbnNmb3JtSyA9IF90aGlzLnRyZWVHVHJhbnNmb3JtSzsNCiAgICAgIGxldCBncm91cHMgPSBzdmcuYXBwZW5kKCJnIikNCiAgICAgICAgLmF0dHIoImlkIiwgImVkaXRyb290VHJlZWciKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCkNCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsICAidHJhbnNsYXRlKCIrdHJlZUdUcmFuc2Zvcm1YKycsJyArdHJlZUdUcmFuc2Zvcm1ZICsgIikgc2NhbGUoIit0cmVlR1RyYW5zZm9ybUsrIikiKTsNCg0KICAgICAgICBsZXQgc3R4ID0gMDsNCiAgICAgICAgbGV0IHN0eSA9IDA7DQogICAgICAgIGxldCBzdGsgPTE7DQogICAgICB2YXIgZ3JhcGhab29tID0gZDMuem9vbSgpDQogICAgICAgIC5zY2FsZUV4dGVudChbMCwgMTBdKQ0KICAgICAgICAub24oInN0YXJ0IiwgKGUpID0+IHsNCiAgICAgICAgICBzdHkgPSBlLnRyYW5zZm9ybS55Ow0KICAgICAgICAgIHN0eCA9IGUudHJhbnNmb3JtLng7DQogICAgICAgICAgc3RrID0gZS50cmFuc2Zvcm0uazsNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCd6b29tJywgKGUpID0+IHsNCiAgICAgICAgICB0cmVlR1RyYW5zZm9ybVggPSBfdGhpcy50cmVlR1RyYW5zZm9ybVggKyBlLnRyYW5zZm9ybS54IC0gc3R4Ow0KICAgICAgICAgIHRyZWVHVHJhbnNmb3JtWSA9IF90aGlzLnRyZWVHVHJhbnNmb3JtWSArIGUudHJhbnNmb3JtLnkgLSBzdHk7DQogICAgICAgICAgdHJlZUdUcmFuc2Zvcm1LID0gX3RoaXMudHJlZUdUcmFuc2Zvcm1LICsgZS50cmFuc2Zvcm0uayAtIHN0azsNCiAgICAgICAgICBncm91cHMuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHRyZWVHVHJhbnNmb3JtWCkgKyAnLCcgKyAodHJlZUdUcmFuc2Zvcm1ZKSArICcpIHNjYWxlKCcgKyAodHJlZUdUcmFuc2Zvcm1LKSArICcpJykNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCdlbmQnLCAoZSkgPT4gew0KICAgICAgICAgIF90aGlzLnRyZWVHVHJhbnNmb3JtWCA9IHRyZWVHVHJhbnNmb3JtWDsNCiAgICAgICAgICBfdGhpcy50cmVlR1RyYW5zZm9ybVkgPSB0cmVlR1RyYW5zZm9ybVk7DQogICAgICAgICAgX3RoaXMudHJlZUdUcmFuc2Zvcm1LID0gdHJlZUdUcmFuc2Zvcm1LOw0KICAgICAgICAgIGdyb3Vwcy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAodHJlZUdUcmFuc2Zvcm1YKSArICcsJyArICh0cmVlR1RyYW5zZm9ybVkpICsgJykgc2NhbGUoJyArICh0cmVlR1RyYW5zZm9ybUspICsgJyknKQ0KICAgICAgICB9KTsNCiAgICAgIHN2Zy5jYWxsKGdyYXBoWm9vbSkNCg0KICAgICAgY29uc3QgZ0xpbmsgPSBncm91cHMuYXBwZW5kKCJnIikNCiAgICAgICAgLmF0dHIoImZpbGwiLCAibm9uZSIpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCAiIzU1NSIpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyBtYXJnaW4ubGVmdCArICIsIiArIG1hcmdpbi50b3AgKyAiKSIpDQogICAgICAgIC5hdHRyKCJzdHJva2Utb3BhY2l0eSIsIDAuNCkNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIDEuNSk7DQoNCiAgICAgIGNvbnN0IGdOb2RlID0gZ3JvdXBzLmFwcGVuZCgiZyIpDQogICAgICAgIC5hdHRyKCJjdXJzb3IiLCAicG9pbnRlciIpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyBtYXJnaW4ubGVmdCArICIsIiArIG1hcmdpbi50b3AgKyAiKSIpDQogICAgICAgIC5hdHRyKCJwb2ludGVyLWV2ZW50cyIsICJhbGwiKQ0KDQogICAgICBsZXQgZGF0YSA9IF90aGlzLnRyZWVEYXRhOw0KICAgICAgbGV0IGRpYWdvbmFsID0gZDMubGlua0hvcml6b250YWwoKS54KGQgPT4gZC55KS55KGQgPT4gZC54KTsNCiAgICAgIGxldCB0cmVlID0gZDMudHJlZSgpLm5vZGVTaXplKFs1MCwgMTUwXSk7Ly8uc2l6ZShbKGhlaWdodCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSAqIDIsICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KS0xMF0pDQogICAgICBjb25zdCByb290ID0gZDMuaGllcmFyY2h5KGRhdGEpOw0KICAgICAgY29uc3Qgbm9kZXMgPSByb290LmRlc2NlbmRhbnRzKCkucmV2ZXJzZSgpOw0KICAgICAgY29uc3QgbGlua3MgPSByb290LmxpbmtzKCk7DQogICAgICB0cmVlKHJvb3QpOw0KICAgICAgY29uc29sZS5sb2cobm9kZXMpDQogICAgICBjb25zdCBub2RlID0gZ05vZGUuc2VsZWN0QWxsKCJnIikNCiAgICAgICAgLmRhdGEobm9kZXMsIGQgPT4gZC5pZCk7DQoNCiAgICAgIGNvbnN0IG5vZGVFbnRlciA9IG5vZGUuZGF0YShub2RlcykuZW50ZXIoKS5hcHBlbmQoImciKQ0KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgKGQpID0+IHsNCiAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke2QueX0sJHtkLnh9KWANCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCJjbGljayIsIChldmVudCwgZCkgPT4gew0KICAgICAgICAgIGQuY2hpbGRyZW4gPSBkLmNoaWxkcmVuID8gbnVsbCA6IGQuX2NoaWxkcmVuOw0KICAgICAgICAgIC8vIHVwZGF0ZShkKTsNCiAgICAgICAgfSkNCg0KICAgICAgbm9kZUVudGVyLmFwcGVuZCgiY2lyY2xlIikNCiAgICAgICAgLmF0dHIoInIiLCAxMCkNCiAgICAgICAgLmF0dHIoImlkIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBjb25zb2xlLmxvZyhkKQ0KICAgICAgICAgIGlmKGQuZGF0YS5uYW1lID09ICdyb290JykNCiAgICAgICAgICAgIHJldHVybiAidHJlZU5vZGVfLTEiOw0KICAgICAgICAgIHJldHVybiAidHJlZU5vZGVfIiArIGQuZGF0YS5pZDsNCiAgICAgICAgfSkNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGlmIChkLmRhdGEubmFtZSA9PSAncm9vdCcpIHsNCiAgICAgICAgICAgIHJldHVybiAnZ3JleScNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICBsZXQgcGFyZW50ID0gZC5wYXJlbnQ7DQogICAgICAgICAgICBsZXQgcm9vdGQgPSBudWxsOw0KICAgICAgICAgICAgd2hpbGUgKHBhcmVudC5kYXRhLm5hbWUgIT0gJ3Jvb3QnKSB7DQogICAgICAgICAgICAgIHJvb3RkID0gcGFyZW50Ow0KICAgICAgICAgICAgICBpZiAocGFyZW50LnBhcmVudC5kYXRhLm5hbWUgPT0gJ3Jvb3QnKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yW2NvbG9yTWFwW3BhcmVudC5kYXRhLmlkXV0NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIGNvbG9yW2NvbG9yTWFwW2QuZGF0YS5pZF1dDQogICAgICAgICAgfQ0KDQogICAgICAgIH0pDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCAicmdiKDEwMCwxMDAsMTAwKSIpDQogICAgICAgIC8vIC5hdHRyKCJmaWxsIiwgZCA9PiBkLl9jaGlsZHJlbiA/ICIjNTU1IiA6ICIjOTk5IikNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIDEpDQogICAgICAgIC5vbigibW91c2VvdmVyIiwgZnVuY3Rpb24gKCkgew0KICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJyIiwgMTUpOw0KDQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2VsZWF2ZSIsIGZ1bmN0aW9uICgpIHsNCiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiciIsIDEwKQ0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlZG93biIsIGZ1bmN0aW9uICgpIHsNCiAgICAgICAgICBsZXQgbm9kZUlkTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJpZCIpOw0KICAgICAgICAgIGxldCBub2RlSWQgPSBub2RlSWROLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgX3RoaXMuY3VyRW50SWQgPSBub2RlSWQ7DQogICAgICAgICAgaWYobm9kZUlkID09ICctMScpew0KICAgICAgICAgICAgX3RoaXMuaW5zZXJ0RW50SWQgPSBwYXJzZUludChub2RlSWQpICsgMSArICcnOw0KICAgICAgICAgIF90aGlzLmNsaWNrX25vZGUoKTsNCiAgICAgICAgICAgIHJldHVybg0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgY3VyRGF0YSA9IF90aGlzLmRhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBub2RlSWQ7IH0pOw0KICAgICAgICAgIGlmIChfdGhpcy50b29sc1N0YXRlID09ICdhZGROb2RlU29uJykgew0KICAgICAgICAgICAgX3RoaXMuaW5zZXJ0RW50SWQgPSBwYXJzZUludChub2RlSWQpICsgMSArICcnOw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIGlmIChfdGhpcy50b29sc1N0YXRlID09ICdhZGRMaW5rQmFzaWMnKSB7DQogICAgICAgICAgICBpZihfdGhpcy5pbnNlcnRTb3VyY2VFbnRJZCA9PSItMSIpDQogICAgICAgICAgICAgIF90aGlzLmluc2VydFNvdXJjZUVudElkID0gcGFyc2VJbnQobm9kZUlkKSArICcnOw0KICAgICAgICAgICAgZWxzZXsNCiAgICAgICAgICAgICAgX3RoaXMuaW5zZXJ0VGFyZ2V0RW50SWQgPSBwYXJzZUludChub2RlSWQpICsgJyc7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIGlmICggKGN1ckRhdGFbJ3NvbiddLmxlbmd0aCA+IDApKSB7DQogICAgICAgICAgICBfdGhpcy5pbnNlcnRFbnRJZCA9IHBhcnNlSW50KGN1ckRhdGFbJ3NvbiddWzBdKSArIDEgKycnOw0KICAgICAgICAgIH07DQogICAgICAgICAgX3RoaXMuY2xpY2tfbm9kZSgpOw0KICAgICAgICB9KQ0KDQogICAgICAvLyBub2RlRW50ZXIuYXBwZW5kKCJ0ZXh0IikNCiAgICAgIC8vICAgLmF0dHIoImR5IiwgIjAuMzFlbSIpDQogICAgICAvLyAgIC5hdHRyKCJ4IiwgZCA9PiBkLl9jaGlsZHJlbiA/IC02IDogNikNCiAgICAgIC8vICAgLmF0dHIoInRleHQtYW5jaG9yIiwgZCA9PiBkLl9jaGlsZHJlbiA/ICJlbmQiIDogInN0YXJ0IikNCiAgICAgIC8vICAgLnRleHQoZCA9PiBkLmRhdGEubmFtZSkNCiAgICAgIC8vICAgLmNsb25lKHRydWUpLmxvd2VyKCkNCiAgICAgIC8vICAgLmF0dHIoInN0cm9rZS1saW5lam9pbiIsICJyb3VuZCIpDQogICAgICAvLyAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCAzKQ0KICAgICAgLy8gICAuYXR0cigic3Ryb2tlIiwgIndoaXRlIik7DQoNCiAgICAgIGNvbnN0IGxpbmsgPSBnTGluay5zZWxlY3RBbGwoInBhdGgiKQ0KICAgICAgICAuZGF0YShsaW5rcywgZCA9PiBkLnRhcmdldC5pZCk7DQoNCiAgICAgIGNvbnN0IGxpbmtFbnRlciA9IGxpbmsuZW50ZXIoKS5hcHBlbmQoInBhdGgiKQ0KICAgICAgICAuYXR0cigiZCIsIGQgPT4gew0KICAgICAgICAgIGNvbnN0IG8gPSB7IHg6IGQuc291cmNlLngsIHk6IGQuc291cmNlLnkgfTsNCiAgICAgICAgICBjb25zdCBwID0geyB4OiBkLnRhcmdldC54LCB5OiBkLnRhcmdldC55IH0NCiAgICAgICAgICByZXR1cm4gZGlhZ29uYWwoeyBzb3VyY2U6IG8sIHRhcmdldDogcCB9KTsNCiAgICAgICAgfSkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsICJyZ2IoMTAwLDEwMCwxMDApIikNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIDUpDQogICAgICBfdGhpcy5kcmF3Um9vdFRyZWVSZWwoZ0xpbmssIG5vZGVzKTsNCiAgICB9LA0KICAgIGRyYXdSb290VHJlZVJlbChzdmcsIG5vZGVEYXRhKSB7DQoNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCByZWxEYXRhID0gX3RoaXMucmVsRGF0YTsNCiAgICAgIGxldCBvRGF0YSA9IF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbjsNCiAgICAgIGNvbnNvbGUubG9nKG5vZGVEYXRhKQ0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGxldCBoZWlnaHQgPSBzdmcuYXR0cignaGVpZ2h0Jyk7DQogICAgICAvLyBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydzaW1pbGFyaXR5UmVsJ107DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBiYXNpY1JlbC5sZW5ndGg7IHIrKykgew0KDQogICAgICAgIGxldCBzb3VyY2VJZCA9IGJhc2ljUmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyXVsxXTsNCiAgICAgICAgbGV0IGlkTiA9ICJiYXNpY1JlbCIgKyBzb3VyY2VJZCArICJfIiArIHRhcmdldElkOw0KICAgICAgICBsZXQgY2xhc3NOID0gImJhc2ljUmVsIHNvdXJjZSIgKyBzb3VyY2VJZCArICIgdGFyZ2V0IiArIHRhcmdldElkOw0KICAgICAgICBsZXQgc291cmNlTm9kZSA9IG5vZGVEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2RhdGEnXVsnaWQnXSA9PSBzb3VyY2VJZCB9KTsNCiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBub2RlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydkYXRhJ11bJ2lkJ10gPT0gdGFyZ2V0SWQgfSk7DQogICAgICAgIGlmIChzb3VyY2VOb2RlWyd4J10gPiB0YXJnZXROb2RlWyd4J10pIHsNCiAgICAgICAgICBsZXQgdHAgPSBzb3VyY2VOb2RlOw0KICAgICAgICAgIHNvdXJjZU5vZGUgPSB0YXJnZXROb2RlOw0KICAgICAgICAgIHRhcmdldE5vZGUgPSB0cDsNCiAgICAgICAgfQ0KICAgICAgICBjb25zdCBwYXRoID0gZDMucGF0aCgpOw0KDQogICAgICAgIGxldCBzdGFydFggPSBzb3VyY2VOb2RlWyd5J107DQogICAgICAgIGxldCBlbmRYID0gdGFyZ2V0Tm9kZVsneSddOw0KICAgICAgICBsZXQgc3RhcnRZID0gc291cmNlTm9kZVsneCddOw0KICAgICAgICBsZXQgZW5kWSA9IHRhcmdldE5vZGVbJ3gnXTsNCiAgICAgICAgbGV0IG1pZFggPSAoc3RhcnRYICsgZW5kWCkgLyAyOw0KICAgICAgICBsZXQgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7DQogICAgICAgIGxldCBjbnggPSAoc3RhcnRYID4gZW5kWCkgPyAoc3RhcnRYICsgMTAgKyAwLjI1ICogKGVuZFkgLSBzdGFydFkpKSA6IChlbmRYICsgMTAgKyAwLjI1ICogKGVuZFkgLSBzdGFydFkpKTsNCiAgICAgICAgcGF0aC5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpOw0KICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oY254LCBtaWRZLCBjbngsIG1pZFksIGVuZFgsIGVuZFkpOw0KICAgICAgICBfdGhpcy5kcmF3VGltZUxpbmUoc3ZnLCBwYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDUsICI5LDkiLCBpZE4sIGNsYXNzTik7DQoNCg0KICAgICAgfTsNCiAgICAgIGxldCBzaW1pbGFyaXR5UmVsID0gcmVsRGF0YVsnc2ltaWxhcml0eVJlbCddOw0KICAgICAgLy8gbGV0IGJhc2ljUmVsID0gcmVsRGF0YVsnYmFzaWNSZWwnXTsNCiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgc2ltaWxhcml0eVJlbC5sZW5ndGg7IHIrKykgew0KDQogICAgICAgIGxldCBzb3VyY2VJZCA9IHNpbWlsYXJpdHlSZWxbcl1bMF07DQogICAgICAgIGxldCB0YXJnZXRJZCA9IHNpbWlsYXJpdHlSZWxbcl1bMV07DQoNCiAgICAgICAgbGV0IGlkTiA9ICJzaW1pbGFyaXR5UmVsIiArIHNvdXJjZUlkICsgIl8iICsgdGFyZ2V0SWQ7DQoNCiAgICAgICAgbGV0IGNsYXNzTiA9ICJzaW1pbGFyaXR5UmVsIHNvdXJjZSIgKyBzb3VyY2VJZCArICIgdGFyZ2V0IiArIHRhcmdldElkOw0KICAgICAgICBsZXQgc291cmNlTm9kZSA9IG5vZGVEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2RhdGEnXVsnaWQnXSA9PSBzb3VyY2VJZCB9KTsNCiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBub2RlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydkYXRhJ11bJ2lkJ10gPT0gdGFyZ2V0SWQgfSk7DQogICAgICAgIGlmIChzb3VyY2VOb2RlWyd4J10gPiB0YXJnZXROb2RlWyd4J10pIHsNCiAgICAgICAgICBsZXQgdHAgPSBzb3VyY2VOb2RlOw0KICAgICAgICAgIHNvdXJjZU5vZGUgPSB0YXJnZXROb2RlOw0KICAgICAgICAgIHRhcmdldE5vZGUgPSB0cDsNCiAgICAgICAgfQ0KICAgICAgICBjb25zdCBwYXRoID0gZDMucGF0aCgpOw0KDQogICAgICAgIGxldCBzdGFydFggPSBzb3VyY2VOb2RlWyd5J107DQogICAgICAgIGxldCBlbmRYID0gdGFyZ2V0Tm9kZVsneSddOw0KICAgICAgICBsZXQgc3RhcnRZID0gc291cmNlTm9kZVsneCddOw0KICAgICAgICBsZXQgZW5kWSA9IHRhcmdldE5vZGVbJ3gnXTsNCiAgICAgICAgbGV0IG1pZFggPSAoc3RhcnRYICsgZW5kWCkgLyAyOw0KICAgICAgICBsZXQgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7DQogICAgICAgIGxldCBjbnggPSAoc3RhcnRYID4gZW5kWCkgPyAoc3RhcnRYICsgMTAwICsgMC41ICogKGVuZFkgLSBzdGFydFkpKSA6IChlbmRYICsgMTAwICsgMC41ICogKGVuZFkgLSBzdGFydFkpKTsNCg0KICAgICAgICBwYXRoLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7DQogICAgICAgIHBhdGgubGluZVRvKGNueCwgc3RhcnRZKTsNCiAgICAgICAgcGF0aC5saW5lVG8oY254LCBlbmRZKTsNCiAgICAgICAgcGF0aC5saW5lVG8oZW5kWCwgZW5kWSk7DQogICAgICAgIF90aGlzLmRyYXdUaW1lTGluZShzdmcsIHBhdGgsICJyZ2IoMjAwLDIwMCwyMDApIiwgNSwgIjAiLCBpZE4sIGNsYXNzTik7DQoNCg0KICAgICAgfTsNCiAgICB9LA0KICAgIGRyYXdlZGl0RGF0YSgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGNvbnN0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGxldCB3aWR0aCA9IHRoaXMuJHJlZnMuZWRpdERhdGEub2Zmc2V0V2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCAtIDYwOw0KICAgICAgbGV0IGhlaWdodCA9IHRoaXMuJHJlZnMuZWRpdERhdGEub2Zmc2V0SGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207DQogICAgICBkMy5zZWxlY3QoIiNlZGl0RGF0YSIpLnNlbGVjdCgic3ZnIikucmVtb3ZlKCk7DQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjZWRpdERhdGEiKS5hcHBlbmQoInN2ZyIpDQogICAgICAgIC5hdHRyKCJpZCIsICJlZGl0RW50IikNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICBsZXQgZW50RyA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJlbnRHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBzb25HID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgInNvbkciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoMSwzMjApIik7DQogICAgICAvLyBfdGhpcy5lbnRHID0gZW50RzsNCiAgICAgIC8vIF90aGlzLnNvbkcgPSBzb25HOw0KICAgICAgX3RoaXMuZHJhd0VudGl0eShfdGhpcy5kYXRhWzBdKTsNCiAgICAgIF90aGlzLmRyYXdTb25MaW5lKF90aGlzLmRhdGFbMV0pOw0KICAgIH0sDQogICAgZHJhd1NvbkxpbmUoZGF0YSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHBzdmcgPSBkMy5zZWxlY3QoIiNzb25HIik7DQogICAgICBsZXQgdyA9IHBzdmcuYXR0cigid2lkdGgiKSAtIDE7DQogICAgICBsZXQgaCA9IDQwOw0KICAgICAgcHN2Zy5yZW1vdmUoKTsNCiAgICAgIGxldCBzdmcgPSBkMy5zZWxlY3QoIiNlZGl0RW50IikuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAic29uRyIpLmF0dHIoIndpZHRoIiwgdyArIDEpLmF0dHIoImhlaWdodCIsIGggKyAyKS5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKDEsMzIwKSIpOw0KICAgICAgbGV0IGNvbG9yX2xpbmVhciA9IF90aGlzLmltcG9ydGFuY2VDb2xvcl9saW5lYXI7DQogICAgICBsZXQgY29tcHV0ZV9jb2xvciA9IF90aGlzLmltcG9ydGFuY2VDb21wdXRlX2NvbG9yOw0KICAgICAgbGV0IG9EYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIF90aGlzLmVudExpbmVXaWR0aCA9IHc7DQogICAgICAvLyBpZiAoc29uTGlzdC5sZW5ndGggPiAwKSB7DQogICAgICBzdmcuc2VsZWN0QWxsKCkucmVtb3ZlKCk7DQogICAgICBzdmcuYXBwZW5kKCJsaW5lIikNCiAgICAgICAgLmF0dHIoIngxIiwgMCkNCiAgICAgICAgLmF0dHIoInkxIiwgaCAvIDIpDQogICAgICAgIC5hdHRyKCJ4MiIsIHcpDQogICAgICAgIC5hdHRyKCJ5MiIsIGggLyAyKQ0KICAgICAgICAuYXR0cigic3Ryb2tlIiwgInJnYigyMDAsMjAwLDIwMCkiKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgIjVweCIpOw0KDQogICAgICBsZXQgdG90YWxTb25EdXJhdGlvbiA9IDA7DQogICAgICBsZXQgZGF0YUluZGV4ID0gb0RhdGEubWFwKGl0ZW0gPT4gaXRlbS5pZCkuaW5kZXhPZihkYXRhWydpZCddKTsNCiAgICAgIGxldCBzdGFydEluZGV4ID0gKChkYXRhSW5kZXggLSAyKSA+IDApID8gKGRhdGFJbmRleCAtIDIpIDogKDApOw0KICAgICAgbGV0IGVuZEluZGV4ID0gKChkYXRhSW5kZXggKyAxKSA8IG9EYXRhLmxlbmd0aCkgPyAoZGF0YUluZGV4ICsgMikgOiAob0RhdGEubGVuZ3RoIC0gMSk7DQoNCiAgICAgIGxldCBkYXRhTGkgPSB0b29scy5kZWVwQ2xvbmUob0RhdGEpLnNwbGljZShzdGFydEluZGV4LCBlbmRJbmRleCAtIHN0YXJ0SW5kZXggKyAxKTsNCiAgICAgIC8vIGxldCBkYXRhID0gc29uTGlzdDsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxpLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBjdXJFbnQgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGRhdGFMaVtpXVsnaWQnXSB9KTsNCiAgICAgICAgbGV0IHRpbWUgPSB0b29scy50aW1lMnNlY29uZHMoY3VyRW50Wyd0aW1lJ11bMF0pOw0KICAgICAgICBsZXQgZW5kVGltZSA9IHRvb2xzLnRpbWUyc2Vjb25kcyhjdXJFbnRbJ3RpbWUnXVsxXSk7DQogICAgICAgIHRvdGFsU29uRHVyYXRpb24gKz0gZW5kVGltZSAtIHRpbWU7DQogICAgICB9DQogICAgICBfdGhpcy50b3RhbFNvbkR1cmF0aW9uID0gdG90YWxTb25EdXJhdGlvbjsNCiAgICAgIGxldCBjeExpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCB0b3RhbFNvbkR1cmF0aW9uXSwgWzAsIHddKTsNCiAgICAgIGxldCBEaXZpc2lvbkRhdGFMaXN0ID0gW107DQogICAgICAvLyBsZXQgY29sb3JJbmRleCA9IDA7DQogICAgICBsZXQgcHJleCA9IDA7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMaS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgY3VyRW50ID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBkYXRhTGlbaV1bJ2lkJ10gfSk7DQogICAgICAgIGxldCB0ZW1wID0gdG9vbHMuZGVlcENsb25lKGN1ckVudCk7DQogICAgICAgIGlmIChEaXZpc2lvbkRhdGFMaXN0Lmxlbmd0aCAhPSAwKSB7DQogICAgICAgICAgRGl2aXNpb25EYXRhTGlzdFtEaXZpc2lvbkRhdGFMaXN0Lmxlbmd0aCAtIDFdWyduZXh0SWQnXSA9IHRlbXBbJ2lkJ107DQogICAgICAgICAgdGVtcFsncHJlSWQnXSA9IERpdmlzaW9uRGF0YUxpc3RbRGl2aXNpb25EYXRhTGlzdC5sZW5ndGggLSAxXVsnaWQnXTsNCiAgICAgICAgfQ0KICAgICAgICBlbHNlIHsgdGVtcFsncHJlSWQnXSA9ICItMSI7IH0NCiAgICAgICAgRGl2aXNpb25EYXRhTGlzdC5wdXNoKHRlbXApOw0KICAgICAgICBsZXQgdGltZSA9IHRvb2xzLnRpbWUyc2Vjb25kcyhjdXJFbnRbJ3RpbWUnXVswXSk7DQogICAgICAgIGxldCBlbmRUaW1lID0gdG9vbHMudGltZTJzZWNvbmRzKGN1ckVudFsndGltZSddWzFdKTsNCiAgICAgICAgbGV0IGN1ckVudER1ciA9IGVuZFRpbWUgLSB0aW1lOw0KICAgICAgICBsZXQgY3ggPSBwcmV4Ow0KICAgICAgICBsZXQgZW5keCA9IHByZXggKyBjeExpbmVhcihjdXJFbnREdXIpOw0KICAgICAgICBsZXQgaW1wb3J0YW5jZVZhbHVlID0gY3VyRW50WydhdHRyaWJ1dGUnXVsnaW1wb3J0YW5jZSddOw0KICAgICAgICBsZXQgZW50Q29sb3IgPSBjb21wdXRlX2NvbG9yKGNvbG9yX2xpbmVhcihpbXBvcnRhbmNlVmFsdWUpKTsNCiAgICAgICAgaWYgKGkgIT0gMCkgew0KICAgICAgICAgIF90aGlzLmRyYXdSZWN0KHN2ZywgY3ggLSA1LCAwLCA1LCBoLCBoIC8gMiwgImRpdmlzaW9uXyIgKyBjdXJFbnRbJ2lkJ10sICJlbnRkaXZpc2lvbkxpbmUiLCAicmdiKDI1MCwyNTAsMjUwKSIsIDUsICcnLCAwKTsNCiAgICAgICAgfQ0KICAgICAgICBpZiAoZGF0YUxpW2ldWydpZCddID09IGRhdGFbJ2lkJ10pIF90aGlzLmRyYXdSZWN0KHN2ZywgY3gsIDAsIGVuZHggLSBjeCwgaCwgaCAvIDIsICJlZGl0RW50XyIgKyBjdXJFbnRbJ2lkJ10sICJlZGl0RW50IiwgZW50Q29sb3IsIDEsICJibGFjayIsIDEpLy9jb2xvcltfdGhpcy5jb2xvck1hcFtzb25bJ2lkJ11dXSwgNSwgMC4xKQ0KICAgICAgICBlbHNlIF90aGlzLmRyYXdSZWN0KHN2ZywgY3gsIDAsIGVuZHggLSBjeCwgaCwgaCAvIDIsICJlZGl0RW50XyIgKyBjdXJFbnRbJ2lkJ10sICJlZGl0RW50IiwgZW50Q29sb3IsIDEsICJyZ2IoMTUwLDE1MCwxNTApIiwgMSkvL2NvbG9yW190aGlzLmNvbG9yTWFwW3NvblsnaWQnXV1dLCA1LCAwLjEpDQogICAgICAgIHByZXggPSBlbmR4Ow0KICAgICAgfQ0KICAgICAgRGl2aXNpb25EYXRhTGlzdFtEaXZpc2lvbkRhdGFMaXN0Lmxlbmd0aCAtIDFdWyduZXh0SWQnXSA9ICItMSI7DQogICAgICBfdGhpcy5lbnREaXZpc2lvbkRhdGFMaXN0ID0gRGl2aXNpb25EYXRhTGlzdDsNCiAgICB9LA0KICAgIGRyYXdFbnRpdHlPcmkoZGF0YSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHBzdmcgPSBkMy5zZWxlY3QoIiNlbnRHIik7DQogICAgICBsZXQgdyA9IHBzdmcuYXR0cigid2lkdGgiKTsNCiAgICAgIGxldCBoID0gcHN2Zy5hdHRyKCJoZWlnaHQiKTsNCiAgICAgIHBzdmcucmVtb3ZlKCk7DQogICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KCIjZWRpdEVudCIpLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImVudEciKS5hdHRyKCJ3aWR0aCIsIHcpLmF0dHIoImhlaWdodCIsIGgpOw0KICAgICAgbGV0IGNvbG9yX2xpbmVhciA9IF90aGlzLmltcG9ydGFuY2VDb2xvcl9saW5lYXI7DQogICAgICBsZXQgY29tcHV0ZV9jb2xvciA9IF90aGlzLmltcG9ydGFuY2VDb21wdXRlX2NvbG9yOw0KICAgICAgbGV0IHRvdGFsRHVyYXRpb25WYWx1ZSA9IGRhdGFbJ3RvdGFsRHVyYXRpb24nXTsNCiAgICAgIGxldCByU2NhbGUgPSBfdGhpcy50b3RhbER1cmF0aW9uU2NhbGVfbGluZWFyOw0KICAgICAgbGV0IHIgPSByU2NhbGUodG90YWxEdXJhdGlvblZhbHVlKTsNCiAgICAgIGxldCBvRGF0YSA9IF90aGlzLmRhdGE7DQogICAgICBsZXQgeCA9IHN2Zy5hdHRyKCJ3aWR0aCIpIC8gMjsNCiAgICAgIGxldCB5ID0gMTIwOw0KICAgICAgbGV0IGltcG9ydGFuY2VWYWx1ZSA9IGRhdGFbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107DQogICAgICBsZXQgcmVsZXZhbmNlVmFsdWUgPSBkYXRhWydhdHRyaWJ1dGUnXVsncmVsZXZhbmNlJ107DQogICAgICBzdmcuc2VsZWN0QWxsKCkucmVtb3ZlKCk7DQoNCiAgICAgIGlmIChkYXRhWyd0eXBlJ10gPT0gJzEnKSB7DQogICAgICAgIGxldCBhcmVhID0gdG9vbHMuY2FsY1RyaWFuZ2xlKHgsIHksIHIpOw0KICAgICAgICBfdGhpcy5kcmF3VHJpYW5nbGUoc3ZnLCAicmdiKDI1MCwgMTk5LCA4OCkiLCBhcmVhLCAicmdiKDI1MCwgMTk5LCA4OCkiKTsNCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KDQogICAgICAgIGxldCBjeSA9IHk7DQogICAgICAgIGxldCB0b3RhbER1cmF0aW9uID0gX3RoaXMudG90YWxEdXJhdGlvbjsNCiAgICAgICAgbGV0IHRpbWVMaW5lU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHRvdGFsRHVyYXRpb25dLCBbeCAtIHIgKiBNYXRoLnNxcnQoMykgLyAyLCB4ICsgciAqIE1hdGguc3FydCgzKSAvIDJdKQ0KICAgICAgICBsZXQgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIF90aGlzLm1heEREdXJhdGlvbl0sIFswLCByICogKDEgKyBNYXRoLnNxcnQoMykgLyAyKV0pDQogICAgICAgIGxldCBjaXJjbGVDb2xvciA9IGNvbXB1dGVfY29sb3IoY29sb3JfbGluZWFyKGltcG9ydGFuY2VWYWx1ZSkpOw0KICAgICAgICBfdGhpcy5kcmF3Q2lyY2xlKHN2ZywgeCwgY3ksIHIsIGNpcmNsZUNvbG9yLCBkYXRhLCAxLCAiZW50Q2lyY2xlIiwgImVudENpcmNsZV8iICsgZGF0YVsnaWQnXSk7DQoNCiAgICAgICAgciA9IHIgKiBNYXRoLnNxcnQoMykgLyAyOw0KICAgICAgICB5ICs9IHIgLyAyOw0KICAgICAgICBsZXQgcGF0aCA9IGQzLnBhdGgoKTsNCg0KDQogICAgICAgIHBhdGgubW92ZVRvKHggLSByLCB5KTsNCiAgICAgICAgbGV0IGxpbmVMaSA9IFtkYXRhWyd0aW1lJ11dOw0KICAgICAgICBsZXQgbGluZVBvaW50ID0gW3sgJ2lkJzogZGF0YVsnaWQnXSwgJ3RpbWUnOiBkYXRhWyd0aW1lJ10sICd4JzogMCwgJ3knOiAwIH1dOw0KICAgICAgICBmb3IgKGxldCBzcmVsIGluIGRhdGFbInNpbWlsYXJpdHlSZWwiXSkgew0KICAgICAgICAgIGxldCBjZGF0YSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gZGF0YVsic2ltaWxhcml0eVJlbCJdW3NyZWxdIH0pDQogICAgICAgICAgbGluZUxpLnB1c2goY2RhdGFbJ3RpbWUnXSkNCiAgICAgICAgICBsaW5lUG9pbnQucHVzaCh7ICdpZCc6IGNkYXRhWydpZCddLCAndGltZSc6IGNkYXRhWyd0aW1lJ10sICd4JzogMCwgJ3knOiAwIH0pDQogICAgICAgIH0NCiAgICAgICAgY29uc3Qgc29ydG10ID0gKGEsIGIpID0+IHsNCiAgICAgICAgICByZXR1cm4gdG9vbHMudGltZTJzZWNvbmRzKGFbMF0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGJbMF0pOw0KICAgICAgICB9DQogICAgICAgIGNvbnN0IHNvcnRscCA9IChhLCBiKSA9PiB7DQogICAgICAgICAgcmV0dXJuIHRvb2xzLnRpbWUyc2Vjb25kcyhhWyd0aW1lJ11bMF0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGJbJ3RpbWUnXVswXSk7DQogICAgICAgIH0NCiAgICAgICAgbGluZUxpID0gbGluZUxpLnNvcnQoc29ydG10KTsNCiAgICAgICAgbGluZVBvaW50ID0gbGluZVBvaW50LnNvcnQoc29ydGxwKTsNCiAgICAgICAgbGV0IGxpbmVEYXRhID0gW1t4IC0gciwgeV1dOw0KICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGxpbmVMaS5sZW5ndGg7IHQrKykgew0KICAgICAgICAgIGxldCBzdGFydFQgPSBsaW5lTGlbdF1bMF07DQogICAgICAgICAgbGV0IGVuZFQgPSBsaW5lTGlbdF1bMV07DQogICAgICAgICAgbGV0IHN0YXJ0UyA9IHRvb2xzLnRpbWUyc2Vjb25kcyhzdGFydFQpOw0KICAgICAgICAgIGxldCBlbmRTID0gdG9vbHMudGltZTJzZWNvbmRzKGVuZFQpOw0KICAgICAgICAgIGxldCBkdXJhdGlvbiA9IGVuZFMgLSBzdGFydFM7DQoNCiAgICAgICAgICBsZXQgc3RhcnR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyAtIGR1cmF0aW9uICogMTApKTsNCiAgICAgICAgICBsZXQgZW5keCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTICsgZHVyYXRpb24gKiAxMCkpOw0KDQogICAgICAgICAgbGV0IHN0YXJ0eWYgPSB5ICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gODsNCiAgICAgICAgICBsZXQgc3RhcnR5ZjEgPSB5ICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gODsNCiAgICAgICAgICBsZXQgZW5keWYgPSB5ICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gODsNCiAgICAgICAgICBsZXQgZW5keWYxID0geSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDg7DQogICAgICAgICAgbGV0IHl6ID0geSAtIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKTsNCiAgICAgICAgICBsZXQgbWlkeCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTICsgc3RhcnRTKSAvIDIpOw0KICAgICAgICAgIGxpbmVQb2ludFt0XVsneCddID0gbWlkeDsNCiAgICAgICAgICBsaW5lUG9pbnRbdF1bJ3knXSA9IHkgLSB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoZHVyYXRpb24pIC8gMS43Ow0KICAgICAgICAgIGxldCB5MSA9IHk7DQogICAgICAgICAgaWYgKHN0YXJ0eCA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHsNCiAgICAgICAgICAgIGlmICh0ID4gMCkgew0KICAgICAgICAgICAgICBsaW5lRGF0YS5zcGxpY2UobGluZURhdGEubGVuZ3RoIC0gMywgMyk7DQogICAgICAgICAgICAgIHN0YXJ0eCA9IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSArIG1pZHgpIC8gMjsNCiAgICAgICAgICAgICAgeTEgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVsxXSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDI7DQogICAgICAgICAgICAgIHN0YXJ0eWYgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVsxXSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDI7DQogICAgICAgICAgICAgIHN0YXJ0eWYxID0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMV0gKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyAyOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgc3RhcnR4MSA9IHN0YXJ0eCArICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTICsgZHVyYXRpb24pKSAtIHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSk7DQogICAgICAgICAgbGV0IGVuZHgxID0gZW5keCAtICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTICsgZHVyYXRpb24pKSAtIHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSk7DQogICAgICAgICAgbGV0IHN0YXJ0eDIgPSBzdGFydHgxICsgKHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMgKyBkdXJhdGlvbikpIC0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKTsNCiAgICAgICAgICBsZXQgZW5keDIgPSBlbmR4MSAtICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTICsgZHVyYXRpb24pKSAtIHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSk7DQogICAgICAgICAgaWYgKGVuZHggPiAociArIHgpKSBlbmR4ID0gciArIHg7DQogICAgICAgICAgaWYgKHN0YXJ0eDEgPCAobGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF0pKSBzdGFydHgxID0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF07DQogICAgICAgICAgaWYgKGVuZHgxID4gKHIgKyB4KSkgZW5keDEgPSByICsgeDsNCiAgICAgICAgICBpZiAoc3RhcnR4MiA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHN0YXJ0eDIgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXTsNCiAgICAgICAgICBpZiAoZW5keDIgPiAociArIHgpKSBlbmR4MiA9IHIgKyB4Ow0KICAgICAgICAgIGxpbmVEYXRhLnB1c2goW3N0YXJ0eCwgeTFdLCBbc3RhcnR4MSwgc3RhcnR5ZjFdLCBbc3RhcnR4Miwgc3RhcnR5Zl0sIFttaWR4LCB5el0sIFtlbmR4MiwgZW5keWZdLCBbZW5keDEsIGVuZHlmMV0sIFtlbmR4LCB5XSkNCiAgICAgICAgfQ0KICAgICAgICBsaW5lRGF0YS5wdXNoKFt4ICsgciwgeV0pDQogICAgICAgIGxldCBjdXJ2ZV9nZW5lcmF0b3IgPSBkMy5saW5lKCkNCiAgICAgICAgICAueCgoZCkgPT4gZFswXSkNCiAgICAgICAgICAueSgoZCkgPT4gew0KICAgICAgICAgICAgbGV0IGggPSBNYXRoLnNxcnQoTWF0aC5wb3cociwgMikgLSBNYXRoLnBvdygoZFswXSAtICh4IC0gcikpLCAyKSk7DQogICAgICAgICAgICBpZiAoKHkgLSBkWzFdKSA+IChoICsgciAqIE1hdGguc3FydCgzKSAvIDIpKQ0KICAgICAgICAgICAgICByZXR1cm4geSAtIChoICsgciAqIE1hdGguc3FydCgzKSAvIDIpICsgMjsNCiAgICAgICAgICAgIHJldHVybiBkWzFdOw0KICAgICAgICAgIH0pDQogICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpDQogICAgICAgIF90aGlzLmRyYXdUaW1lTGluZShzdmcsIGN1cnZlX2dlbmVyYXRvcihsaW5lRGF0YSksICJ3aGl0ZSIsIDIsICcwJywgJ3NvbkxpbmUgJywgJ3NvbkxpbmUgJyk7DQoNCg0KICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGxpbmVQb2ludC5sZW5ndGg7IHArKykgew0KICAgICAgICAgIF90aGlzLmRyYXdDaXJjbGUoc3ZnLCBsaW5lUG9pbnRbcF1bJ3gnXSwgbGluZVBvaW50W3BdWyd5J10sIDUsICJyZWQiLCBsaW5lUG9pbnRbcF0sIDAsICJsaW5lUG9pbnQiLCAibGluZVBvaW50XyIgKyBsaW5lUG9pbnRbcF1bJ2lkJ10pOw0KICAgICAgICB9DQoNCiAgICAgICAgLy8gIjEiOiAicmdiKDE0NSwgMjA0LCAxMTcpIiwNCiAgICAgICAgLy8gICAiMiI6ICJyZ2IoODQsIDExMiwgMTk4KSIsDQogICAgICAgIC8vICAgIjMiOiAicmdiKDIzOCwgMTAyLCAxMDIpIiwNCiAgICAgICAgbGV0IHR5cGVDb2xvciA9IHsNCiAgICAgICAgICAiMSI6ICIjZmY5YzljIiwNCiAgICAgICAgICAiMiI6ICIjZjRmNGQwIiwNCiAgICAgICAgICAiMyI6ICIjNmY4YmUwIiwNCiAgICAgICAgfTsNCiAgICAgICAgbGV0IGR1cmF0aW9uID0gdG9vbHMudGltZTJzZWNvbmRzKGRhdGFbJ3RpbWUnXVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoZGF0YVsndGltZSddWzFdKTsNCiAgICAgICAgbGV0IHR5cGVEYXRhID0gZGF0YVsnYXR0cmlidXRlJ11bJ2V4cHJlc3Npb25zJ107DQogICAgICAgIGxldCBzb25MaXN0ID0gZGF0YVsnc29uJ107DQogICAgICAgIGxldCB0eXBlQXJjU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIGR1cmF0aW9uXSwgWzAsIE1hdGguUEkgKiAyXSk7DQoNCiAgICAgICAgdmFyIHR5cGVTdGFydFIgPSAwLy9NYXRoLlBJLzQ7DQoNCiAgICAgICAgdmFyIHR5cGVTdGVwUiA9IE1hdGguUEkgLyAxOw0KDQogICAgICAgIGlmIChzb25MaXN0Lmxlbmd0aCA+IDApIHsNCiAgICAgICAgICBmb3IgKGxldCBpIGluIHR5cGVEYXRhKSB7DQogICAgICAgICAgICBsZXQgY29sb3IgPSB0eXBlQ29sb3JbaV07DQogICAgICAgICAgICBsZXQgdHlwZUR1cml0aW9uID0gdHlwZURhdGFbaV07DQogICAgICAgICAgICBsZXQgdG90YWxUeXBlU2Vjb25kcyA9IDA7DQogICAgICAgICAgICBmb3IgKGxldCBkIGluIHR5cGVEdXJpdGlvbikgew0KICAgICAgICAgICAgICB0b3RhbFR5cGVTZWNvbmRzICs9ICh0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMF0pKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgbGV0IHR5cGVTdGVwUiA9IHR5cGVBcmNTY2FsZV9saW5lYXIodG90YWxUeXBlU2Vjb25kcykvL01hdGguUEkvMjsNCg0KICAgICAgICAgICAgbGV0IGVuZEFuZ2xldCA9IHR5cGVTdGFydFIgKyAxICogdHlwZVN0ZXBSDQogICAgICAgICAgICB2YXIgZGF0YXNldCA9IHsgc3RhcnRBbmdsZTogdHlwZVN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgICAgICAgICAgdHlwZVN0YXJ0UiA9IGVuZEFuZ2xldDsNCiAgICAgICAgICAgIHZhciBhcmNQYXRoID0gZDMuYXJjKCkNCiAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKHIgKyAxMCkNCiAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKHIgKyAyNSk7DQogICAgICAgICAgICB2YXIgcGF0aEFyYyA9IGFyY1BhdGgoZGF0YXNldCk7DQogICAgICAgICAgICBfdGhpcy5kcmF3QXJjKHN2ZywgeCwgeSAtIHIgLyAyLCBwYXRoQXJjLCBjb2xvciwgY29sb3IsICd0eXBlIGYnICsgZGF0YVsnaWQnXSArICIgdCIgKyBpKTsNCiAgICAgICAgICB9DQogICAgICAgICAgbGV0IHNvblRvdGFsID0gMDsNCiAgICAgICAgICBsZXQgc29uTnVtID0gMA0KICAgICAgICAgIGZvciAobGV0IHMgaW4gc29uTGlzdCkgew0KICAgICAgICAgICAgbGV0IHNvbkRhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNvbkxpc3Rbc10gfSk7DQogICAgICAgICAgICBsZXQgc29uRHVyID0gc29uRGF0YVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgICAgICAgc29uVG90YWwgKz0gc29uRHVyOw0KICAgICAgICAgICAgc29uTnVtICs9IDE7DQogICAgICAgICAgfQ0KICAgICAgICAgIGxldCBza2lwQXJjID0gTWF0aC5QSSAvIChzb25OdW0gKyAyKTsNCiAgICAgICAgICBsZXQgdGltZVNvbkxpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBzb25Ub3RhbF0sIFswLCBNYXRoLlBJICogMiAtIHNraXBBcmMgKiBzb25OdW1dKTsNCiAgICAgICAgICBsZXQgdGltZVNvbkhlaWdoTGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHNvblRvdGFsXSwgWzQwLCA0MF0pOw0KDQogICAgICAgICAgbGV0IHRpbWVTb25Db2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgc29uVG90YWxdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgICAgIGxldCB0aW1lU29uQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKCJ3aGl0ZSIsIGNpcmNsZUNvbG9yKTsNCiAgICAgICAgICB2YXIgc29uU3RhcnRSID0gMDsvLy1NYXRoLlBJLzI7DQogICAgICAgICAgZm9yIChsZXQgcyBpbiBzb25MaXN0KSB7DQogICAgICAgICAgICBsZXQgc29uRGF0YSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29uTGlzdFtzXSB9KTsNCiAgICAgICAgICAgIGxldCBzb25EdXIgPSBzb25EYXRhWyd0b3RhbER1cmF0aW9uJ107DQoNCiAgICAgICAgICAgIGxldCBzb25TdGVwUiA9IHRpbWVTb25MaW5lYXIoc29uRHVyKS8vTWF0aC5QSS8yOw0KDQogICAgICAgICAgICBsZXQgZW5kQW5nbGV0ID0gc29uU3RhcnRSICsgc29uU3RlcFI7DQogICAgICAgICAgICB2YXIgZGF0YXNldCA9IHsgc3RhcnRBbmdsZTogc29uU3RhcnRSLCBlbmRBbmdsZTogZW5kQW5nbGV0IH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQogICAgICAgICAgICBzb25TdGFydFIgPSBlbmRBbmdsZXQ7DQogICAgICAgICAgICBsZXQgY29sb3IgPSAnYmx1ZSc7DQogICAgICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgICAgIC5pbm5lclJhZGl1cyhyICsgMjgpDQogICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgdGltZVNvbkhlaWdoTGluZWFyKHNvbkR1cikpOw0KICAgICAgICAgICAgdmFyIGFyY01pZFBhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgICAgICAuaW5uZXJSYWRpdXMoMCkNCiAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKHIgKyAzMik7DQogICAgICAgICAgICB2YXIgcGF0aEFyYyA9IGFyY1BhdGgoZGF0YXNldCk7DQoNCiAgICAgICAgICAgIGVuZEFuZ2xldCA9IHNvblN0YXJ0UiArIHNraXBBcmM7DQogICAgICAgICAgICB2YXIgbWlkRGF0YXNldCA9IHsgc3RhcnRBbmdsZTogc29uU3RhcnRSLCBlbmRBbmdsZTogZW5kQW5nbGV0IH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQoNCiAgICAgICAgICAgIGxldCBqaWFudG91UGF0aCA9IGQzLnBhdGgoKTsNCiAgICAgICAgICAgIGppYW50b3VQYXRoLmFyYyh4LCB5IC0gciAvIDIsIHIgKyAzMiwgc29uU3RhcnRSIC0gTWF0aC5QSSAvIDIsIGVuZEFuZ2xldCAtIE1hdGguUEkgLyAyKTsNCg0KICAgICAgICAgICAgc29uU3RhcnRSICs9IHNraXBBcmM7DQogICAgICAgICAgICB2YXIgcGF0aE1pZEFyYyA9IGFyY01pZFBhdGgobWlkRGF0YXNldCk7DQogICAgICAgICAgICBsZXQgdGltZVNvbkNvbG9yID0gY29tcHV0ZV9jb2xvcihjb2xvcl9saW5lYXIoc29uRGF0YVsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXSkpOw0KICAgICAgICAgICAgX3RoaXMuZHJhd0FyYyhzdmcsIHgsIHkgLSByIC8gMiwgcGF0aEFyYywgdGltZVNvbkNvbG9yLCB0aW1lU29uQ29sb3IsICdzb24gZicgKyBkYXRhWydpZCddICsgIiBzIiArIHNvbkxpc3Rbc10sICcwJyk7DQogICAgICAgICAgICBpZiAocyAhPSBzb25MaXN0Lmxlbmd0aCAtIDEpIHsNCiAgICAgICAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgamlhbnRvdVBhdGgsICJyZ2IoMjAwLDIwMCwyMDApIiwgMywgJzksNScsICdtaWRBcmMgJywgJ21pZEFyYyAnKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQoNCiAgICAgICAgfQ0KDQoNCiAgICAgIH0NCiAgICAgIGxldCB0eHRzID0gX3RoaXMubmFtZWlucHV0LnNwbGl0KCIgIikNCiAgICAgIF90aGlzLmRyYXdUeHQoc3ZnLCB4IC0gciAtIDMyLCB5ICsgciArIDUwLCByICogMiArIDY0LCB0eHRzLCAiZ3JleSIpOw0KICAgIH0sDQogICAgZHJhd0VudGl0eShkYXRhKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcHN2ZyA9IGQzLnNlbGVjdCgiI2VudEciKTsNCiAgICAgIGxldCB3ID0gcHN2Zy5hdHRyKCJ3aWR0aCIpOw0KICAgICAgbGV0IGggPSBwc3ZnLmF0dHIoImhlaWdodCIpOw0KICAgICAgcHN2Zy5yZW1vdmUoKTsNCiAgICAgIGxldCBzdmcgPSBkMy5zZWxlY3QoIiNlZGl0RW50IikuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZW50RyIpLmF0dHIoIndpZHRoIiwgdykuYXR0cigiaGVpZ2h0IiwgaCk7DQogICAgICBsZXQgY29sb3JfbGluZWFyID0gX3RoaXMuaW1wb3J0YW5jZUNvbG9yX2xpbmVhcjsNCiAgICAgIGxldCBjb21wdXRlX2NvbG9yID0gX3RoaXMuaW1wb3J0YW5jZUNvbXB1dGVfY29sb3I7DQogICAgICBsZXQgdG90YWxEdXJhdGlvblZhbHVlID0gZGF0YVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgbGV0IHJTY2FsZSA9IF90aGlzLnRvdGFsRHVyYXRpb25TY2FsZV9saW5lYXI7DQogICAgICBsZXQgciA9IHJTY2FsZSh0b3RhbER1cmF0aW9uVmFsdWUpOw0KICAgICAgbGV0IG9EYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCB4ID0gc3ZnLmF0dHIoIndpZHRoIikgLyAyOw0KICAgICAgbGV0IHkgPSAxMjA7DQogICAgICBsZXQgaW1wb3J0YW5jZVZhbHVlID0gZGF0YVsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXTsNCiAgICAgIGxldCByZWxldmFuY2VWYWx1ZSA9IGRhdGFbJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsNCiAgICAgIHN2Zy5zZWxlY3RBbGwoKS5yZW1vdmUoKTsNCg0KICAgICAgaWYgKGRhdGFbJ3R5cGUnXSA9PSAnMScpIHsNCiAgICAgICAgbGV0IGFyZWEgPSB0b29scy5jYWxjVHJpYW5nbGUoeCwgeSwgcik7DQogICAgICAgIF90aGlzLmRyYXdUcmlhbmdsZShzdmcsICJyZ2IoMjUwLCAxOTksIDg4KSIsIGFyZWEsICJyZ2IoMjUwLCAxOTksIDg4KSIpOw0KICAgICAgfQ0KICAgICAgZWxzZSB7DQoNCiAgICAgICAgbGV0IGN5ID0geTsNCiAgICAgICAgbGV0IHRvdGFsRHVyYXRpb24gPSBfdGhpcy50b3RhbER1cmF0aW9uOw0KICAgICAgICBsZXQgdGltZUxpbmVTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgdG90YWxEdXJhdGlvbl0sIFt4IC0gciAqIE1hdGguc3FydCgzKSAvIDIsIHggKyByICogTWF0aC5zcXJ0KDMpIC8gMl0pDQogICAgICAgIGxldCB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgX3RoaXMubWF4RER1cmF0aW9uXSwgWzAsIHIgKiAoMSArIE1hdGguc3FydCgzKSAvIDIpXSkNCiAgICAgICAgbGV0IGNpcmNsZUNvbG9yID0gY29tcHV0ZV9jb2xvcihjb2xvcl9saW5lYXIoaW1wb3J0YW5jZVZhbHVlKSk7DQogICAgICAgIF90aGlzLmRyYXdDaXJjbGUoc3ZnLCB4LCBjeSwgciwgY2lyY2xlQ29sb3IsIGRhdGEsIDEsICJlbnRDaXJjbGUiLCAiZW50Q2lyY2xlXyIgKyBkYXRhWydpZCddKTsNCg0KICAgICAgICByID0gciAqIE1hdGguc3FydCgzKSAvIDI7DQogICAgICAgIHkgKz0gciAvIDI7DQogICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpOw0KDQoNCiAgICAgICAgcGF0aC5tb3ZlVG8oeCAtIHIsIHkpOw0KICAgICAgICBsZXQgbGluZUxpID0gW2RhdGFdOw0KICAgICAgICBsZXQgbGluZVBvaW50ID0gW3sgJ2lkJzogZGF0YVsnaWQnXSwgJ3RpbWUnOiBkYXRhWyd0aW1lJ10sICd4JzogMCwgJ3knOiAwIH1dOw0KICAgICAgICBsZXQgamdpZEwgPSBbZGF0YVsnaWQnXV07DQogICAgICAgIGxldCBzaW1pbGFyaXR5UmVsc2xpID0gW2RhdGFbInNpbWlsYXJpdHlSZWwiXV07DQogICAgICAgIHdoaWxlKHNpbWlsYXJpdHlSZWxzbGkubGVuZ3RoPjApew0KICAgICAgICAgIGxldCBzaW1pbGFyaXR5UmVscyA9IHNpbWlsYXJpdHlSZWxzbGlbMF07DQogICAgICAgICAgc2ltaWxhcml0eVJlbHNsaS5zcGxpY2UoMCwxKTsNCiAgICAgICAgICBsZXQgamcgPSAwOw0KICAgICAgICAgIGZvciAobGV0IHNyZWwgaW4gc2ltaWxhcml0eVJlbHMpIHsNCiAgICAgICAgICAgIGxldCBjZGF0YSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc2ltaWxhcml0eVJlbHNbc3JlbF0gfSk7DQogICAgICAgICAgICBpZihqZ2lkTC5pbmRleE9mKGNkYXRhWydpZCddKT09LTEpew0KICAgICAgICAgICAgICBzaW1pbGFyaXR5UmVsc2xpLnB1c2goY2RhdGFbInNpbWlsYXJpdHlSZWwiXSkNCiAgICAgICAgICAgICAgamc9MTsNCiAgICAgICAgICAgICAgbGluZUxpLnB1c2goY2RhdGEpDQogICAgICAgICAgICAgIGpnaWRMLnB1c2goY2RhdGFbJ2lkJ10pDQogICAgICAgICAgICAgIGxpbmVQb2ludC5wdXNoKHsgJ2lkJzogY2RhdGFbJ2lkJ10sICd0aW1lJzogY2RhdGFbJ3RpbWUnXSwgJ3gnOiAwLCAneSc6IDAgfSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgLy8gaWYoamc9PTApew0KICAgICAgICAgICAgLy8gYnJlYWs7DQogICAgICAgICAgLy8gfQ0KICAgICAgICB9DQogICAgICAgIA0KICAgICAgICBjb25zdCBzb3J0bXQgPSAoYSwgYikgPT4gew0KICAgICAgICAgIHJldHVybiB0b29scy50aW1lMnNlY29uZHMoYVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlswXSk7DQogICAgICAgIH0NCiAgICAgICAgY29uc3Qgc29ydGxwID0gKGEsIGIpID0+IHsNCiAgICAgICAgICByZXR1cm4gdG9vbHMudGltZTJzZWNvbmRzKGFbJ3RpbWUnXVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlsndGltZSddWzBdKTsNCiAgICAgICAgfQ0KICAgICAgICBjb25zb2xlLmxvZyhsaW5lTGkpOw0KICAgICAgICBsaW5lTGkgPSBsaW5lTGkuc29ydChzb3J0bHApOw0KICAgICAgICBsaW5lUG9pbnQgPSBsaW5lUG9pbnQuc29ydChzb3J0bHApOw0KICAgICAgICBsZXQgbGluZURhdGEgPSBbW3ggLSByICogTWF0aC5zcXJ0KDMpLzItNCAsIHldXTsNCiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBsaW5lTGkubGVuZ3RoOyB0KyspIHsNCiAgICAgICAgICBsZXQgc3RhcnRUID0gbGluZUxpW3RdWyd0aW1lJ11bMF07DQogICAgICAgICAgbGV0IGR1cmF0aW9uID1saW5lTGlbdF1bJ3RvdGFsRHVyYXRpb24nXQ0KICAgICAgICAgIC8vIGxldCBlbmRUID0gbGluZUxpW3RdWyd0aW1lJ11bMV07DQogICAgICAgICAgbGV0IHN0YXJ0UyA9IHRvb2xzLnRpbWUyc2Vjb25kcyhzdGFydFQpOw0KICAgICAgICAgIGxldCBlbmRTID0gc3RhcnRTICtkdXJhdGlvbjsNCiAgICAgICAgICAvLyBsZXQgc3RhcnR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyAtIGR1cmF0aW9uICogMTApKTsNCiAgICAgICAgICAvLyBsZXQgZW5keCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTICsgZHVyYXRpb24gKiAxMCkpOw0KICAgICAgICAgIGxldCBsaW1zdCA9ICh4IC0gciAqIE1hdGguc3FydCgzKSAvIDIpOw0KICAgICAgICAgIGxldCBsaW1lZCA9ICh4ICsgciAqIE1hdGguc3FydCgzKSAvIDIpOw0KICAgICAgICAgIGxldCBzdGFydHggPSAobGltc3Q8dGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKT8odGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKToobGltc3QpOw0KICAgICAgICAgIGxldCBlbmR4ID0gKGxpbWVkPnRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTKSkpPyh0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUykpKToobGltZWQpOw0KICAgICAgICAgIC8vIGxldCBtaWR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKGVuZFMgKyBzdGFydFMpIC8gMik7DQogICAgICAgICAgbGV0IG1pZHggPSAoc3RhcnR4K2VuZHgpIC8gMjsNCiAgICAgICAgICBsZXQgeXMgPSB5Ow0KICAgICAgICAgIGxldCB5eiA9IHkgLSB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSk7DQogICAgICAgICAgbGluZVBvaW50W3RdWyd4J10gPSBtaWR4Ow0KICAgICAgICAgIGxpbmVQb2ludFt0XVsneSddID0geSAtIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcihkdXJhdGlvbikgLyAxLjc7DQogICAgICAgICAgLy8gaWYgKHN0YXJ0eCA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHsNCiAgICAgICAgICAgIGlmICh0ID4gMCkgew0KICAgICAgICAgICAgICBsaW5lRGF0YS5zcGxpY2UobGluZURhdGEubGVuZ3RoIC0gMSwgMSk7DQogICAgICAgICAgICAgIG1pZHgrPXQqNTsNCiAgICAgICAgICAgICAgc3RhcnR4ID0gbWlkeC0oKG1pZHgtKGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdICsgbWlkeCkgLyAyKSkvMjsNCiAgICAgICAgICAgICAgZW5keCs9dCo1Ow0KICAgICAgICAgICAgICB5cyA9IHkrKHktbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMV0pLzMNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnNvbGUubG9nKHlzKQ0KICAgICAgICAgIC8vIH0NCiAgICAgICAgICBsaW5lRGF0YS5wdXNoKFtzdGFydHgsIHlzXSxbbWlkeCwgeXpdLFtlbmR4LCB5XSl9DQogICAgICAgIGxpbmVEYXRhLnB1c2goW3ggKyByLCB5XSkNCiAgICAgICAgbGV0IGN1cnZlX2dlbmVyYXRvciA9IGQzLmxpbmUoKQ0KICAgICAgICAgIC54KChkKSA9PiBkWzBdKQ0KICAgICAgICAgIC55KChkKSA9PiB7DQogICAgICAgICAgICBsZXQgaCA9IE1hdGguc3FydChNYXRoLnBvdyhyLCAyKSAtIE1hdGgucG93KChkWzBdIC0gKHggLSByKSksIDIpKTsNCiAgICAgICAgICAgIGlmICgoeSAtIGRbMV0pID4gKGggKyByICogTWF0aC5zcXJ0KDMpIC8gMikpDQogICAgICAgICAgICAgIHJldHVybiB5IC0gKGggKyByICogTWF0aC5zcXJ0KDMpIC8gMikgKyAyOw0KICAgICAgICAgICAgcmV0dXJuIGRbMV07DQogICAgICAgICAgfSkNCiAgICAgICAgICAuY3VydmUoZDMuY3VydmVCdW5kbGUgKQ0KICAgICAgICAgIC8vIC5jdXJ2ZShkMy5jdXJ2ZUNhdG11bGxSb20gICkNCiAgICAgICAgICAvLyAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgY3VydmVfZ2VuZXJhdG9yKGxpbmVEYXRhKSwgIndoaXRlIiwgMiwgJzAnLCAnc29uTGluZSAnLCAnc29uTGluZSAnKTsNCg0KDQogICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbGluZVBvaW50Lmxlbmd0aDsgcCsrKSB7DQogICAgICAgICAgX3RoaXMuZHJhd0NpcmNsZShzdmcsIGxpbmVQb2ludFtwXVsneCddLCBsaW5lUG9pbnRbcF1bJ3knXSwgNSwgInJlZCIsIGxpbmVQb2ludFtwXSwgMCwgImxpbmVQb2ludCIsICJsaW5lUG9pbnRfIiArIGxpbmVQb2ludFtwXVsnaWQnXSk7DQogICAgICAgIH0NCg0KICAgICAgICAvLyAiMSI6ICJyZ2IoMTQ1LCAyMDQsIDExNykiLA0KICAgICAgICAvLyAgICIyIjogInJnYig4NCwgMTEyLCAxOTgpIiwNCiAgICAgICAgLy8gICAiMyI6ICJyZ2IoMjM4LCAxMDIsIDEwMikiLA0KICAgICAgICBsZXQgdHlwZUNvbG9yID0gew0KICAgICAgICAgICIxIjogIiNmZjljOWMiLA0KICAgICAgICAgICIyIjogIiNmNGY0ZDAiLA0KICAgICAgICAgICIzIjogIiM2ZjhiZTAiLA0KICAgICAgICB9Ow0KICAgICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHMoZGF0YVsndGltZSddWzBdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyhkYXRhWyd0aW1lJ11bMV0pOw0KICAgICAgICBsZXQgdHlwZURhdGEgPSBkYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXTsNCiAgICAgICAgbGV0IHNvbkxpc3QgPSBkYXRhWydzb24nXTsNCiAgICAgICAgbGV0IHNvbnMgPSBbc29uTGlzdF07DQogICAgICAgIHdoaWxlIChzb25zLmxlbmd0aCA+IDApIHsNCiAgICAgICAgICBsZXQgY3VyU29uTGlzdCA9IHNvbnNbMF07DQogICAgICAgICAgc29ucy5zcGxpY2UoMCwgMSk7DQogICAgICAgICAgaWYgKGN1clNvbkxpc3QubGVuZ3RoID4gMCkgew0KICAgICAgICAgICAgZm9yIChsZXQgcyBpbiBjdXJTb25MaXN0KSB7DQogICAgICAgICAgICAgIGxldCBzb25EYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBjdXJTb25MaXN0W3NdIH0pOw0KICAgICAgICAgICAgICBsZXQgc29uVHlwZURhdGEgPSBzb25EYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXTsNCg0KICAgICAgICAgICAgICBmb3IgKGxldCB0IGluIHNvblR5cGVEYXRhKSB7DQogICAgICAgICAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHNvblR5cGVEYXRhW3RdOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgICAgICAgICAgdHlwZURhdGFbdF0ucHVzaCh0eXBlRHVyaXRpb25bZF0pDQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIHNvbnMucHVzaChzb25EYXRhWydzb24nXSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIHZhciB0eXBlU3RhcnRSID0gMC8vTWF0aC5QSS80Ow0KDQogICAgICAgIHZhciB0eXBlU3RlcFIgPSBNYXRoLlBJIC8gMTsNCg0KICAgICAgICBpZiAoc29uTGlzdC5sZW5ndGggPiAwKSB7DQogICAgICAgICAgbGV0IHR5cGVUb3RhbER1ciA9IDA7DQogICAgICAgICAgZm9yIChsZXQgdCBpbiB0eXBlRGF0YSkgew0KICAgICAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHR5cGVEYXRhW3RdOw0KICAgICAgICAgICAgZm9yIChsZXQgZCBpbiB0eXBlRHVyaXRpb24pIHsNCiAgICAgICAgICAgICAgdHlwZVRvdGFsRHVyICs9ICh0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMF0pKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgdHlwZUFyY1NjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCB0eXBlVG90YWxEdXJdLCBbMCwgTWF0aC5QSSAqIDJdKTsNCiAgICAgICAgICBmb3IgKGxldCBpIGluIHR5cGVEYXRhKSB7DQogICAgICAgICAgICBsZXQgY29sb3IgPSB0eXBlQ29sb3JbaV07DQogICAgICAgICAgICBsZXQgdHlwZUR1cml0aW9uID0gdHlwZURhdGFbaV07DQogICAgICAgICAgICBsZXQgdG90YWxUeXBlU2Vjb25kcyA9IDA7DQogICAgICAgICAgICBmb3IgKGxldCBkIGluIHR5cGVEdXJpdGlvbikgew0KICAgICAgICAgICAgICB0b3RhbFR5cGVTZWNvbmRzICs9ICh0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMF0pKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYodG90YWxUeXBlU2Vjb25kcz4wKQ0KICAgICAgICAgICAge2xldCB0eXBlU3RlcFIgPSB0eXBlQXJjU2NhbGVfbGluZWFyKHRvdGFsVHlwZVNlY29uZHMpLy9NYXRoLlBJLzI7DQoNCiAgICAgICAgICAgIGxldCBlbmRBbmdsZXQgPSB0eXBlU3RhcnRSICsgMSAqIHR5cGVTdGVwUg0KICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHR5cGVTdGFydFIsIGVuZEFuZ2xlOiBlbmRBbmdsZXQgfTsgLy/liJvlu7rkuIDkuKrlvKfnlJ/miJDlmagNCiAgICAgICAgICAgIHR5cGVTdGFydFIgPSBlbmRBbmdsZXQ7DQogICAgICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgICAgIC5pbm5lclJhZGl1cyhyICsgMTApDQogICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgMjUpOw0KICAgICAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KICAgICAgICAgICAgX3RoaXMuZHJhd0FyYyhzdmcsIHgsIHkgLSByIC8gMiwgcGF0aEFyYywgY29sb3IsIGNvbG9yLCAndHlwZSBmJyArIGRhdGFbJ2lkJ10gKyAiIHQiICsgaSk7fQ0KICAgICAgICAgIH0NCg0KICAgICAgICAgIGxldCBzb25Ub3RhbCA9IDA7DQogICAgICAgICAgbGV0IHNvbk51bSA9IDANCiAgICAgICAgICBmb3IgKGxldCBzIGluIHNvbkxpc3QpIHsNCiAgICAgICAgICAgIGxldCBzb25EYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb25MaXN0W3NdIH0pOw0KICAgICAgICAgICAgbGV0IHNvbkR1ciA9IHNvbkRhdGFbJ3RvdGFsRHVyYXRpb24nXTsNCiAgICAgICAgICAgIHNvblRvdGFsICs9IHNvbkR1cjsNCiAgICAgICAgICAgIHNvbk51bSArPSAxOw0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgc2tpcEFyYyA9IE1hdGguUEkgLyAoc29uTnVtICsgMik7DQogICAgICAgICAgbGV0IHRpbWVTb25MaW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgc29uVG90YWxdLCBbMCwgTWF0aC5QSSAqIDIgLSBza2lwQXJjICogc29uTnVtXSk7DQogICAgICAgICAgbGV0IHRpbWVTb25IZWlnaExpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBzb25Ub3RhbF0sIFs0MCwgNDBdKTsNCg0KICAgICAgICAgIGxldCB0aW1lU29uQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIHNvblRvdGFsXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAgICAgICBsZXQgdGltZVNvbkNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZSgid2hpdGUiLCBjaXJjbGVDb2xvcik7DQogICAgICAgICAgdmFyIHNvblN0YXJ0UiA9IDA7Ly8tTWF0aC5QSS8yOw0KICAgICAgICAgIGZvciAobGV0IHMgaW4gc29uTGlzdCkgew0KICAgICAgICAgICAgbGV0IHNvbkRhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNvbkxpc3Rbc10gfSk7DQogICAgICAgICAgICBsZXQgc29uRHVyID0gc29uRGF0YVsndG90YWxEdXJhdGlvbiddOw0KDQogICAgICAgICAgICBsZXQgc29uU3RlcFIgPSB0aW1lU29uTGluZWFyKHNvbkR1cikvL01hdGguUEkvMjsNCg0KICAgICAgICAgICAgbGV0IGVuZEFuZ2xldCA9IHNvblN0YXJ0UiArIHNvblN0ZXBSOw0KICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHNvblN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgICAgICAgICAgc29uU3RhcnRSID0gZW5kQW5nbGV0Ow0KICAgICAgICAgICAgbGV0IGNvbG9yID0gJ2JsdWUnOw0KICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgICAgICAuaW5uZXJSYWRpdXMociArIDI4KQ0KICAgICAgICAgICAgICAub3V0ZXJSYWRpdXMociArIHRpbWVTb25IZWlnaExpbmVhcihzb25EdXIpKTsNCiAgICAgICAgICAgIHZhciBhcmNNaWRQYXRoID0gZDMuYXJjKCkNCiAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKDApDQogICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgMzIpOw0KICAgICAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KDQogICAgICAgICAgICBlbmRBbmdsZXQgPSBzb25TdGFydFIgKyBza2lwQXJjOw0KICAgICAgICAgICAgdmFyIG1pZERhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHNvblN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KDQogICAgICAgICAgICBsZXQgamlhbnRvdVBhdGggPSBkMy5wYXRoKCk7DQogICAgICAgICAgICBqaWFudG91UGF0aC5hcmMoeCwgeSAtIHIgLyAyLCByICsgMzIsIHNvblN0YXJ0UiAtIE1hdGguUEkgLyAyLCBlbmRBbmdsZXQgLSBNYXRoLlBJIC8gMik7DQoNCiAgICAgICAgICAgIHNvblN0YXJ0UiArPSBza2lwQXJjOw0KICAgICAgICAgICAgdmFyIHBhdGhNaWRBcmMgPSBhcmNNaWRQYXRoKG1pZERhdGFzZXQpOw0KICAgICAgICAgICAgbGV0IHRpbWVTb25Db2xvciA9IGNvbXB1dGVfY29sb3IoY29sb3JfbGluZWFyKHNvbkRhdGFbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ10pKTsNCiAgICAgICAgICAgIF90aGlzLmRyYXdBcmMoc3ZnLCB4LCB5IC0gciAvIDIsIHBhdGhBcmMsIHRpbWVTb25Db2xvciwgdGltZVNvbkNvbG9yLCAnc29uIGYnICsgZGF0YVsnaWQnXSArICIgcyIgKyBzb25MaXN0W3NdLCAnMCcpOw0KICAgICAgICAgICAgaWYgKHMgIT0gc29uTGlzdC5sZW5ndGggLSAxKSB7DQogICAgICAgICAgICAgIF90aGlzLmRyYXdUaW1lTGluZShzdmcsIGppYW50b3VQYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDMsICc5LDUnLCAnbWlkQXJjICcsICdtaWRBcmMgJyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KDQogICAgICAgIH0NCg0KDQogICAgICB9DQogICAgICBsZXQgdHh0cyA9IGRhdGFbJ25hbWUnXS5zcGxpdCgiICIpDQogICAgICBsZXQgdHggPSB4IC0gciAtIDMwOw0KICAgICAgbGV0IHR5ID0geSArIHIgKzYwOw0KICAgICAgbGV0IHR3ID0gcioyOw0KICAgICAgdHggPSB4Ow0KICAgICAgaWYoZGF0YVsnc29uJ10ubGVuZ3RoPT0wKXsNCiAgICAgICAgdHggPSB4Ly8tci0xMDsNCiAgICAgICAgdHkgPSB5K3IqMjsNCiAgICAgIH0NCiAgICAgIGlmKGRhdGFbJ2lkJ109PSIzIil7DQogICAgICAgIHR4ID0geC0xMDsNCiAgICAgICAgdHkgPSB5K3IqMjsNCiAgICAgIH0NCiAgICAgIGlmKGRhdGFbJ2lkJ109PSI0Iil7DQogICAgICAgIHR4ID0geCsxMDsNCiAgICAgICAgdHkgPSB5K3IqMjsNCiAgICAgIH0NCiAgICAgIC8vIGlmKGRhdGFbJ3R5cGUnXT09JzEnKXsNCiAgICAgIC8vICAgdHggPSB4LXIvMjsNCiAgICAgIC8vICAgdHkgPSB5K3IqMjsNCiAgICAgIC8vIH0NCg0KICAgICAgX3RoaXMuZHJhd1R4dChzdmcsIHR4LCB0eSx0dyAsIHR4dHMsICJncmV5IiwyMiwgYHRleHRfJHtkYXRhWydpZCddfWApOw0KICAgICAgLy8gbGV0IHR4dHMgPSBfdGhpcy5uYW1laW5wdXQuc3BsaXQoIiAiKQ0KICAgICAgLy8gX3RoaXMuZHJhd1R4dChzdmcsIHggLSByIC0gMzIsIHkgKyByICsgNTAsIHIgKiAyICsgNjQsIHR4dHMsICJncmV5Iik7DQogICAgfSwNCiAgICBkcmF3VHh0KHN2ZywgeCwgeSwgd2lkdGgsIHR4dHMsIGZpbGwsIGZvbnRzaXplID0gMTIsIGlkTikgew0KICAgICAgbGV0IHR4ID0geDsNCiAgICAgIGxldCB0eSA9IHk7DQogICAgICBsZXQgcHJlV2lkdGggPSAwOw0KICAgICAgbGV0IHByZUlkTiA9IDA7DQogICAgICBsZXQgcHJldGV4dCA9ICcnDQogICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHR4dHMubGVuZ3RoOyB0KyspIHsNCiAgICAgICAgcHJldGV4dCArPSIgIisgdHh0c1t0XTsNCiAgICAgICAgbGV0IHR4dCA9IHN2Zy5hcHBlbmQoInRleHQiKQ0KICAgICAgICAgIC5hdHRyKCJ5IiwgdHkpDQogICAgICAgICAgLmF0dHIoIngiLCB0eCkNCiAgICAgICAgICAuYXR0cigiaWQiLCBgJHtpZE59XyR7dH1gKQ0KICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgICAuYXR0cigiZm9udC1zaXplIiwgZm9udHNpemUpDQogICAgICAgICAgLnN0eWxlKCJ0ZXh0LWFuY2hvciIsICJtaWRkbGUiKQ0KICAgICAgICAgIC50ZXh0KHByZXRleHQpDQogICAgICAgIGxldCB0ZXh0V2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtpZE59XyR7dH1gKS5nZXRCQm94KCkud2lkdGg7DQogICAgICAgIGlmKCh0ZXh0V2lkdGg+d2lkdGgpfHwodD09dHh0cy5sZW5ndGggLTEpKXsNCiAgICAgICAgICBwcmV0ZXh0ID0gJyc7DQogICAgICAgICAgdHggPSB4Ow0KICAgICAgICAgIHR5ICs9IDI1Ow0KICAgICAgICB9DQogICAgICAgIGVsc2V7DQogICAgICAgICAgdHh0LnJlbW92ZSgpDQogICAgICAgIH0NCiAgICAgICAgcHJlV2lkdGggKz0gdGV4dFdpZHRoOw0KICAgICAgfQ0KICAgIH0sDQogICAgZHJhd1R4dE9yaTEoc3ZnLCB4LCB5LCB3aWR0aCwgdHh0cywgZmlsbCxmb250c2l6ZT0xMikgew0KICAgICAgbGV0IHR4ID0geDsNCiAgICAgIGxldCB0eSA9IHk7DQogICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHR4dHMubGVuZ3RoOyB0KyspIHsNCg0KICAgICAgbGV0IHR4dCA9ICAgc3ZnLmFwcGVuZCgidGV4dCIpDQogICAgICAgICAgLmF0dHIoInkiLCB0eSkNCiAgICAgICAgICAuYXR0cigieCIsIHR4KQ0KICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgICAuYXR0cigiZm9udC1zaXplIixmb250c2l6ZSkNCiAgICAgICAgICAuc3R5bGUoInRleHQtYW5jaG9yIiwgIm1pZGRsZSIpDQogICAgICAgICAgLnRleHQodHh0c1t0XSkNCiAgICAgICAgdHggKz0gdHh0c1t0XS5sZW5ndGggKiAxNDsNCiAgICAgICAgaWYgKHR4IC0geCA+IHdpZHRoKSB7DQogICAgICAgICAgdHggPSB4Ow0KICAgICAgICAgIHR5ICs9IDI1Ow0KICAgICAgICB9DQogICAgICB9DQogICAgfSwNCiAgICBkcmF3VHh0T3JpKHN2ZywgeCwgeSwgd2lkdGgsIHR4dHMsIGZpbGwpIHsNCiAgICAgIGxldCB0eCA9IHg7DQogICAgICBsZXQgdHkgPSB5Ow0KICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0eHRzLmxlbmd0aDsgdCsrKSB7DQoNCiAgICAgICAgc3ZnLmFwcGVuZCgidGV4dCIpDQogICAgICAgICAgLmF0dHIoInkiLCB0eSkNCiAgICAgICAgICAuYXR0cigieCIsIHR4KQ0KICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgICAudGV4dCh0eHRzW3RdKQ0KICAgICAgICB0eCArPSB0eHRzW3RdLmxlbmd0aCAqIDEwOw0KICAgICAgICBpZiAodHggLSB4ID4gd2lkdGgpIHsNCiAgICAgICAgICB0eCA9IHg7DQogICAgICAgICAgdHkgKz0gMjU7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9LA0KICAgIGRyYXdUcmlhbmdsZShzdmcsIGNvbG9yLCBwb2ludHMsIHN0cm9rZSwgb3BhY2l0eSA9IDEpIHsNCiAgICAgIHN2Zy5hcHBlbmQoInBvbHlnb24iKQ0KICAgICAgICAuYXR0cigicG9pbnRzIiwgcG9pbnRzKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGNvbG9yKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWxpbmVqb2luIiwgInJvdW5kIikNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBvcGFjaXR5KQ0KICAgICAgICAuYXR0cigic3Ryb2tlIiwgc3Ryb2tlKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgIjE1cHgiKTsNCiAgICB9LA0KICAgIGRyYXdDaXJjbGUoc3ZnLCB4LCB5LCByLCBmaWxsLCBkYXRhLCBvcGFjaXR5LCBjbGFzc05hbWUgPSAnZW50Q2lyY2xlJywgaWROYW1lKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBjb25zdCBvRGF0YSA9IF90aGlzLmRhdGENCiAgICAgIHN2Zy5hcHBlbmQoImNpcmNsZSIpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJjeCIsIHgpDQogICAgICAgIC5hdHRyKCJjeSIsIHkpDQogICAgICAgIC5hdHRyKCJyIiwgcikNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgICAgICAub24oIm1vdXNlb3ZlciIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInIiLCByICogMS4xKQ0KICAgICAgICAgIGxldCBjbGFzc04gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBpZiAoY2xhc3NOID09ICdsaW5lUG9pbnQnKSB7DQogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigib3BhY2l0eSIsIDEpLmF0dHIoInIiLCA1KQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmYiICsgZGF0YVsnaWQnXSkNCiAgICAgICAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWQgPSBkMy5zZWxlY3QodGhpcykuYXR0cigidHJhbnNmb3JtIikNCiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZC5zcGxpdCgiICIpWzBdICsgIiBzY2FsZSgxLjEpIg0KICAgICAgICAgICAgICB9KQ0KDQogICAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5iYXNpY1JlbCIpDQogICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IGNsYXNzTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgICAgICAgIGxldCBjbGFzc05MaXN0ID0gY2xhc3NOLnNwbGl0KCIgIik7DQogICAgICAgICAgICAgICAgbGV0IGpnID0gMDsNCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc291cmNlJyArIGRhdGFbJ2lkJ10sIGNsYXNzTkxpc3RbaV0pDQogICAgICAgICAgICAgICAgICBpZiAoJ3NvdXJjZScgKyBkYXRhWydpZCddID09IGNsYXNzTkxpc3RbaV0pIHsgamcgPSAxOyB9DQogICAgICAgICAgICAgICAgICBpZiAoJ3RhcmdldCcgKyBkYXRhWydpZCddID09IGNsYXNzTkxpc3RbaV0pIHsgamcgPSAxOyB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmIChqZyA9PSAxKSB7DQogICAgICAgICAgICAgICAgICBjbGFzc04gKz0gIiBhY3RpdmVTIjsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTjsNCiAgICAgICAgICAgICAgfSkNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2VsZWF2ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInIiLCByKQ0KICAgICAgICAgIGxldCBjbGFzc04gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBpZiAoY2xhc3NOID09ICdsaW5lUG9pbnQnKSB7DQogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigib3BhY2l0eSIsIDApLmF0dHIoInIiLCA1KQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmYiICsgZGF0YVsnaWQnXSkNCiAgICAgICAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWQgPSBkMy5zZWxlY3QodGhpcykuYXR0cigidHJhbnNmb3JtIikNCiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZC5zcGxpdCgiICIpWzBdICsgIiBzY2FsZSgxKSINCiAgICAgICAgICAgICAgfSkNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgicGF0aCIpDQogICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IHRoaXNTZWxlY3QgPSBkMy5zZWxlY3QodGhpcykNCiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOID0gdGhpc1NlbGVjdC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgICAgICAgIGxldCBjbGFzc05MaXN0ID0gY2xhc3NOLnNwbGl0KCIgIikNCiAgICAgICAgICAgICAgICBpZiAoY2xhc3NOTGlzdFtjbGFzc05MaXN0Lmxlbmd0aCAtIDFdID09ICJhY3RpdmVTIikgew0KICAgICAgICAgICAgICAgICAgY2xhc3NOID0gIiI7DQogICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgICAgICAgIGNsYXNzTiArPSBjbGFzc05MaXN0W2ldICsgIiAiOw0KICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NODQogICAgICAgICAgICAgIH0pDQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlZG93biIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInIiLCByKTsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5mIiArIGRhdGFbJ2lkJ10pDQogICAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWQgPSBkMy5zZWxlY3QodGhpcykuYXR0cigidHJhbnNmb3JtIikNCiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWQuc3BsaXQoIiAiKVswXSArICIgc2NhbGUoMSkiDQogICAgICAgICAgICB9KQ0KICAgICAgICAgIGxldCB0aGlzSWQgPSB0aGlzLmlkLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgbGV0IHRoaXNEYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnaWQnXSA9PSB0aGlzSWQgfSkNCiAgICAgICAgICBsZXQgdGhpc1RpbWUgPSB0aGlzRGF0YVsndGltZSddOw0KICAgICAgICAgIF90aGlzLmNsaWNrX0VudCh0aGlzVGltZSk7DQogICAgICAgICAgLy8gY29uc29sZS5sb2codGhpc1RpbWUsdGhpc0lkLHRoaXNEYXRhKQ0KICAgICAgICB9KQ0KICAgICAgLy8gLm9uKCIiKQ0KICAgIH0sDQogICAgZHJhd1RpbWVMaW5lKHN2ZywgcGF0aCwgc3Ryb2tlLCB3aWR0aCwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgaWROYW1lLCBjbGFzc05hbWUpIHsNCiAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKQ0KICAgICAgICAuYXR0cignZCcsIHBhdGgudG9TdHJpbmcoKSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cignaWQnLCBpZE5hbWUpDQogICAgICAgIC5hdHRyKCJzdHJva2UtZGFzaGFycmF5Iiwgc3Ryb2tlX2Rhc2hhcnJheSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cignZmlsbCcsICdub25lJykNCiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCB0aGlzU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMpDQogICAgICAgICAgbGV0IGNsYXNzTiA9IHRoaXNTZWxlY3QuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBsZXQgaWROID0gdGhpc1NlbGVjdC5hdHRyKCJpZCIpOw0KICAgICAgICAgIGlmIChjbGFzc04uc3BsaXQoIiAiKVswXSA9PSAiYmFzaWNSZWwiKSB7DQogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiLCBjbGFzc04gKyAiIGFjdGl2ZVMiKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IHRoaXNTZWxlY3QgPSBkMy5zZWxlY3QodGhpcykNCiAgICAgICAgICBsZXQgY2xhc3NOID0gdGhpc1NlbGVjdC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBjbGFzc05MaXN0ID0gY2xhc3NOLnNwbGl0KCIgIikNCiAgICAgICAgICBpZiAoY2xhc3NOTGlzdFtjbGFzc05MaXN0Lmxlbmd0aCAtIDFdID09ICJhY3RpdmVTIikgew0KICAgICAgICAgICAgY2xhc3NOID0gIiI7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgIGNsYXNzTiArPSBjbGFzc05MaXN0W2ldICsgIiAiOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIiwgY2xhc3NOKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgfSwNCiAgICBkcmF3QXJjKHN2ZywgeCwgeSwgYXJjUGF0aCwgc3Ryb2tlLCBmaWxsLCBjbGFzc05hbWUsIHN0cm9rZV9kYXNoYXJyYXkgPSAiMCIsIHdpZHRoID0gMykgew0KICAgICAgc3ZnLmFwcGVuZCgicGF0aCIpDQogICAgICAgIC5hdHRyKCJkIiwgYXJjUGF0aCkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgeCArICIsIiArIHkgKyAiKSIpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1kYXNoYXJyYXkiLCBzdHJva2VfZGFzaGFycmF5KQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWxpbmVqb2luIiwgInJvdW5kIikNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgIH0sDQogICAgdXBkYXRhKCkgew0KICAgICAgDQogICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IG1heERJbXBvcnRhbmNlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107IH0pKQ0KICAgICAgbGV0IG1pbkRJbXBvcnRhbmNlID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107IH0pKQ0KICAgICAgbGV0IG1heERSZWxldmFuY2UgPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnYXR0cmlidXRlJ11bJ3JlbGV2YW5jZSddOyB9KSkNCiAgICAgIGxldCBtaW5EUmVsZXZhbmNlID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsgfSkpDQogICAgICBsZXQgbWF4RER1cmF0aW9uID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHRvb2xzLnRpbWUyc2Vjb25kcyhkWyd0aW1lJ11bMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGRbJ3RpbWUnXVswXSk7IH0pKQ0KICAgICAgbGV0IG1heFRvdGFsRHVyYXRpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsndG90YWxEdXJhdGlvbiddOyB9KSkNCg0KICAgICAgX3RoaXMubWluREltcG9ydGFuY2UgPSBtaW5ESW1wb3J0YW5jZTsNCiAgICAgIF90aGlzLm1heERJbXBvcnRhbmNlID0gbWF4REltcG9ydGFuY2U7DQogICAgICBfdGhpcy5taW5EUmVsZXZhbmNlID0gbWluRFJlbGV2YW5jZTsNCiAgICAgIF90aGlzLm1heERSZWxldmFuY2UgPSBtYXhEUmVsZXZhbmNlOw0KICAgICAgX3RoaXMubWF4RER1cmF0aW9uID0gbWF4RER1cmF0aW9uOw0KICAgICAgX3RoaXMubWF4VG90YWxEdXJhdGlvbiA9IG1heFRvdGFsRHVyYXRpb247DQoNCiAgICAgIGxldCBjdXJyZW50TWF4Q29sb3IgPSBfdGhpcy5pbXBvcnRhbmNlTWF4Q29sb3I7DQogICAgICBsZXQgY3VycmVudE1pbkNvbG9yID0gX3RoaXMuaW1wb3J0YW5jZU1pbkNvbG9yOw0KICAgICAgX3RoaXMuaW1wb3J0YW5jZUNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFttaW5ESW1wb3J0YW5jZSwgbWF4REltcG9ydGFuY2VdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgX3RoaXMuaW1wb3J0YW5jZUNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50TWluQ29sb3IsIGN1cnJlbnRNYXhDb2xvcik7DQogICAgICBfdGhpcy5yZWxldmFuY2VTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbbWluRFJlbGV2YW5jZSwgbWF4RFJlbGV2YW5jZV0sIFsyMCwgNTBdKQ0KICAgICAgX3RoaXMudG90YWxEdXJhdGlvblNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBtYXhUb3RhbER1cmF0aW9uXSkucmFuZ2UoWzIwLCA2MF0pOw0KDQoNCg0KDQogICAgICBfdGhpcy4kYnVzLiRlbWl0KCJncmFwaERhdGEiLCBfdGhpcy5kYXRhKTsNCiAgICAgIF90aGlzLiRidXMuJGVtaXQoInJlbERhdGEiLCBfdGhpcy5yZWxEYXRhKTsNCiAgICAgIC8vIF90aGlzLmRyYXd0b3BpY0xpbmUoKTsNCiAgICAgIC8vIF90aGlzLmRyYXdyb290VHJlZSgpOw0KICAgICAgX3RoaXMuZHJhd2VkaXREYXRhKCk7DQogICAgfSwNCiAgICBjbGlja19FbnQodGltZSkgew0KICAgICAgdGhpcy4kZW1pdCgidGltZUR1ciIsIHRpbWUpOw0KICAgIH0sDQogIH0sDQogIGNyZWF0ZWQoKSB7DQogICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsNCiAgICAgIF90aGlzLmdldFRyZWVEYXRhKCk7DQogICAgICBfdGhpcy51cGRhdGEoKTsNCg0KICAgIH0pOw0KICB9LA0KICBtb3VudGVkKCkgew0KICAgIGNvbnN0IF90aGlzID0gdGhpcw0KICAgIF90aGlzLnRhYmxlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydrZXknXSA9PSAnbmFtZScgfSlbJ3ZhbHVlJ10gPSAnQ29tcHV0ZXIgTmV0d29yayc7DQogICAgdGhpcy4kYnVzLiRvbignc2VsZWN0RW50JywgKHZhbCkgPT4gew0KICAgICBjb25zb2xlLmxvZyh2YWwpOw0KICAgICBfdGhpcy5jdXJFbnRJZCA9IHZhbDsNCiAgICB9KTsNCiAgfSwNCiAgLy8gYmVmb3JlRGVzdHJveSgpIHsNCiAgLy8gICBjbGVhckludGVydmFsKHRoaXMubW92ZVRpbWVyKTsNCiAgLy8gfSwNCn0gDQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/EditPanel","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"editPanel\">\r\n    <div class=\"panelHead\">SupportPanel</div>\r\n    <div id=\"editPanelDiv\" class=\"panelBody\" ref=\"editPanelDiv\">\r\n      <div id=\"topicLine\" ref=\"topicLine\"></div>\r\n      <!-- <div id=\"rootTree\" ref=\"rootTree\">\r\n        <div id=\"toolsButs\">\r\n          <el-collapse accordion>\r\n            <el-collapse-item>\r\n              <template slot=\"title\">\r\n                <img class=\"iconUpload\" :src=\"toolsButsUrl\">\r\n              </template>\r\n              <div id=\"addNodeSonDiv\" class=\"toolsBut\" @click=\"addNodeSonClk\">\r\n                <img class=\"iconUpload\" :src=\"addNodeSonUrl\">\r\n              </div>\r\n              <div id=\"addNodePerDiv\" class=\"toolsBut\" @click=\"addNodePerClk\">\r\n                <img class=\"iconUpload\" :src=\"addNodePerUrl\">\r\n              </div>\r\n              <div id=\"addLinkBasicDiv\" class=\"toolsBut\" @click=\"addLinkBasicClk\">\r\n                <img class=\"iconUpload\" :src=\"addLinkBasicUrl\">\r\n              </div>\r\n            </el-collapse-item>\r\n          </el-collapse>\r\n        </div>\r\n      </div> -->\r\n      <div id=\"editData\" ref=\"editData\">\r\n        <el-table class=\"editTable\" :data=\"tableData\" style=\"width: 100%\">\r\n          <el-table-column prop=\"key\" label=\"\" width=\"260\">\r\n          </el-table-column>\r\n          <el-table-column prop=\"value\" label=\"\" width=\"260\">\r\n            <template slot-scope=\"scope\">\r\n              <div v-if=\"scope.row.key == 'type'\">\r\n                <el-radio-group v-model=\"typeRadio\" size=\"small\" @change=\"selectType\">\r\n                  <el-radio-button label=\"cell State\"></el-radio-button>\r\n                  <el-radio-button label=\"hidden State\"></el-radio-button>\r\n                </el-radio-group>\r\n              </div>\r\n              <div v-if=\"scope.row.key == 'lecture style'\">\r\n                <div class=\"block\">\r\n                  <el-slider v-model=\"lectureStyleValue\" range>\r\n                  </el-slider>\r\n                </div>\r\n              </div>\r\n              <div v-if=\"scope.row.key == 'name'\">\r\n                <el-input size=\"small\" :placeholder=\"scope.row.value\" v-model=\"nameinput\" clearable>\r\n                </el-input>\r\n              </div>\r\n              <div :class=\"scope.row.key + ' tableCell'\" :height=\"scope.row.value === '' ? '10' : '0'\"\r\n                disable-transitions>\r\n                <!-- {{ scope.row.value }} -->\r\n              </div>\r\n            </template>\r\n          </el-table-column>\r\n        </el-table>\r\n        <div id=\"cancelDiv\" @click=\"cancelClk\">\r\n          <img class=\"iconUpload\" :src=\"cancelUrl\">\r\n        </div>\r\n        <div id=\"confirmDiv\" @click=\"confirmClk\">\r\n          <img class=\"iconUpload\" :src=\"confirmUrl\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport filenames from \"@/utils/fileName\";\r\nimport domtoimage from 'dom-to-image';\r\nimport TestJson from \"@/assets/json/case1_fin.json\";\r\nimport TestRelJson from \"@/assets/json/case1_fin_rel.json\";\r\nimport tools from \"@/utils/tools.js\";\r\n\r\nexport default {\r\n  props: [],\r\n  data() {\r\n    return {\r\n      typeRadio: \"cell State\",\r\n      data: TestJson,\r\n      relData: TestRelJson,\r\n      treeData: null,\r\n      toolsState: '',\r\n      confirmUrl: require(\"@/assets/img/confirm.svg\"),\r\n      cancelUrl: require(\"@/assets/img/cancel.svg\"),\r\n      toolsButsUrl: require(\"@/assets/img/toolsButs.png\"),\r\n      addNodeSonUrl: require(\"@/assets/img/addNode1.png\"),\r\n      addNodePerUrl: require(\"@/assets/img/addNode2.png\"),\r\n      addLinkBasicUrl: require(\"@/assets/img/addLink.png\"),\r\n      // nameinput: \"Random Variables\",\r\n      nameinput: \"Fundamental Graphs\",\r\n      // nameinput: \"Trees\",\r\n      lectureStyleValue: [0, 80],\r\n      tableData: [{\r\n        key: 'type',\r\n        value: '',\r\n      }, {\r\n        key: 'name',\r\n        value: '',\r\n      }, {\r\n        key: 'lecture style',\r\n        value: '',\r\n      }],\r\n      curEntId: \"\",\r\n      insertEntId: \"\",\r\n      insertSourceEntId: \"-1\",\r\n      insertTargetEntId: \"-1\",\r\n      sonList: [],\r\n      minDImportance: 0,\r\n      maxDImportance: 0,\r\n      minDRelevance: 0,\r\n      maxDRelevance: 0,\r\n      maxDDuration: 0,\r\n      maxTotalDuration: 0,\r\n      importanceMinColor: \"rgb(203, 230, 209)\",\r\n      importanceMaxColor: \"rgb(22, 144, 207)\",\r\n      totalDuration: 1000,\r\n      importanceColor_linear: null,\r\n      importanceCompute_color: null,\r\n      relevanceScale_linear: null,\r\n      totalDurationScale_linear: null,\r\n      DivisionDataList: [],\r\n      rootDivisionDataList: [],\r\n      entDivisionDataList: [],\r\n      colorMap: {},\r\n      rootColorMap:{},\r\n      videoDuration: 570,\r\n      selectRectId: \"\",\r\n      selectRectClass: \"\",\r\n      topicLineWidth: 1000,\r\n      topicLineHeight: 1000,\r\n      moveLineWidth: 1000,\r\n      entLineWidth: 1000,\r\n      totalSonDuration: 0,\r\n      treeGTransformK:1,\r\n      treeGTransformX:10,\r\n      treeGTransformY:100,\r\n      margin: { top: 5, right: 5, bottom: 5, left: 5 },\r\n      // mcolor: [\r\n      //   \"rgb(255,60,60)\",\r\n      //   \"rgb(155,20,100)\",\r\n      //   \"rgb(255,83,255)\",\r\n      //   \"rgb(200,100,50)\",\r\n      //   \"rgb(235,135,162)\",\r\n      //   \"rgb(200,200,102)\",\r\n      //   \"rgb(255,178,101)\",\r\n      //   \"rgb(63,151,134)\",\r\n      //   \"rgb(83,155,255)\",\r\n      //   \"rgb(50,200,120)\",\r\n      //   \"rgb(2,50,200)\",\r\n      //   \"rgb(0,122,244)\",\r\n      //   \"rgb(150,122,244)\",\r\n      //   \"rgb(168,168,255)\",\r\n      //   \"rgb(200,200,200)\",\r\n      // ],\r\n      mcolor: [\r\n        \"rgb(91, 107, 255)\",\r\n        \"rgb(6, 214, 160)\",\r\n        \"rgb(255, 120, 90)\",\r\n        \"rgb(125, 98, 211)\",\r\n        \"rgb(255, 113, 212)\",\r\n        \"rgb(112, 214, 255)\",\r\n        \"rgb(255, 159, 28)\",\r\n        \"rgb(255, 77, 109)\",\r\n      ],\r\n      mLightcolor: [\r\n        \"#ff9c9c\",\r\n        \"#cc88b0\",\r\n        \"#ffa8ff\",\r\n        \"#e3b097\",\r\n        \"#f4c3d0\",\r\n        \"#f4f4d0\",\r\n        \"#ffd8b1\",\r\n        \"#9ecac2\",\r\n        \"#a8ccff\",\r\n        \"#97e3ba\",\r\n        \"#6f8be0\",\r\n        \"rgb(0,122,244)\",\r\n        \"#b6a2f7\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n    };\r\n  },\r\n  watch: {\r\n    typeRadio(val) {\r\n    },\r\n    lectureStyleValue(val){\r\n      console.log(val);\r\n      let mid = (val[0]+val[1])/2;\r\n      d3.select(\"#editData .el-slider__runway\")\r\n      .attr(\"style\",\"background: linear-gradient(90deg, #ff9c9c \"+mid+\"%,#6f8be0 \"+mid+\"%) !important\")\r\n    },\r\n    type(val) {\r\n    },\r\n    // selectEnt(val){\r\n    //   console.log(val);\r\n    // },\r\n    curEntId(curEntId) {\r\n      const _this = this;\r\n      let data = _this.data;\r\n      let curEnt = data.find(function (d) { return d['id'] == curEntId; });\r\n      if (curEnt['type'] == '1') {\r\n        _this.typeRadio = \"hidden State\";\r\n      }\r\n      else {\r\n        _this.typeRadio = \"cell State\";\r\n      }\r\n      _this.nameinput = curEnt['name'];\r\n      let duration = tools.time2seconds(curEnt['time'][1]) - tools.time2seconds(curEnt['time'][0]);\r\n      let typeDurScale_linear = d3.scaleLinear([0, duration], [0, 100]);\r\n      let typeData = curEnt[\"attribute\"][\"expressions\"];\r\n      let typeDur = 0;\r\n      let styleValue = [];\r\n      for (let i in typeData) {\r\n        // let color = typeColor[i];\r\n        let typeDurition = typeData[i];\r\n        let totalTypeSeconds = 0;\r\n        for (let d in typeDurition) {\r\n          totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n        }\r\n        typeDur += totalTypeSeconds;\r\n        styleValue.push(typeDurScale_linear(typeDur))\r\n      }\r\n\r\n      _this.lectureStyleValue = styleValue\r\n      _this.drawEntity(curEnt);\r\n      _this.drawSonLine(curEnt);\r\n    }\r\n  },\r\n  methods: {\r\n    selectType(v) {\r\n      // console.log(v)\r\n    },\r\n    cancelClk() {\r\n      const _this = this;\r\n      let data = _this.data;\r\n      let curEntId = _this.curEntId;\r\n      let curEnt = data.find(function (d) { return d['id'] == curEntId; });\r\n      _this.drawEntity(curEnt);\r\n      _this.drawSonLine(curEnt);\r\n      _this.drawrootTree();\r\n\r\n    },\r\n    confirmClk() {\r\n      const _this = this;\r\n      let data = _this.data;\r\n      let curEntId = _this.curEntId;\r\n      let curEnt = data.find(function (d) { return d['id'] == curEntId; });\r\n      if (_this.typeRadio == \"hidden State\") {\r\n        curEnt['type'] = '1'\r\n      }\r\n      else {\r\n        curEnt['type'] = '0';\r\n      }\r\n      curEnt['name'] = _this.nameinput;\r\n\r\n      let styleValue = _this.lectureStyleValue;\r\n      let startSeconds = tools.time2seconds(curEnt['time'][0]);\r\n      let endSeconds = tools.time2seconds(curEnt['time'][1]);\r\n      let totalSeconds = endSeconds - startSeconds;\r\n      let typeDurReScale_linear = d3.scaleLinear([0, 100], [startSeconds, endSeconds]);\r\n      let typeData = { \"1\": [], \"2\": [], \"3\": [] };//;\r\n      let t1 = tools.seconds2time(typeDurReScale_linear(styleValue[0]));\r\n      let t2 = tools.seconds2time(typeDurReScale_linear(styleValue[1]));\r\n      typeData['1'].push([curEnt['time'][0], t1]);\r\n      typeData['2'].push([t1, t2]);\r\n      typeData['3'].push([t2, curEnt['time'][1]]);\r\n      curEnt[\"attribute\"][\"expressions\"] = typeData;\r\n\r\n      let entRects = d3.selectAll(\".editEnt\").nodes();\r\n      console.log(entRects)\r\n      let totalSonDuration = _this.totalSonDuration;\r\n      let wid = _this.entLineWidth;\r\n      let cxReLinear = d3.scaleLinear([0, wid], [0, totalSonDuration]);\r\n      let preTime = '';\r\n      let typeTotalData = { \"1\": [], \"2\": [], \"3\": [] };//;\r\n      for (let n = 0; n < entRects.length; n++) {\r\n        let curRect = entRects[n];\r\n        let rectId = curRect.id.split(\"_\")[1];\r\n        let rectData = data.find(function (d) { return d['id'] == rectId; });\r\n        let perDur = tools.time2seconds(rectData['time'][1]) - tools.time2seconds(rectData['time'][0]);\r\n        if (n == 0) {\r\n          preTime = rectData['time'][0];\r\n        }\r\n        let preSecond = tools.time2seconds(preTime);\r\n        let x = curRect.x.baseVal.value;\r\n        let w = curRect.width.baseVal.value;\r\n        let durSecond = cxReLinear(w);\r\n        let endTime = tools.seconds2time(preSecond + durSecond);\r\n        rectData['time'] = [preTime, endTime];\r\n        rectData['totalDuration'] += durSecond - perDur;\r\n        preTime = endTime;\r\n        for (let t in typeTotalData) {\r\n          typeTotalData[t] = [...typeTotalData[t], ...rectData['attribute']['expressions'][t]]\r\n        }\r\n      }\r\n      console.log(typeTotalData)\r\n      _this.data = data;\r\n      // console.log(entRects,entRects[0])\r\n\r\n      _this.drawEntity(curEnt);\r\n      _this.drawSonLine(curEnt);\r\n      _this.drawrootTree();\r\n      _this.$bus.$emit(\"graphData\", data);\r\n    },\r\n    click_node() {\r\n      const _this = this;\r\n      let nodeId = _this.curEntId;\r\n      let addDataId = _this.insertEntId;//parseInt(nodeId)+1+'';\r\n      let oriData = _this.data;\r\n      let state = _this.toolsState;\r\n      let returnData = [];\r\n      let returnRelData = {};\r\n      let relData = _this.relData;\r\n\r\n      if (state == 'addNodeSon') {\r\n        for (let i = 0; i < oriData.length; i++) {\r\n          let cData = oriData[i];\r\n          let cDataId = cData['id']\r\n          \r\n          let sons = cData['son'];\r\n          let sonsNew = [];\r\n          for(let s=0;s<sons.length;s++){\r\n            let ss = sons[s]\r\n              if(parseInt(ss)>=parseInt(addDataId)) ss = parseInt(ss)+1\r\n              sonsNew.push(ss+'')\r\n          }\r\n          cData['son'] = sonsNew;\r\n\r\n          if (parseInt(cDataId) == parseInt(addDataId)) {\r\n            let perData = tools.deepClone(cData);\r\n            let addData = tools.deepClone(perData);\r\n            addData['id'] = addDataId;\r\n            perData['id'] = (parseInt(addDataId) + 1)+'';\r\n            console.log(addData,perData)\r\n            let startT = cData['time'][0];\r\n            let endT = cData['time'][1];\r\n            let midT = tools.seconds2time((tools.time2seconds(endT) + tools.time2seconds(startT)) / 2);\r\n            addData['time'] = [startT, midT];\r\n            perData['time'] = [midT, endT];\r\n            addData['son'] = [];\r\n            addData['totalDuration'] = (tools.time2seconds(midT) - tools.time2seconds(startT));\r\n            perData['totalDuration'] -= addData['totalDuration'];\r\n            let typeTimes = perData['attribute']['expressions'];\r\n            let typePreData = { \"1\": [], \"2\": [], \"3\": [] };\r\n            let typeAddData = { \"1\": [], \"2\": [], \"3\": [] };\r\n            for (let t in typeTimes) {\r\n              for (let a = 0; a < typeTimes[t].length; a++) {\r\n                let st = typeTimes[t][a][0];\r\n                let et = typeTimes[t][a][1];\r\n                if (tools.time2seconds(et) <= tools.time2seconds(midT)) { typeAddData[t].push([st, et]) }\r\n                else if (tools.time2seconds(st) >= tools.time2seconds(midT)) { typePreData[t].push([st, et]) }\r\n                else if ((tools.time2seconds(st) < tools.time2seconds(midT)) && (tools.time2seconds(et) > tools.time2seconds(midT))) {\r\n                  typeAddData[t].push([st, midT]);\r\n                  typePreData[t].push([midT, et]);\r\n                }\r\n              }\r\n            }\r\n            perData['attribute']['expressions'] = typePreData;\r\n            addData['attribute']['expressions'] = typeAddData;\r\n            returnData.push(addData);\r\n            returnData.push(perData);\r\n          }\r\n          else if (parseInt(cData['id']) < parseInt(addDataId)) {\r\n            returnData.push(tools.deepClone(cData));\r\n          }\r\n          else if (parseInt(cData['id']) > parseInt(addDataId)){\r\n            let perData = tools.deepClone(cData);\r\n            perData['id'] = (parseInt(cDataId) + 1) + '';\r\n            returnData.push(perData);\r\n          }\r\n\r\n        }\r\n      \r\n      let bsNew = [];\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n        let sourceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        if(parseInt(sourceId)>=parseInt(addDataId)) sourceId = parseInt(sourceId)+1;\r\n        if(parseInt(targetId)>=parseInt(addDataId)) targetId = parseInt(targetId)+1;\r\n        bsNew.push([sourceId+'',targetId+''])\r\n      }\r\n      let ssNew = []\r\n      let similarityRel = relData['similarityRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n        let sourceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n        if(parseInt(sourceId)>=parseInt(addDataId)) sourceId = parseInt(sourceId)+1;\r\n        if(parseInt(targetId)>=parseInt(addDataId)) targetId = parseInt(targetId)+1;\r\n        ssNew.push([sourceId+'',targetId+''])\r\n      }\r\n      returnRelData = {'basicRel':bsNew,'similarityRel':ssNew};\r\n      let nData = returnData.find(function(d){return d['id'] == nodeId});\r\n      let aData = returnData.find(function(d){return d['id'] == addDataId});\r\n      if(nodeId!='-1'){\r\n        nData['son'].push(addDataId);\r\n        aData['layout'] = parseInt(nData['layout']+1);\r\n        aData['father'] = [nodeId];\r\n      }\r\n      else{\r\n        aData['layout'] = '0';\r\n      }\r\n      _this.data = (returnData);\r\n      _this.relData = returnRelData;\r\n      _this.getTreeData();\r\n      _this.updata();\r\n      }\r\n      if (state == 'addLinkBasic') {\r\n        let addSourceDataId = _this.insertSourceEntId;\r\n        let addTargetDataId = _this.insertTargetEntId;\r\n        if((addSourceDataId != '-1')&&(addTargetDataId != '-1')){\r\n          returnRelData =  tools.deepClone(relData);\r\n          returnRelData['basicRel'].push([addSourceDataId,addTargetDataId]);\r\n          _this.insertSourceEntId = '-1';\r\n          _this.insertTargetEntId = '-1';\r\n          _this.relData = returnRelData;\r\n          _this.getTreeData();\r\n          _this.updata();\r\n        }\r\n      }\r\n    },\r\n    addNodeSonClk() {\r\n      this.toolsState = 'addNodeSon';\r\n    },\r\n    addNodePerClk() {\r\n      this.toolsState = 'addNodePer';\r\n    },\r\n    addLinkBasicClk() {\r\n      this.toolsState = 'addLinkBasic';\r\n    },\r\n    drawtopicLine() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      const color = _this.mcolor;\r\n\r\n      let width = this.$refs.topicLine.offsetWidth - margin.left - margin.right;\r\n      let height = this.$refs.topicLine.offsetHeight - margin.top - margin.bottom;\r\n      _this.topicLineWidth = width;\r\n      _this.topicLineHeight = height;\r\n      d3.select(\"#topicLine\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#topicLine\").append(\"svg\")\r\n        .attr(\"id\", \"topicLineSvg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height);\r\n      let rootEntG = groups.append(\"g\").attr(\"id\", \"rootEntG\").attr(\"width\", width).attr(\"height\", height);\r\n      let oriLineG = groups.append(\"g\").attr(\"id\", \"oriLineG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      oriLineG.append(\"line\")\r\n        .attr(\"x1\", 0)\r\n        .attr(\"y1\", height / 2)\r\n        .attr(\"x2\", width)\r\n        .attr(\"y2\", height / 2)\r\n        .attr(\"stroke\", \"rgb(200,200,200)\")\r\n        .attr(\"stroke-width\", \"5px\");\r\n\r\n      let cxLinear = d3.scaleLinear([0, _this.videoDuration], [margin.left, width])\r\n\r\n      let data = tools.deepClone(_this.data);\r\n      let DivisionDataList = [];\r\n      let colorIndex = 0;\r\n      for (let i = 0; i < data.length; i++) {\r\n        if (data[i]['layout'] == '0') {\r\n          if (DivisionDataList.length != 0) {\r\n            DivisionDataList[DivisionDataList.length - 1]['nextId'] = data[i]['id'];\r\n            data[i]['preId'] = DivisionDataList[DivisionDataList.length - 1]['id'];\r\n          }\r\n          else { data[i]['preId'] = \"-1\"; }\r\n          DivisionDataList.push(data[i]);\r\n          let time = tools.time2seconds(data[i]['time'][0]);\r\n          let endTime = tools.time2seconds(data[i]['time'][0]) + data[i]['totalDuration'];\r\n          let cx = cxLinear(time);\r\n          let endx = cxLinear(endTime);\r\n          _this.colorMap[data[i]['id']] = colorIndex % color.length;\r\n          _this.drawRect(oriLineG, cx - 5, height / 2 - 5, 10, 10, height / 2, \"division_\" + data[i][\"id\"], \"rootdivisionLine\", \"rgb(250,250,250)\", 0, '', 1)\r\n          _this.drawRect(rootEntG, cx, margin.top, endx - cx, height - margin.top - margin.bottom, height / 2, \"rootEnt_\" + data[i]['id'], \"rootEnt\", color[_this.colorMap[data[i]['id']]], 5, \"rgb(150,150,150)\", 0.1)\r\n          colorIndex++;\r\n        }\r\n      }\r\n      DivisionDataList[DivisionDataList.length - 1]['nextId'] = \"-1\";\r\n      _this.rootDivisionDataList = DivisionDataList;\r\n\r\n      // oriLineG.append(\"ellipse\")\r\n      // .attr(\"cx\",50)\r\n      // .attr(\"cy\",height/2)\r\n      // .attr(\"rx\",50)\r\n      // .attr(\"ry\",height/2)\r\n      // .attr(\"fill\",color[3])\r\n      // .attr(\"stroke\", color[3])\r\n\r\n      // .attr(\"stroke-width\", \"5px\");\r\n      // console.log(data)\r\n      // this.$bus.$emit(\"getData\",data)\r\n    },\r\n    drawRect(svg, x, y, w, h, rx, idName, className, fill, strokeWidth, stroke, opacity) {\r\n      const _this = this;\r\n      svg.append(\"rect\")\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"width\", w)\r\n        .attr(\"height\", h)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"stroke\", stroke)//\"rgb(150,150,150)\")\r\n        .attr(\"stroke-width\", strokeWidth)\r\n        .on(\"mousedown\", function (d) {\r\n          _this.selectRectId = idName.split(\"_\")[1] //d3.select(this).attr(\"id\");\r\n          if (d3.select(this).attr(\"class\") == \"rootdivisionLine\") {\r\n            _this.selectRectClass = \"rootEnt\";\r\n            _this.moveLineWidth = _this.topicLineWidth;\r\n            _this.DivisionDataList = _this.rootDivisionDataList;\r\n            // document.getElementById('topicLineSvg').addEventListener(\"mousemove\", _this.moveRect); // \r\n          }\r\n          else if (d3.select(this).attr(\"class\") == \"entdivisionLine\") {\r\n            _this.selectRectClass = \"editEnt\";\r\n            _this.moveLineWidth = _this.entLineWidth;\r\n            _this.DivisionDataList = _this.entDivisionDataList;\r\n            document.getElementById('editEnt').addEventListener(\"mousemove\", _this.moveRect); // \r\n          }\r\n        })\r\n        .on(\"mouseup\", function (d) {\r\n          // document.getElementById('topicLineSvg').removeEventListener(\"mousemove\", _this.moveRect); // \r\n          document.getElementById('editEnt').removeEventListener(\"mousemove\", _this.moveRect); // \r\n          // _this.$bus.$emit(\"graphData\", _this.data);\r\n\r\n          _this.$bus.$emit(\"treeData\", _this.treeData);\r\n        })\r\n    },\r\n    moveRect(e) {\r\n      const _this = this;\r\n      let selectRect = _this.DivisionDataList.find(function (d) { return d['id'] == _this.selectRectId; })//rect\r\n      let preId = selectRect['preId'];//rect\r\n      let nextId = selectRect['nextId'];//rect\r\n      let rectClass = _this.selectRectClass;\r\n      let prex = 0;\r\n      if (preId != '-1') {\r\n        prex = d3.select(\"#\" + rectClass + \"_\" + preId).attr(\"x\")\r\n        d3.select(\"#\" + rectClass + \"_\" + preId)\r\n          .attr(\"width\", function (d) {\r\n            return e.offsetX - prex;\r\n          })\r\n      }\r\n      let nextX = 100;\r\n      if (nextId == '-1') {\r\n        nextX = _this.moveLineWidth;\r\n      }\r\n      else {\r\n        nextX = d3.select(\"#\" + rectClass + \"_\" + nextId).attr(\"x\");\r\n      }\r\n      d3.select(\"#\" + rectClass + \"_\" + _this.selectRectId)\r\n        .attr(\"width\", function (d) {\r\n          return nextX - e.offsetX;\r\n        })\r\n        .attr(\"x\", e.offsetX)\r\n      d3.select(\"#division_\" + _this.selectRectId)\r\n        .attr(\"x\", e.offsetX - 5)\r\n\r\n      if ((e.offsetX > (_this.topicLineWidth)) || (e.offsetX < (0)) || (e.offsetY > (_this.topicLineHeight)) || (e.offsetY < (0))) {\r\n        // document.getElementById('topicLineSvg').removeEventListener(\"mousemove\", _this.moveRect); // \r\n      }\r\n    },\r\n    getTreeData(){\r\n      const _this = this;\r\n      let oriData = tools.deepClone(this.data);\r\n      var data = {\r\n        \"name\": \"root\",\r\n        \"children\": []\r\n      };\r\n\r\n      for (let i = oriData.length - 1; i >= 0; i--) {\r\n        let sons = oriData[i]['son'];\r\n        oriData[i]['children'] = [];\r\n        if (sons.length > 0) {\r\n          for (let s = 0; s < sons.length; s++) {\r\n            oriData[i]['children'].push(oriData.find(function (d) { return d['id'] == sons[s] }))\r\n          }\r\n        }\r\n      }\r\n      let c = 0 ;\r\n      for (let i = 0; i < oriData.length; i++) {\r\n\r\n        let layout = oriData[i]['layout'];\r\n        if (layout == '0') {\r\n          data['children'].push(oriData[i]);\r\n          if(oriData[i]['name']!=\"Test\"){\r\n            _this.rootColorMap[oriData[i]['id']] = _this.mcolor[c];\r\n            c++;\r\n          }\r\n          else{\r\n            _this.rootColorMap[oriData[i]['id']] =\"rgb(250, 199, 88)\";\r\n          }\r\n        }\r\n      }\r\n\r\n      this.treeData = data;\r\n      console.log(_this.rootColorMap)\r\n      this.$bus.$emit(\"treeData\", [data,_this.rootColorMap]);\r\n    },\r\n    drawrootTree() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      let width = this.$refs.rootTree.offsetWidth - margin.left - margin.right;\r\n      let height = this.$refs.rootTree.offsetHeight - margin.top - margin.bottom;\r\n\r\n      let color = _this.mcolor;\r\n      let colorMap = _this.colorMap;\r\n      // var tree = d3.tree()\r\n      //   .size([width, height - 200]);\r\n      d3.select(\"#rootTree\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#rootTree\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n\r\n      let transY = height;\r\n      let treeGTransformX = _this.treeGTransformX;\r\n      let treeGTransformY = _this.treeGTransformY;\r\n      let treeGTransformK = _this.treeGTransformK;\r\n      let groups = svg.append(\"g\")\r\n        .attr(\"id\", \"editrootTreeg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n        .attr(\"transform\",  \"translate(\"+treeGTransformX+',' +treeGTransformY + \") scale(\"+treeGTransformK+\")\");\r\n\r\n        let stx = 0;\r\n        let sty = 0;\r\n        let stk =1;\r\n      var graphZoom = d3.zoom()\r\n        .scaleExtent([0, 10])\r\n        .on(\"start\", (e) => {\r\n          sty = e.transform.y;\r\n          stx = e.transform.x;\r\n          stk = e.transform.k;\r\n        })\r\n        .on('zoom', (e) => {\r\n          treeGTransformX = _this.treeGTransformX + e.transform.x - stx;\r\n          treeGTransformY = _this.treeGTransformY + e.transform.y - sty;\r\n          treeGTransformK = _this.treeGTransformK + e.transform.k - stk;\r\n          groups.attr('transform', 'translate(' + (treeGTransformX) + ',' + (treeGTransformY) + ') scale(' + (treeGTransformK) + ')')\r\n        })\r\n        .on('end', (e) => {\r\n          _this.treeGTransformX = treeGTransformX;\r\n          _this.treeGTransformY = treeGTransformY;\r\n          _this.treeGTransformK = treeGTransformK;\r\n          groups.attr('transform', 'translate(' + (treeGTransformX) + ',' + (treeGTransformY) + ') scale(' + (treeGTransformK) + ')')\r\n        });\r\n      svg.call(graphZoom)\r\n\r\n      const gLink = groups.append(\"g\")\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", \"#555\")\r\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\r\n        .attr(\"stroke-opacity\", 0.4)\r\n        .attr(\"stroke-width\", 1.5);\r\n\r\n      const gNode = groups.append(\"g\")\r\n        .attr(\"cursor\", \"pointer\")\r\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\r\n        .attr(\"pointer-events\", \"all\")\r\n\r\n      let data = _this.treeData;\r\n      let diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);\r\n      let tree = d3.tree().nodeSize([50, 150]);//.size([(height - margin.left - margin.right) * 2, (width - margin.left - margin.right)-10])\r\n      const root = d3.hierarchy(data);\r\n      const nodes = root.descendants().reverse();\r\n      const links = root.links();\r\n      tree(root);\r\n      console.log(nodes)\r\n      const node = gNode.selectAll(\"g\")\r\n        .data(nodes, d => d.id);\r\n\r\n      const nodeEnter = node.data(nodes).enter().append(\"g\")\r\n        .attr(\"transform\", (d) => {\r\n          return `translate(${d.y},${d.x})`\r\n        })\r\n        .on(\"click\", (event, d) => {\r\n          d.children = d.children ? null : d._children;\r\n          // update(d);\r\n        })\r\n\r\n      nodeEnter.append(\"circle\")\r\n        .attr(\"r\", 10)\r\n        .attr(\"id\", function (d) {\r\n          console.log(d)\r\n          if(d.data.name == 'root')\r\n            return \"treeNode_-1\";\r\n          return \"treeNode_\" + d.data.id;\r\n        })\r\n        .attr(\"fill\", function (d) {\r\n          if (d.data.name == 'root') {\r\n            return 'grey'\r\n          }\r\n          else {\r\n            let parent = d.parent;\r\n            let rootd = null;\r\n            while (parent.data.name != 'root') {\r\n              rootd = parent;\r\n              if (parent.parent.data.name == 'root') {\r\n                return color[colorMap[parent.data.id]]\r\n              }\r\n              parent = parent.parent;\r\n            }\r\n            return color[colorMap[d.data.id]]\r\n          }\r\n\r\n        })\r\n        .attr(\"stroke\", \"rgb(100,100,100)\")\r\n        // .attr(\"fill\", d => d._children ? \"#555\" : \"#999\")\r\n        .attr(\"stroke-width\", 1)\r\n        .on(\"mouseover\", function () {\r\n          d3.select(this).attr(\"r\", 15);\r\n\r\n        })\r\n        .on(\"mouseleave\", function () {\r\n          d3.select(this).attr(\"r\", 10)\r\n        })\r\n        .on(\"mousedown\", function () {\r\n          let nodeIdN = d3.select(this).attr(\"id\");\r\n          let nodeId = nodeIdN.split(\"_\")[1];\r\n          _this.curEntId = nodeId;\r\n          if(nodeId == '-1'){\r\n            _this.insertEntId = parseInt(nodeId) + 1 + '';\r\n          _this.click_node();\r\n            return\r\n          }\r\n          let curData = _this.data.find(function (d) { return d['id'] == nodeId; });\r\n          if (_this.toolsState == 'addNodeSon') {\r\n            _this.insertEntId = parseInt(nodeId) + 1 + '';\r\n          }\r\n          else if (_this.toolsState == 'addLinkBasic') {\r\n            if(_this.insertSourceEntId ==\"-1\")\r\n              _this.insertSourceEntId = parseInt(nodeId) + '';\r\n            else{\r\n              _this.insertTargetEntId = parseInt(nodeId) + '';\r\n            }\r\n          }\r\n          if ( (curData['son'].length > 0)) {\r\n            _this.insertEntId = parseInt(curData['son'][0]) + 1 +'';\r\n          };\r\n          _this.click_node();\r\n        })\r\n\r\n      // nodeEnter.append(\"text\")\r\n      //   .attr(\"dy\", \"0.31em\")\r\n      //   .attr(\"x\", d => d._children ? -6 : 6)\r\n      //   .attr(\"text-anchor\", d => d._children ? \"end\" : \"start\")\r\n      //   .text(d => d.data.name)\r\n      //   .clone(true).lower()\r\n      //   .attr(\"stroke-linejoin\", \"round\")\r\n      //   .attr(\"stroke-width\", 3)\r\n      //   .attr(\"stroke\", \"white\");\r\n\r\n      const link = gLink.selectAll(\"path\")\r\n        .data(links, d => d.target.id);\r\n\r\n      const linkEnter = link.enter().append(\"path\")\r\n        .attr(\"d\", d => {\r\n          const o = { x: d.source.x, y: d.source.y };\r\n          const p = { x: d.target.x, y: d.target.y }\r\n          return diagonal({ source: o, target: p });\r\n        })\r\n        .attr(\"stroke\", \"rgb(100,100,100)\")\r\n        .attr(\"stroke-width\", 5)\r\n      _this.drawRootTreeRel(gLink, nodes);\r\n    },\r\n    drawRootTreeRel(svg, nodeData) {\r\n\r\n      const _this = this;\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      console.log(nodeData)\r\n      let margin = _this.margin;\r\n      let height = svg.attr('height');\r\n      // let basicRel = relData['similarityRel'];\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n\r\n        let sourceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        let idN = \"basicRel\" + sourceId + \"_\" + targetId;\r\n        let classN = \"basicRel source\" + sourceId + \" target\" + targetId;\r\n        let sourceNode = nodeData.find(function (d) { return d['data']['id'] == sourceId });\r\n        let targetNode = nodeData.find(function (d) { return d['data']['id'] == targetId });\r\n        if (sourceNode['x'] > targetNode['x']) {\r\n          let tp = sourceNode;\r\n          sourceNode = targetNode;\r\n          targetNode = tp;\r\n        }\r\n        const path = d3.path();\r\n\r\n        let startX = sourceNode['y'];\r\n        let endX = targetNode['y'];\r\n        let startY = sourceNode['x'];\r\n        let endY = targetNode['x'];\r\n        let midX = (startX + endX) / 2;\r\n        let midY = (startY + endY) / 2;\r\n        let cnx = (startX > endX) ? (startX + 10 + 0.25 * (endY - startY)) : (endX + 10 + 0.25 * (endY - startY));\r\n        path.moveTo(startX, startY);\r\n        path.bezierCurveTo(cnx, midY, cnx, midY, endX, endY);\r\n        _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"9,9\", idN, classN);\r\n\r\n\r\n      };\r\n      let similarityRel = relData['similarityRel'];\r\n      // let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n\r\n        let sourceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n\r\n        let idN = \"similarityRel\" + sourceId + \"_\" + targetId;\r\n\r\n        let classN = \"similarityRel source\" + sourceId + \" target\" + targetId;\r\n        let sourceNode = nodeData.find(function (d) { return d['data']['id'] == sourceId });\r\n        let targetNode = nodeData.find(function (d) { return d['data']['id'] == targetId });\r\n        if (sourceNode['x'] > targetNode['x']) {\r\n          let tp = sourceNode;\r\n          sourceNode = targetNode;\r\n          targetNode = tp;\r\n        }\r\n        const path = d3.path();\r\n\r\n        let startX = sourceNode['y'];\r\n        let endX = targetNode['y'];\r\n        let startY = sourceNode['x'];\r\n        let endY = targetNode['x'];\r\n        let midX = (startX + endX) / 2;\r\n        let midY = (startY + endY) / 2;\r\n        let cnx = (startX > endX) ? (startX + 100 + 0.5 * (endY - startY)) : (endX + 100 + 0.5 * (endY - startY));\r\n\r\n        path.moveTo(startX, startY);\r\n        path.lineTo(cnx, startY);\r\n        path.lineTo(cnx, endY);\r\n        path.lineTo(endX, endY);\r\n        _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"0\", idN, classN);\r\n\r\n\r\n      };\r\n    },\r\n    draweditData() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      let width = this.$refs.editData.offsetWidth - margin.left - margin.right - 60;\r\n      let height = this.$refs.editData.offsetHeight - margin.top - margin.bottom;\r\n      d3.select(\"#editData\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#editData\").append(\"svg\")\r\n        .attr(\"id\", \"editEnt\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n      let entG = svg.append(\"g\").attr(\"id\", \"entG\").attr(\"width\", width).attr(\"height\", height);\r\n      let sonG = svg.append(\"g\").attr(\"id\", \"sonG\").attr(\"width\", width).attr(\"height\", height).attr(\"transform\", \"translate(1,320)\");\r\n      // _this.entG = entG;\r\n      // _this.sonG = sonG;\r\n      _this.drawEntity(_this.data[0]);\r\n      _this.drawSonLine(_this.data[1]);\r\n    },\r\n    drawSonLine(data) {\r\n      const _this = this;\r\n      let psvg = d3.select(\"#sonG\");\r\n      let w = psvg.attr(\"width\") - 1;\r\n      let h = 40;\r\n      psvg.remove();\r\n      let svg = d3.select(\"#editEnt\").append(\"g\").attr(\"id\", \"sonG\").attr(\"width\", w + 1).attr(\"height\", h + 2).attr(\"transform\", \"translate(1,320)\");\r\n      let color_linear = _this.importanceColor_linear;\r\n      let compute_color = _this.importanceCompute_color;\r\n      let oData = _this.data;\r\n      _this.entLineWidth = w;\r\n      // if (sonList.length > 0) {\r\n      svg.selectAll().remove();\r\n      svg.append(\"line\")\r\n        .attr(\"x1\", 0)\r\n        .attr(\"y1\", h / 2)\r\n        .attr(\"x2\", w)\r\n        .attr(\"y2\", h / 2)\r\n        .attr(\"stroke\", \"rgb(200,200,200)\")\r\n        .attr(\"stroke-width\", \"5px\");\r\n\r\n      let totalSonDuration = 0;\r\n      let dataIndex = oData.map(item => item.id).indexOf(data['id']);\r\n      let startIndex = ((dataIndex - 2) > 0) ? (dataIndex - 2) : (0);\r\n      let endIndex = ((dataIndex + 1) < oData.length) ? (dataIndex + 2) : (oData.length - 1);\r\n\r\n      let dataLi = tools.deepClone(oData).splice(startIndex, endIndex - startIndex + 1);\r\n      // let data = sonList;\r\n      for (let i = 0; i < dataLi.length; i++) {\r\n        let curEnt = oData.find(function (d) { return d['id'] == dataLi[i]['id'] });\r\n        let time = tools.time2seconds(curEnt['time'][0]);\r\n        let endTime = tools.time2seconds(curEnt['time'][1]);\r\n        totalSonDuration += endTime - time;\r\n      }\r\n      _this.totalSonDuration = totalSonDuration;\r\n      let cxLinear = d3.scaleLinear([0, totalSonDuration], [0, w]);\r\n      let DivisionDataList = [];\r\n      // let colorIndex = 0;\r\n      let prex = 0;\r\n      for (let i = 0; i < dataLi.length; i++) {\r\n        let curEnt = oData.find(function (d) { return d['id'] == dataLi[i]['id'] });\r\n        let temp = tools.deepClone(curEnt);\r\n        if (DivisionDataList.length != 0) {\r\n          DivisionDataList[DivisionDataList.length - 1]['nextId'] = temp['id'];\r\n          temp['preId'] = DivisionDataList[DivisionDataList.length - 1]['id'];\r\n        }\r\n        else { temp['preId'] = \"-1\"; }\r\n        DivisionDataList.push(temp);\r\n        let time = tools.time2seconds(curEnt['time'][0]);\r\n        let endTime = tools.time2seconds(curEnt['time'][1]);\r\n        let curEntDur = endTime - time;\r\n        let cx = prex;\r\n        let endx = prex + cxLinear(curEntDur);\r\n        let importanceValue = curEnt['attribute']['importance'];\r\n        let entColor = compute_color(color_linear(importanceValue));\r\n        if (i != 0) {\r\n          _this.drawRect(svg, cx - 5, 0, 5, h, h / 2, \"division_\" + curEnt['id'], \"entdivisionLine\", \"rgb(250,250,250)\", 5, '', 0);\r\n        }\r\n        if (dataLi[i]['id'] == data['id']) _this.drawRect(svg, cx, 0, endx - cx, h, h / 2, \"editEnt_\" + curEnt['id'], \"editEnt\", entColor, 1, \"black\", 1)//color[_this.colorMap[son['id']]], 5, 0.1)\r\n        else _this.drawRect(svg, cx, 0, endx - cx, h, h / 2, \"editEnt_\" + curEnt['id'], \"editEnt\", entColor, 1, \"rgb(150,150,150)\", 1)//color[_this.colorMap[son['id']]], 5, 0.1)\r\n        prex = endx;\r\n      }\r\n      DivisionDataList[DivisionDataList.length - 1]['nextId'] = \"-1\";\r\n      _this.entDivisionDataList = DivisionDataList;\r\n    },\r\n    drawEntityOri(data) {\r\n      const _this = this;\r\n      let psvg = d3.select(\"#entG\");\r\n      let w = psvg.attr(\"width\");\r\n      let h = psvg.attr(\"height\");\r\n      psvg.remove();\r\n      let svg = d3.select(\"#editEnt\").append(\"g\").attr(\"id\", \"entG\").attr(\"width\", w).attr(\"height\", h);\r\n      let color_linear = _this.importanceColor_linear;\r\n      let compute_color = _this.importanceCompute_color;\r\n      let totalDurationValue = data['totalDuration'];\r\n      let rScale = _this.totalDurationScale_linear;\r\n      let r = rScale(totalDurationValue);\r\n      let oData = _this.data;\r\n      let x = svg.attr(\"width\") / 2;\r\n      let y = 120;\r\n      let importanceValue = data['attribute']['importance'];\r\n      let relevanceValue = data['attribute']['relevance'];\r\n      svg.selectAll().remove();\r\n\r\n      if (data['type'] == '1') {\r\n        let area = tools.calcTriangle(x, y, r);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n      }\r\n      else {\r\n\r\n        let cy = y;\r\n        let totalDuration = _this.totalDuration;\r\n        let timeLineScale_linear = d3.scaleLinear([0, totalDuration], [x - r * Math.sqrt(3) / 2, x + r * Math.sqrt(3) / 2])\r\n        let timeLineHighScale_linear = d3.scaleLinear([0, _this.maxDDuration], [0, r * (1 + Math.sqrt(3) / 2)])\r\n        let circleColor = compute_color(color_linear(importanceValue));\r\n        _this.drawCircle(svg, x, cy, r, circleColor, data, 1, \"entCircle\", \"entCircle_\" + data['id']);\r\n\r\n        r = r * Math.sqrt(3) / 2;\r\n        y += r / 2;\r\n        let path = d3.path();\r\n\r\n\r\n        path.moveTo(x - r, y);\r\n        let lineLi = [data['time']];\r\n        let linePoint = [{ 'id': data['id'], 'time': data['time'], 'x': 0, 'y': 0 }];\r\n        for (let srel in data[\"similarityRel\"]) {\r\n          let cdata = oData.find(function (d) { return d['id'] == data[\"similarityRel\"][srel] })\r\n          lineLi.push(cdata['time'])\r\n          linePoint.push({ 'id': cdata['id'], 'time': cdata['time'], 'x': 0, 'y': 0 })\r\n        }\r\n        const sortmt = (a, b) => {\r\n          return tools.time2seconds(a[0]) - tools.time2seconds(b[0]);\r\n        }\r\n        const sortlp = (a, b) => {\r\n          return tools.time2seconds(a['time'][0]) - tools.time2seconds(b['time'][0]);\r\n        }\r\n        lineLi = lineLi.sort(sortmt);\r\n        linePoint = linePoint.sort(sortlp);\r\n        let lineData = [[x - r, y]];\r\n        for (let t = 0; t < lineLi.length; t++) {\r\n          let startT = lineLi[t][0];\r\n          let endT = lineLi[t][1];\r\n          let startS = tools.time2seconds(startT);\r\n          let endS = tools.time2seconds(endT);\r\n          let duration = endS - startS;\r\n\r\n          let startx = timeLineScale_linear((startS - duration * 10));\r\n          let endx = timeLineScale_linear((endS + duration * 10));\r\n\r\n          let startyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          let startyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          let endyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          let endyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          let yz = y - timeLineHighScale_linear((duration));\r\n          let midx = timeLineScale_linear((endS + startS) / 2);\r\n          linePoint[t]['x'] = midx;\r\n          linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n          let y1 = y;\r\n          if (startx < (lineData[lineData.length - 1][0])) {\r\n            if (t > 0) {\r\n              lineData.splice(lineData.length - 3, 3);\r\n              startx = (lineData[lineData.length - 1][0] + midx) / 2;\r\n              y1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n              startyf = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n              startyf1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n            }\r\n          }\r\n          let startx1 = startx + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          let endx1 = endx - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          let startx2 = startx1 + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          let endx2 = endx1 - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          if (endx > (r + x)) endx = r + x;\r\n          if (startx1 < (lineData[lineData.length - 1][0])) startx1 = lineData[lineData.length - 1][0];\r\n          if (endx1 > (r + x)) endx1 = r + x;\r\n          if (startx2 < (lineData[lineData.length - 1][0])) startx2 = lineData[lineData.length - 1][0];\r\n          if (endx2 > (r + x)) endx2 = r + x;\r\n          lineData.push([startx, y1], [startx1, startyf1], [startx2, startyf], [midx, yz], [endx2, endyf], [endx1, endyf1], [endx, y])\r\n        }\r\n        lineData.push([x + r, y])\r\n        let curve_generator = d3.line()\r\n          .x((d) => d[0])\r\n          .y((d) => {\r\n            let h = Math.sqrt(Math.pow(r, 2) - Math.pow((d[0] - (x - r)), 2));\r\n            if ((y - d[1]) > (h + r * Math.sqrt(3) / 2))\r\n              return y - (h + r * Math.sqrt(3) / 2) + 2;\r\n            return d[1];\r\n          })\r\n          .curve(d3.curveBasis)\r\n        _this.drawTimeLine(svg, curve_generator(lineData), \"white\", 2, '0', 'sonLine ', 'sonLine ');\r\n\r\n\r\n        for (let p = 0; p < linePoint.length; p++) {\r\n          _this.drawCircle(svg, linePoint[p]['x'], linePoint[p]['y'], 5, \"red\", linePoint[p], 0, \"linePoint\", \"linePoint_\" + linePoint[p]['id']);\r\n        }\r\n\r\n        // \"1\": \"rgb(145, 204, 117)\",\r\n        //   \"2\": \"rgb(84, 112, 198)\",\r\n        //   \"3\": \"rgb(238, 102, 102)\",\r\n        let typeColor = {\r\n          \"1\": \"#ff9c9c\",\r\n          \"2\": \"#f4f4d0\",\r\n          \"3\": \"#6f8be0\",\r\n        };\r\n        let duration = tools.time2seconds(data['time'][0]) - tools.time2seconds(data['time'][1]);\r\n        let typeData = data['attribute']['expressions'];\r\n        let sonList = data['son'];\r\n        let typeArcScale_linear = d3.scaleLinear([0, duration], [0, Math.PI * 2]);\r\n\r\n        var typeStartR = 0//Math.PI/4;\r\n\r\n        var typeStepR = Math.PI / 1;\r\n\r\n        if (sonList.length > 0) {\r\n          for (let i in typeData) {\r\n            let color = typeColor[i];\r\n            let typeDurition = typeData[i];\r\n            let totalTypeSeconds = 0;\r\n            for (let d in typeDurition) {\r\n              totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n            let typeStepR = typeArcScale_linear(totalTypeSeconds)//Math.PI/2;\r\n\r\n            let endAnglet = typeStartR + 1 * typeStepR\r\n            var dataset = { startAngle: typeStartR, endAngle: endAnglet }; //\r\n            typeStartR = endAnglet;\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 10)\r\n              .outerRadius(r + 25);\r\n            var pathArc = arcPath(dataset);\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, color, color, 'type f' + data['id'] + \" t\" + i);\r\n          }\r\n          let sonTotal = 0;\r\n          let sonNum = 0\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n            sonTotal += sonDur;\r\n            sonNum += 1;\r\n          }\r\n          let skipArc = Math.PI / (sonNum + 2);\r\n          let timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI * 2 - skipArc * sonNum]);\r\n          let timeSonHeighLinear = d3.scaleLinear([0, sonTotal], [40, 40]);\r\n\r\n          let timeSonColor_linear = d3.scaleLinear().domain([0, sonTotal]).range([0, 1]);\r\n          let timeSonCompute_color = d3.interpolate(\"white\", circleColor);\r\n          var sonStartR = 0;//-Math.PI/2;\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n\r\n            let sonStepR = timeSonLinear(sonDur)//Math.PI/2;\r\n\r\n            let endAnglet = sonStartR + sonStepR;\r\n            var dataset = { startAngle: sonStartR, endAngle: endAnglet }; //\r\n            sonStartR = endAnglet;\r\n            let color = 'blue';\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 28)\r\n              .outerRadius(r + timeSonHeighLinear(sonDur));\r\n            var arcMidPath = d3.arc()\r\n              .innerRadius(0)\r\n              .outerRadius(r + 32);\r\n            var pathArc = arcPath(dataset);\r\n\r\n            endAnglet = sonStartR + skipArc;\r\n            var midDataset = { startAngle: sonStartR, endAngle: endAnglet }; //\r\n\r\n            let jiantouPath = d3.path();\r\n            jiantouPath.arc(x, y - r / 2, r + 32, sonStartR - Math.PI / 2, endAnglet - Math.PI / 2);\r\n\r\n            sonStartR += skipArc;\r\n            var pathMidArc = arcMidPath(midDataset);\r\n            let timeSonColor = compute_color(color_linear(sonData['attribute']['importance']));\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, timeSonColor, timeSonColor, 'son f' + data['id'] + \" s\" + sonList[s], '0');\r\n            if (s != sonList.length - 1) {\r\n              _this.drawTimeLine(svg, jiantouPath, \"rgb(200,200,200)\", 3, '9,5', 'midArc ', 'midArc ');\r\n            }\r\n          }\r\n\r\n        }\r\n\r\n\r\n      }\r\n      let txts = _this.nameinput.split(\" \")\r\n      _this.drawTxt(svg, x - r - 32, y + r + 50, r * 2 + 64, txts, \"grey\");\r\n    },\r\n    drawEntity(data) {\r\n      const _this = this;\r\n      let psvg = d3.select(\"#entG\");\r\n      let w = psvg.attr(\"width\");\r\n      let h = psvg.attr(\"height\");\r\n      psvg.remove();\r\n      let svg = d3.select(\"#editEnt\").append(\"g\").attr(\"id\", \"entG\").attr(\"width\", w).attr(\"height\", h);\r\n      let color_linear = _this.importanceColor_linear;\r\n      let compute_color = _this.importanceCompute_color;\r\n      let totalDurationValue = data['totalDuration'];\r\n      let rScale = _this.totalDurationScale_linear;\r\n      let r = rScale(totalDurationValue);\r\n      let oData = _this.data;\r\n      let x = svg.attr(\"width\") / 2;\r\n      let y = 120;\r\n      let importanceValue = data['attribute']['importance'];\r\n      let relevanceValue = data['attribute']['relevance'];\r\n      svg.selectAll().remove();\r\n\r\n      if (data['type'] == '1') {\r\n        let area = tools.calcTriangle(x, y, r);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n      }\r\n      else {\r\n\r\n        let cy = y;\r\n        let totalDuration = _this.totalDuration;\r\n        let timeLineScale_linear = d3.scaleLinear([0, totalDuration], [x - r * Math.sqrt(3) / 2, x + r * Math.sqrt(3) / 2])\r\n        let timeLineHighScale_linear = d3.scaleLinear([0, _this.maxDDuration], [0, r * (1 + Math.sqrt(3) / 2)])\r\n        let circleColor = compute_color(color_linear(importanceValue));\r\n        _this.drawCircle(svg, x, cy, r, circleColor, data, 1, \"entCircle\", \"entCircle_\" + data['id']);\r\n\r\n        r = r * Math.sqrt(3) / 2;\r\n        y += r / 2;\r\n        let path = d3.path();\r\n\r\n\r\n        path.moveTo(x - r, y);\r\n        let lineLi = [data];\r\n        let linePoint = [{ 'id': data['id'], 'time': data['time'], 'x': 0, 'y': 0 }];\r\n        let jgidL = [data['id']];\r\n        let similarityRelsli = [data[\"similarityRel\"]];\r\n        while(similarityRelsli.length>0){\r\n          let similarityRels = similarityRelsli[0];\r\n          similarityRelsli.splice(0,1);\r\n          let jg = 0;\r\n          for (let srel in similarityRels) {\r\n            let cdata = oData.find(function (d) { return d['id'] == similarityRels[srel] });\r\n            if(jgidL.indexOf(cdata['id'])==-1){\r\n              similarityRelsli.push(cdata[\"similarityRel\"])\r\n              jg=1;\r\n              lineLi.push(cdata)\r\n              jgidL.push(cdata['id'])\r\n              linePoint.push({ 'id': cdata['id'], 'time': cdata['time'], 'x': 0, 'y': 0 })\r\n            }\r\n          }\r\n          // if(jg==0){\r\n            // break;\r\n          // }\r\n        }\r\n        \r\n        const sortmt = (a, b) => {\r\n          return tools.time2seconds(a[0]) - tools.time2seconds(b[0]);\r\n        }\r\n        const sortlp = (a, b) => {\r\n          return tools.time2seconds(a['time'][0]) - tools.time2seconds(b['time'][0]);\r\n        }\r\n        console.log(lineLi);\r\n        lineLi = lineLi.sort(sortlp);\r\n        linePoint = linePoint.sort(sortlp);\r\n        let lineData = [[x - r * Math.sqrt(3)/2-4 , y]];\r\n        for (let t = 0; t < lineLi.length; t++) {\r\n          let startT = lineLi[t]['time'][0];\r\n          let duration =lineLi[t]['totalDuration']\r\n          // let endT = lineLi[t]['time'][1];\r\n          let startS = tools.time2seconds(startT);\r\n          let endS = startS +duration;\r\n          // let startx = timeLineScale_linear((startS - duration * 10));\r\n          // let endx = timeLineScale_linear((endS + duration * 10));\r\n          let limst = (x - r * Math.sqrt(3) / 2);\r\n          let limed = (x + r * Math.sqrt(3) / 2);\r\n          let startx = (limst<timeLineScale_linear((startS)))?(timeLineScale_linear((startS))):(limst);\r\n          let endx = (limed>timeLineScale_linear((endS)))?(timeLineScale_linear((endS))):(limed);\r\n          // let midx = timeLineScale_linear((endS + startS) / 2);\r\n          let midx = (startx+endx) / 2;\r\n          let ys = y;\r\n          let yz = y - timeLineHighScale_linear((duration));\r\n          linePoint[t]['x'] = midx;\r\n          linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n          // if (startx < (lineData[lineData.length - 1][0])) {\r\n            if (t > 0) {\r\n              lineData.splice(lineData.length - 1, 1);\r\n              midx+=t*5;\r\n              startx = midx-((midx-(lineData[lineData.length - 1][0] + midx) / 2))/2;\r\n              endx+=t*5;\r\n              ys = y+(y-lineData[lineData.length - 1][1])/3\r\n            }\r\n            console.log(ys)\r\n          // }\r\n          lineData.push([startx, ys],[midx, yz],[endx, y])}\r\n        lineData.push([x + r, y])\r\n        let curve_generator = d3.line()\r\n          .x((d) => d[0])\r\n          .y((d) => {\r\n            let h = Math.sqrt(Math.pow(r, 2) - Math.pow((d[0] - (x - r)), 2));\r\n            if ((y - d[1]) > (h + r * Math.sqrt(3) / 2))\r\n              return y - (h + r * Math.sqrt(3) / 2) + 2;\r\n            return d[1];\r\n          })\r\n          .curve(d3.curveBundle )\r\n          // .curve(d3.curveCatmullRom  )\r\n          // .curve(d3.curveBasis)\r\n        _this.drawTimeLine(svg, curve_generator(lineData), \"white\", 2, '0', 'sonLine ', 'sonLine ');\r\n\r\n\r\n        for (let p = 0; p < linePoint.length; p++) {\r\n          _this.drawCircle(svg, linePoint[p]['x'], linePoint[p]['y'], 5, \"red\", linePoint[p], 0, \"linePoint\", \"linePoint_\" + linePoint[p]['id']);\r\n        }\r\n\r\n        // \"1\": \"rgb(145, 204, 117)\",\r\n        //   \"2\": \"rgb(84, 112, 198)\",\r\n        //   \"3\": \"rgb(238, 102, 102)\",\r\n        let typeColor = {\r\n          \"1\": \"#ff9c9c\",\r\n          \"2\": \"#f4f4d0\",\r\n          \"3\": \"#6f8be0\",\r\n        };\r\n        let duration = tools.time2seconds(data['time'][0]) - tools.time2seconds(data['time'][1]);\r\n        let typeData = data['attribute']['expressions'];\r\n        let sonList = data['son'];\r\n        let sons = [sonList];\r\n        while (sons.length > 0) {\r\n          let curSonList = sons[0];\r\n          sons.splice(0, 1);\r\n          if (curSonList.length > 0) {\r\n            for (let s in curSonList) {\r\n              let sonData = oData.find(function (d) { return d['id'] == curSonList[s] });\r\n              let sonTypeData = sonData['attribute']['expressions'];\r\n\r\n              for (let t in sonTypeData) {\r\n                let typeDurition = sonTypeData[t];\r\n                for (let d in typeDurition) {\r\n                   typeData[t].push(typeDurition[d])\r\n                }\r\n              }\r\n              sons.push(sonData['son']);\r\n            }\r\n          }\r\n        }\r\n        var typeStartR = 0//Math.PI/4;\r\n\r\n        var typeStepR = Math.PI / 1;\r\n\r\n        if (sonList.length > 0) {\r\n          let typeTotalDur = 0;\r\n          for (let t in typeData) {\r\n            let typeDurition = typeData[t];\r\n            for (let d in typeDurition) {\r\n              typeTotalDur += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n          }\r\n          let typeArcScale_linear = d3.scaleLinear([0, typeTotalDur], [0, Math.PI * 2]);\r\n          for (let i in typeData) {\r\n            let color = typeColor[i];\r\n            let typeDurition = typeData[i];\r\n            let totalTypeSeconds = 0;\r\n            for (let d in typeDurition) {\r\n              totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n            if(totalTypeSeconds>0)\r\n            {let typeStepR = typeArcScale_linear(totalTypeSeconds)//Math.PI/2;\r\n\r\n            let endAnglet = typeStartR + 1 * typeStepR\r\n            var dataset = { startAngle: typeStartR, endAngle: endAnglet }; //\r\n            typeStartR = endAnglet;\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 10)\r\n              .outerRadius(r + 25);\r\n            var pathArc = arcPath(dataset);\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, color, color, 'type f' + data['id'] + \" t\" + i);}\r\n          }\r\n\r\n          let sonTotal = 0;\r\n          let sonNum = 0\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n            sonTotal += sonDur;\r\n            sonNum += 1;\r\n          }\r\n          let skipArc = Math.PI / (sonNum + 2);\r\n          let timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI * 2 - skipArc * sonNum]);\r\n          let timeSonHeighLinear = d3.scaleLinear([0, sonTotal], [40, 40]);\r\n\r\n          let timeSonColor_linear = d3.scaleLinear().domain([0, sonTotal]).range([0, 1]);\r\n          let timeSonCompute_color = d3.interpolate(\"white\", circleColor);\r\n          var sonStartR = 0;//-Math.PI/2;\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n\r\n            let sonStepR = timeSonLinear(sonDur)//Math.PI/2;\r\n\r\n            let endAnglet = sonStartR + sonStepR;\r\n            var dataset = { startAngle: sonStartR, endAngle: endAnglet }; //\r\n            sonStartR = endAnglet;\r\n            let color = 'blue';\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 28)\r\n              .outerRadius(r + timeSonHeighLinear(sonDur));\r\n            var arcMidPath = d3.arc()\r\n              .innerRadius(0)\r\n              .outerRadius(r + 32);\r\n            var pathArc = arcPath(dataset);\r\n\r\n            endAnglet = sonStartR + skipArc;\r\n            var midDataset = { startAngle: sonStartR, endAngle: endAnglet }; //\r\n\r\n            let jiantouPath = d3.path();\r\n            jiantouPath.arc(x, y - r / 2, r + 32, sonStartR - Math.PI / 2, endAnglet - Math.PI / 2);\r\n\r\n            sonStartR += skipArc;\r\n            var pathMidArc = arcMidPath(midDataset);\r\n            let timeSonColor = compute_color(color_linear(sonData['attribute']['importance']));\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, timeSonColor, timeSonColor, 'son f' + data['id'] + \" s\" + sonList[s], '0');\r\n            if (s != sonList.length - 1) {\r\n              _this.drawTimeLine(svg, jiantouPath, \"rgb(200,200,200)\", 3, '9,5', 'midArc ', 'midArc ');\r\n            }\r\n          }\r\n\r\n        }\r\n\r\n\r\n      }\r\n      let txts = data['name'].split(\" \")\r\n      let tx = x - r - 30;\r\n      let ty = y + r +60;\r\n      let tw = r*2;\r\n      tx = x;\r\n      if(data['son'].length==0){\r\n        tx = x//-r-10;\r\n        ty = y+r*2;\r\n      }\r\n      if(data['id']==\"3\"){\r\n        tx = x-10;\r\n        ty = y+r*2;\r\n      }\r\n      if(data['id']==\"4\"){\r\n        tx = x+10;\r\n        ty = y+r*2;\r\n      }\r\n      // if(data['type']=='1'){\r\n      //   tx = x-r/2;\r\n      //   ty = y+r*2;\r\n      // }\r\n\r\n      _this.drawTxt(svg, tx, ty,tw , txts, \"grey\",22, `text_${data['id']}`);\r\n      // let txts = _this.nameinput.split(\" \")\r\n      // _this.drawTxt(svg, x - r - 32, y + r + 50, r * 2 + 64, txts, \"grey\");\r\n    },\r\n    drawTxt(svg, x, y, width, txts, fill, fontsize = 12, idN) {\r\n      let tx = x;\r\n      let ty = y;\r\n      let preWidth = 0;\r\n      let preIdN = 0;\r\n      let pretext = ''\r\n      for (let t = 0; t < txts.length; t++) {\r\n        pretext +=\" \"+ txts[t];\r\n        let txt = svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"id\", `${idN}_${t}`)\r\n          .attr(\"fill\", fill)\r\n          .attr(\"font-size\", fontsize)\r\n          .style(\"text-anchor\", \"middle\")\r\n          .text(pretext)\r\n        let textWidth = document.getElementById(`${idN}_${t}`).getBBox().width;\r\n        if((textWidth>width)||(t==txts.length -1)){\r\n          pretext = '';\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n        else{\r\n          txt.remove()\r\n        }\r\n        preWidth += textWidth;\r\n      }\r\n    },\r\n    drawTxtOri1(svg, x, y, width, txts, fill,fontsize=12) {\r\n      let tx = x;\r\n      let ty = y;\r\n      for (let t = 0; t < txts.length; t++) {\r\n\r\n      let txt =   svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"fill\", fill)\r\n          .attr(\"font-size\",fontsize)\r\n          .style(\"text-anchor\", \"middle\")\r\n          .text(txts[t])\r\n        tx += txts[t].length * 14;\r\n        if (tx - x > width) {\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n      }\r\n    },\r\n    drawTxtOri(svg, x, y, width, txts, fill) {\r\n      let tx = x;\r\n      let ty = y;\r\n      for (let t = 0; t < txts.length; t++) {\r\n\r\n        svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"fill\", fill)\r\n          .text(txts[t])\r\n        tx += txts[t].length * 10;\r\n        if (tx - x > width) {\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n      }\r\n    },\r\n    drawTriangle(svg, color, points, stroke, opacity = 1) {\r\n      svg.append(\"polygon\")\r\n        .attr(\"points\", points)\r\n        .attr(\"fill\", color)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", \"15px\");\r\n    },\r\n    drawCircle(svg, x, y, r, fill, data, opacity, className = 'entCircle', idName) {\r\n      const _this = this;\r\n      const oData = _this.data\r\n      svg.append(\"circle\")\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"cx\", x)\r\n        .attr(\"cy\", y)\r\n        .attr(\"r\", r)\r\n        .attr(\"fill\", fill)\r\n        .on(\"mouseover\", function (d) {\r\n          d3.select(this).attr(\"r\", r * 1.1)\r\n          let classN = d3.select(this).attr(\"class\");\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 1).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1.1)\"\r\n              })\r\n\r\n            d3.selectAll(\".basicRel\")\r\n              .attr(\"class\", function (d) {\r\n                let classN = d3.select(this).attr(\"class\");\r\n                let classNList = classN.split(\" \");\r\n                let jg = 0;\r\n                for (let i = 0; i < classNList.length - 1; i++) {\r\n                  console.log('source' + data['id'], classNList[i])\r\n                  if ('source' + data['id'] == classNList[i]) { jg = 1; }\r\n                  if ('target' + data['id'] == classNList[i]) { jg = 1; }\r\n                }\r\n                if (jg == 1) {\r\n                  classN += \" activeS\";\r\n                }\r\n                return classN;\r\n              })\r\n          }\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(this).attr(\"r\", r)\r\n          let classN = d3.select(this).attr(\"class\");\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 0).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1)\"\r\n              })\r\n            d3.selectAll(\"path\")\r\n              .attr(\"class\", function (d) {\r\n                let thisSelect = d3.select(this)\r\n                let classN = thisSelect.attr(\"class\");\r\n                let classNList = classN.split(\" \")\r\n                if (classNList[classNList.length - 1] == \"activeS\") {\r\n                  classN = \"\";\r\n                  for (let i = 0; i < classNList.length - 1; i++) {\r\n                    classN += classNList[i] + \" \";\r\n                  }\r\n                }\r\n                return classN\r\n              })\r\n          }\r\n        })\r\n        .on(\"mousedown\", function (d) {\r\n          d3.select(this).attr(\"r\", r);\r\n          d3.selectAll(\".f\" + data['id'])\r\n            .attr(\"transform\", function (d) {\r\n              let transformd = d3.select(this).attr(\"transform\")\r\n              return transformd.split(\" \")[0] + \" scale(1)\"\r\n            })\r\n          let thisId = this.id.split(\"_\")[1];\r\n          let thisData = oData.find(function (a) { return a['id'] == thisId })\r\n          let thisTime = thisData['time'];\r\n          _this.click_Ent(thisTime);\r\n          // console.log(thisTime,thisId,thisData)\r\n        })\r\n      // .on(\"\")\r\n    },\r\n    drawTimeLine(svg, path, stroke, width, stroke_dasharray = \"0\", idName, className) {\r\n      svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .attr('fill', 'none')\r\n        .on('mouseover', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let idN = thisSelect.attr(\"id\");\r\n          if (classN.split(\" \")[0] == \"basicRel\") {\r\n            d3.select(this).attr(\"class\", classN + \" activeS\");\r\n          }\r\n        })\r\n        .on('mouseleave', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let classNList = classN.split(\" \")\r\n          if (classNList[classNList.length - 1] == \"activeS\") {\r\n            classN = \"\";\r\n            for (let i = 0; i < classNList.length - 1; i++) {\r\n              classN += classNList[i] + \" \";\r\n            }\r\n            d3.select(this).attr(\"class\", classN);\r\n          }\r\n        })\r\n    },\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3) {\r\n      svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n    },\r\n    updata() {\r\n      \r\n    const _this = this;\r\n      let data = _this.data;\r\n      let maxDImportance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let minDImportance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let maxDRelevance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let minDRelevance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let maxDDuration = Math.max.apply(Math, data.map(function (d) { return tools.time2seconds(d['time'][1]) - tools.time2seconds(d['time'][0]); }))\r\n      let maxTotalDuration = Math.max.apply(Math, data.map(function (d) { return d['totalDuration']; }))\r\n\r\n      _this.minDImportance = minDImportance;\r\n      _this.maxDImportance = maxDImportance;\r\n      _this.minDRelevance = minDRelevance;\r\n      _this.maxDRelevance = maxDRelevance;\r\n      _this.maxDDuration = maxDDuration;\r\n      _this.maxTotalDuration = maxTotalDuration;\r\n\r\n      let currentMaxColor = _this.importanceMaxColor;\r\n      let currentMinColor = _this.importanceMinColor;\r\n      _this.importanceColor_linear = d3.scaleLinear().domain([minDImportance, maxDImportance]).range([0, 1]);\r\n      _this.importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n      _this.relevanceScale_linear = d3.scaleLinear([minDRelevance, maxDRelevance], [20, 50])\r\n      _this.totalDurationScale_linear = d3.scaleLinear().domain([0, maxTotalDuration]).range([20, 60]);\r\n\r\n\r\n\r\n\r\n      _this.$bus.$emit(\"graphData\", _this.data);\r\n      _this.$bus.$emit(\"relData\", _this.relData);\r\n      // _this.drawtopicLine();\r\n      // _this.drawrootTree();\r\n      _this.draweditData();\r\n    },\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n  },\r\n  created() {\r\n    const _this = this;\r\n    this.$nextTick(() => {\r\n      _this.getTreeData();\r\n      _this.updata();\r\n\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this\r\n    _this.tableData.find(function (d) { return d['key'] == 'name' })['value'] = 'Computer Network';\r\n    this.$bus.$on('selectEnt', (val) => {\r\n     console.log(val);\r\n     _this.curEntId = val;\r\n    });\r\n  },\r\n  // beforeDestroy() {\r\n  //   clearInterval(this.moveTimer);\r\n  // },\r\n} \r\n</script>\r\n\r\n<style>\r\n@import './index.css';\r\n</style>\r\n"]}]}