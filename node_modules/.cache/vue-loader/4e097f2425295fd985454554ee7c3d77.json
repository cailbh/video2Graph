{"remainingRequest":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\EditPanel\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\EditPanel\\index.vue","mtime":1705377392669},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\babel-loader\\lib\\index.js","mtime":1688115046651},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js","mtime":1688115046800}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBkb210b2ltYWdlIGZyb20gJ2RvbS10by1pbWFnZSc7DQppbXBvcnQgVGVzdEpzb24gZnJvbSAiQC9hc3NldHMvanNvbi9jYXNlMV9maW4uanNvbiI7DQppbXBvcnQgVGVzdFJlbEpzb24gZnJvbSAiQC9hc3NldHMvanNvbi9jYXNlMV9maW5fcmVsLmpzb24iOw0KaW1wb3J0IHRvb2xzIGZyb20gIkAvdXRpbHMvdG9vbHMuanMiOw0KDQpleHBvcnQgZGVmYXVsdCB7DQogIHByb3BzOiBbXSwNCiAgZGF0YSgpIHsNCiAgICByZXR1cm4gew0KICAgICAgdHlwZVJhZGlvOiAiY29uY2VwdCIsDQogICAgICBkYXRhOiBUZXN0SnNvbiwgIC8vdGVzdCBpbiB0aGUgb25saW5lIGRlbW8NCiAgICAgIHJlbERhdGE6IFRlc3RSZWxKc29uLCAgLy90ZXN0IGluIHRoZSBvbmxpbmUgZGVtbw0KICAgICAgdHJlZURhdGE6IG51bGwsDQogICAgICB0b29sc1N0YXRlOiAnJywNCiAgICAgIGNvbmZpcm1Vcmw6IHJlcXVpcmUoIkAvYXNzZXRzL2ltZy9jb25maXJtLnN2ZyIpLA0KICAgICAgY2FuY2VsVXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvY2FuY2VsLnN2ZyIpLA0KICAgICAgdG9vbHNCdXRzVXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvdG9vbHNCdXRzLnBuZyIpLA0KICAgICAgYWRkTm9kZVNvblVybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL2FkZE5vZGUxLnBuZyIpLA0KICAgICAgYWRkTm9kZVBlclVybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL2FkZE5vZGUyLnBuZyIpLA0KICAgICAgYWRkTGlua0Jhc2ljVXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvYWRkTGluay5wbmciKSwNCiAgICAgIC8vIG5hbWVpbnB1dDogIlJhbmRvbSBWYXJpYWJsZXMiLA0KICAgICAgbmFtZWlucHV0OiAiRnVuZGFtZW50YWwgR3JhcGhzIiwNCiAgICAgIC8vIG5hbWVpbnB1dDogIlRyZWVzIiwNCiAgICAgIGxlY3R1cmVTdHlsZVZhbHVlOiBbMCwgODBdLA0KICAgICAgaW1wb3J0YW5jZVNjb3JlVmFsdWU6IDgwLA0KICAgICAgdGFibGVEYXRhOiBbew0KICAgICAgICBrZXk6ICdOYW1lJywNCiAgICAgICAgdmFsdWU6ICcnLA0KICAgICAgfSx7DQogICAgICAgIGtleTogJ1R5cGUnLA0KICAgICAgICB2YWx1ZTogJycsDQogICAgICB9LCB7DQogICAgICAgIGtleTogJ0NvdXJzZSBzdHlsZScsDQogICAgICAgIHZhbHVlOiAnJywNCiAgICAgIH0sIHsNCiAgICAgICAga2V5OiAnSW1wb3J0YW5jZSBzY29yZScsDQogICAgICAgIHZhbHVlOiAnJywNCiAgICAgIH1dLA0KICAgICAgY3VyRW50SWQ6ICIiLA0KICAgICAgaW5zZXJ0RW50SWQ6ICIiLA0KICAgICAgaW5zZXJ0U291cmNlRW50SWQ6ICItMSIsDQogICAgICBpbnNlcnRUYXJnZXRFbnRJZDogIi0xIiwNCiAgICAgIHNvbkxpc3Q6IFtdLA0KICAgICAgbWluREltcG9ydGFuY2U6IDAsDQogICAgICBtYXhESW1wb3J0YW5jZTogMCwNCiAgICAgIG1pbkRSZWxldmFuY2U6IDAsDQogICAgICBtYXhEUmVsZXZhbmNlOiAwLA0KICAgICAgbWF4RER1cmF0aW9uOiAwLA0KICAgICAgaW1wb3J0YW5jZUxpbmVhcjonJywNCiAgICAgIG1heFRvdGFsRHVyYXRpb246IDAsDQogICAgICBpbXBvcnRhbmNlTWluQ29sb3I6ICJyZ2IoMjAzLCAyMzAsIDIwOSkiLA0KICAgICAgaW1wb3J0YW5jZU1heENvbG9yOiAicmdiKDIyLCAxNDQsIDIwNykiLA0KICAgICAgdG90YWxEdXJhdGlvbjogMTAwMCwNCiAgICAgIGltcG9ydGFuY2VDb2xvcl9saW5lYXI6IG51bGwsDQogICAgICBpbXBvcnRhbmNlQ29tcHV0ZV9jb2xvcjogbnVsbCwNCiAgICAgIHJlbGV2YW5jZVNjYWxlX2xpbmVhcjogbnVsbCwNCiAgICAgIHRvdGFsRHVyYXRpb25TY2FsZV9saW5lYXI6IG51bGwsDQogICAgICBEaXZpc2lvbkRhdGFMaXN0OiBbXSwNCiAgICAgIHJvb3REaXZpc2lvbkRhdGFMaXN0OiBbXSwNCiAgICAgIGVudERpdmlzaW9uRGF0YUxpc3Q6IFtdLA0KICAgICAgY29sb3JNYXA6IHt9LA0KICAgICAgcm9vdENvbG9yTWFwOnt9LA0KICAgICAgdmlkZW9EdXJhdGlvbjogNjY4LA0KICAgICAgc2VsZWN0UmVjdElkOiAiIiwNCiAgICAgIHNlbGVjdFJlY3RDbGFzczogIiIsDQogICAgICB0b3BpY0xpbmVXaWR0aDogMTAwMCwNCiAgICAgIHRvcGljTGluZUhlaWdodDogMTAwMCwNCiAgICAgIG1vdmVMaW5lV2lkdGg6IDEwMDAsDQogICAgICBlbnRMaW5lV2lkdGg6IDEwMDAsDQogICAgICB0b3RhbFNvbkR1cmF0aW9uOiAwLA0KICAgICAgdHJlZUdUcmFuc2Zvcm1LOjEsDQogICAgICB0cmVlR1RyYW5zZm9ybVg6MTAsDQogICAgICB0cmVlR1RyYW5zZm9ybVk6MTAwLA0KICAgICAgbWFyZ2luOiB7IHRvcDogNSwgcmlnaHQ6IDUsIGJvdHRvbTogNSwgbGVmdDogNSB9LA0KICAgICAgLy8gbWNvbG9yOiBbDQogICAgICAvLyAgICJyZ2IoMjU1LDYwLDYwKSIsDQogICAgICAvLyAgICJyZ2IoMTU1LDIwLDEwMCkiLA0KICAgICAgLy8gICAicmdiKDI1NSw4MywyNTUpIiwNCiAgICAgIC8vICAgInJnYigyMDAsMTAwLDUwKSIsDQogICAgICAvLyAgICJyZ2IoMjM1LDEzNSwxNjIpIiwNCiAgICAgIC8vICAgInJnYigyMDAsMjAwLDEwMikiLA0KICAgICAgLy8gICAicmdiKDI1NSwxNzgsMTAxKSIsDQogICAgICAvLyAgICJyZ2IoNjMsMTUxLDEzNCkiLA0KICAgICAgLy8gICAicmdiKDgzLDE1NSwyNTUpIiwNCiAgICAgIC8vICAgInJnYig1MCwyMDAsMTIwKSIsDQogICAgICAvLyAgICJyZ2IoMiw1MCwyMDApIiwNCiAgICAgIC8vICAgInJnYigwLDEyMiwyNDQpIiwNCiAgICAgIC8vICAgInJnYigxNTAsMTIyLDI0NCkiLA0KICAgICAgLy8gICAicmdiKDE2OCwxNjgsMjU1KSIsDQogICAgICAvLyAgICJyZ2IoMjAwLDIwMCwyMDApIiwNCiAgICAgIC8vIF0sDQogICAgICBtY29sb3I6IFsNCiAgICAgICAgInJnYig5MSwgMTA3LCAyNTUpIiwNCiAgICAgICAgInJnYig2LCAyMTQsIDE2MCkiLA0KICAgICAgICAicmdiKDI1NSwgMTIwLCA5MCkiLA0KICAgICAgICAicmdiKDEyNSwgOTgsIDIxMSkiLA0KICAgICAgICAicmdiKDI1NSwgMTEzLCAyMTIpIiwNCiAgICAgICAgInJnYigxMTIsIDIxNCwgMjU1KSIsDQogICAgICAgICJyZ2IoMjU1LCAxNTksIDI4KSIsDQogICAgICAgICJyZ2IoMjU1LCA3NywgMTA5KSIsDQogICAgICBdLA0KICAgICAgbUxpZ2h0Y29sb3I6IFsNCiAgICAgICAgIiNmZjljOWMiLA0KICAgICAgICAiI2NjODhiMCIsDQogICAgICAgICIjZmZhOGZmIiwNCiAgICAgICAgIiNlM2IwOTciLA0KICAgICAgICAiI2Y0YzNkMCIsDQogICAgICAgICIjZjRmNGQwIiwNCiAgICAgICAgIiNmZmQ4YjEiLA0KICAgICAgICAiIzllY2FjMiIsDQogICAgICAgICIjYThjY2ZmIiwNCiAgICAgICAgIiM5N2UzYmEiLA0KICAgICAgICAiIzZmOGJlMCIsDQogICAgICAgICJyZ2IoMCwxMjIsMjQ0KSIsDQogICAgICAgICIjYjZhMmY3IiwNCiAgICAgICAgInJnYigxNjgsMTY4LDI1NSkiLA0KICAgICAgICAicmdiKDIwMCwyMDAsMjAwKSIsDQogICAgICBdLA0KICAgIH07DQogIH0sDQogIHdhdGNoOiB7DQogICAgdHlwZVJhZGlvKHZhbCkgew0KICAgIH0sDQogICAgbGVjdHVyZVN0eWxlVmFsdWUodmFsKXsNCiAgICAgIGxldCBtaWQgPSAodmFsWzBdK3ZhbFsxXSkvMjsNCiAgICAgIGQzLnNlbGVjdCgiI2VkaXREYXRhIC5lbC1zbGlkZXJfX3J1bndheSIpDQogICAgICAuYXR0cigic3R5bGUiLCJiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICNmZjljOWMgIittaWQrIiUsIzZmOGJlMCAiK21pZCsiJSkgIWltcG9ydGFudCIpDQogICAgfSwNCiAgICB0eXBlKHZhbCkgew0KICAgIH0sDQogICAgLy8gc2VsZWN0RW50KHZhbCl7DQogICAgLy8gICBjb25zb2xlLmxvZyh2YWwpOw0KICAgIC8vIH0sDQogICAgY3VyRW50SWQoY3VyRW50SWQpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBkYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIA0KICAgICAgbGV0IGN1ckVudCA9IGRhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBjdXJFbnRJZDsgfSk7DQogICAgICBpZiAoY3VyRW50Wyd0eXBlJ10gPT0gJzEnKSB7DQogICAgICAgIF90aGlzLnR5cGVSYWRpbyA9ICJ0ZXN0IjsNCiAgICAgIH0NCiAgICAgIGVsc2UgaWYoY3VyRW50Wyd0eXBlJ10gPT0gJzAnKSB7DQogICAgICAgIF90aGlzLnR5cGVSYWRpbyA9ICJjb25jZXB0IjsNCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KICAgICAgICBfdGhpcy50eXBlUmFkaW8gPSAiZXhhbXBsZSI7DQogICAgICB9DQogICAgICBfdGhpcy5uYW1laW5wdXQgPSBjdXJFbnRbJ25hbWUnXTsNCiAgICAgIGxldCBkdXJhdGlvbiA9IDAvL3Rvb2xzLnRpbWUyc2Vjb25kcyhjdXJFbnRbJ3RpbWUnXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHMoY3VyRW50Wyd0aW1lJ11bMF0pOw0KICAgICAgDQogICAgICBsZXQgdHlwZURhdGEgPSBjdXJFbnRbImF0dHJpYnV0ZSJdWyJleHByZXNzaW9ucyJdOw0KICAgICAgbGV0IHR5cGVEdXIgPSAwOw0KICAgICAgbGV0IHN0eWxlVmFsdWUgPSBbXTsNCiAgICAgIGZvciAobGV0IGkgaW4gdHlwZURhdGEpIHsNCiAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHR5cGVEYXRhW2ldOw0KICAgICAgICBsZXQgdG90YWxUeXBlU2Vjb25kcyA9IDA7DQogICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgdG90YWxUeXBlU2Vjb25kcyArPSAodG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzBdKSkNCiAgICAgICAgfQ0KICAgICAgICBkdXJhdGlvbis9dG90YWxUeXBlU2Vjb25kcw0KICAgICAgfQ0KICAgICAgbGV0IHR5cGVEdXJTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgZHVyYXRpb25dLCBbMCwgMTAwXSk7DQogICAgICBmb3IgKGxldCBpIGluIHR5cGVEYXRhKSB7DQogICAgICAgIC8vIGxldCBjb2xvciA9IHR5cGVDb2xvcltpXTsNCiAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHR5cGVEYXRhW2ldOw0KICAgICAgICBsZXQgdG90YWxUeXBlU2Vjb25kcyA9IDA7DQogICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgdG90YWxUeXBlU2Vjb25kcyArPSAodG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzBdKSkNCiAgICAgICAgfQ0KICAgICAgICB0eXBlRHVyICs9IHRvdGFsVHlwZVNlY29uZHM7DQogICAgICAgIHN0eWxlVmFsdWUucHVzaCh0eXBlRHVyU2NhbGVfbGluZWFyKHR5cGVEdXIpKQ0KICAgICAgfQ0KICAgICAgLy8gY29uc29sZS5sb2cNCiAgICAgIGxldCBpbXBvcnRhbmNlQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWyBfdGhpcy5taW5ESW1wb3J0YW5jZSwgX3RoaXMubWF4REltcG9ydGFuY2VdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgX3RoaXMuaW1wb3J0YW5jZVNjb3JlVmFsdWUgPSBpbXBvcnRhbmNlQ29sb3JfbGluZWFyKGN1ckVudFsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXSkqMTAwDQogICAgICBfdGhpcy5sZWN0dXJlU3R5bGVWYWx1ZSA9IHN0eWxlVmFsdWU7DQogICAgICAvLyBfdGhpcy5pbXBvcnRhbmNlU2NvcmVWYWx1ZSA9IDA7DQogICAgICBfdGhpcy5kcmF3RW50aXR5KGN1ckVudCk7DQogICAgICBfdGhpcy5kcmF3U29uTGluZShjdXJFbnQpOw0KICAgIH0NCiAgfSwNCiAgbWV0aG9kczogew0KICAgIHNlbGVjdFR5cGUodikgew0KICAgICAgLy8gY29uc29sZS5sb2codikNCiAgICB9LA0KICAgIGNhbmNlbENsaygpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBkYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCBjdXJFbnRJZCA9IF90aGlzLmN1ckVudElkOw0KICAgICAgbGV0IGN1ckVudCA9IGRhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBjdXJFbnRJZDsgfSk7DQogICAgICBfdGhpcy5kcmF3RW50aXR5KGN1ckVudCk7DQogICAgICBfdGhpcy5kcmF3U29uTGluZShjdXJFbnQpOw0KICAgICAgX3RoaXMuZHJhd3Jvb3RUcmVlKCk7DQoNCiAgICB9LA0KICAgIGNvbmZpcm1DbGsoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZGF0YSA9IF90aGlzLmRhdGE7DQogICAgICBsZXQgY3VyRW50SWQgPSBfdGhpcy5jdXJFbnRJZDsNCiAgICAgIGxldCBjdXJFbnQgPSBkYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY3VyRW50SWQ7IH0pOw0KICAgICAgaWYgKF90aGlzLnR5cGVSYWRpbyA9PSAiaGlkZGVuIFN0YXRlIikgew0KICAgICAgICBjdXJFbnRbJ3R5cGUnXSA9ICcxJw0KICAgICAgfQ0KICAgICAgZWxzZSB7DQogICAgICAgIGN1ckVudFsndHlwZSddID0gJzAnOw0KICAgICAgfQ0KICAgICAgY3VyRW50WyduYW1lJ10gPSBfdGhpcy5uYW1laW5wdXQ7DQoNCiAgICAgIGxldCBzdHlsZVZhbHVlID0gX3RoaXMubGVjdHVyZVN0eWxlVmFsdWU7DQogICAgICBsZXQgc3RhcnRTZWNvbmRzID0gdG9vbHMudGltZTJzZWNvbmRzKGN1ckVudFsndGltZSddWzBdKTsNCiAgICAgIGxldCBlbmRTZWNvbmRzID0gdG9vbHMudGltZTJzZWNvbmRzKGN1ckVudFsndGltZSddWzFdKTsNCiAgICAgIGxldCB0b3RhbFNlY29uZHMgPSBlbmRTZWNvbmRzIC0gc3RhcnRTZWNvbmRzOw0KICAgICAgbGV0IHR5cGVEdXJSZVNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCAxMDBdLCBbc3RhcnRTZWNvbmRzLCBlbmRTZWNvbmRzXSk7DQogICAgICBsZXQgdHlwZURhdGEgPSB7ICIxIjogW10sICIyIjogW10sICIzIjogW10gfTsvLzsNCiAgICAgIGxldCB0MSA9IHRvb2xzLnNlY29uZHMydGltZSh0eXBlRHVyUmVTY2FsZV9saW5lYXIoc3R5bGVWYWx1ZVswXSkpOw0KICAgICAgbGV0IHQyID0gdG9vbHMuc2Vjb25kczJ0aW1lKHR5cGVEdXJSZVNjYWxlX2xpbmVhcihzdHlsZVZhbHVlWzFdKSk7DQogICAgICB0eXBlRGF0YVsnMSddLnB1c2goW2N1ckVudFsndGltZSddWzBdLCB0MV0pOw0KICAgICAgdHlwZURhdGFbJzInXS5wdXNoKFt0MSwgdDJdKTsNCiAgICAgIHR5cGVEYXRhWyczJ10ucHVzaChbdDIsIGN1ckVudFsndGltZSddWzFdXSk7DQogICAgICBjdXJFbnRbImF0dHJpYnV0ZSJdWyJleHByZXNzaW9ucyJdID0gdHlwZURhdGE7DQoNCiAgICAgIGxldCBlbnRSZWN0cyA9IGQzLnNlbGVjdEFsbCgiLmVkaXRFbnQiKS5ub2RlcygpOw0KICAgICAgY29uc29sZS5sb2coZW50UmVjdHMpDQogICAgICBsZXQgdG90YWxTb25EdXJhdGlvbiA9IF90aGlzLnRvdGFsU29uRHVyYXRpb247DQogICAgICBsZXQgd2lkID0gX3RoaXMuZW50TGluZVdpZHRoOw0KICAgICAgbGV0IGN4UmVMaW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgd2lkXSwgWzAsIHRvdGFsU29uRHVyYXRpb25dKTsNCiAgICAgIGxldCBwcmVUaW1lID0gJyc7DQogICAgICBsZXQgdHlwZVRvdGFsRGF0YSA9IHsgIjEiOiBbXSwgIjIiOiBbXSwgIjMiOiBbXSB9Oy8vOw0KICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBlbnRSZWN0cy5sZW5ndGg7IG4rKykgew0KICAgICAgICBsZXQgY3VyUmVjdCA9IGVudFJlY3RzW25dOw0KICAgICAgICBsZXQgcmVjdElkID0gY3VyUmVjdC5pZC5zcGxpdCgiXyIpWzFdOw0KICAgICAgICBsZXQgcmVjdERhdGEgPSBkYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gcmVjdElkOyB9KTsNCiAgICAgICAgbGV0IHBlckR1ciA9IHRvb2xzLnRpbWUyc2Vjb25kcyhyZWN0RGF0YVsndGltZSddWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyhyZWN0RGF0YVsndGltZSddWzBdKTsNCiAgICAgICAgaWYgKG4gPT0gMCkgew0KICAgICAgICAgIHByZVRpbWUgPSByZWN0RGF0YVsndGltZSddWzBdOw0KICAgICAgICB9DQogICAgICAgIGxldCBwcmVTZWNvbmQgPSB0b29scy50aW1lMnNlY29uZHMocHJlVGltZSk7DQogICAgICAgIGxldCB4ID0gY3VyUmVjdC54LmJhc2VWYWwudmFsdWU7DQogICAgICAgIGxldCB3ID0gY3VyUmVjdC53aWR0aC5iYXNlVmFsLnZhbHVlOw0KICAgICAgICBsZXQgZHVyU2Vjb25kID0gY3hSZUxpbmVhcih3KTsNCiAgICAgICAgbGV0IGVuZFRpbWUgPSB0b29scy5zZWNvbmRzMnRpbWUocHJlU2Vjb25kICsgZHVyU2Vjb25kKTsNCiAgICAgICAgcmVjdERhdGFbJ3RpbWUnXSA9IFtwcmVUaW1lLCBlbmRUaW1lXTsNCiAgICAgICAgcmVjdERhdGFbJ3RvdGFsRHVyYXRpb24nXSArPSBkdXJTZWNvbmQgLSBwZXJEdXI7DQogICAgICAgIHByZVRpbWUgPSBlbmRUaW1lOw0KICAgICAgICBmb3IgKGxldCB0IGluIHR5cGVUb3RhbERhdGEpIHsNCiAgICAgICAgICB0eXBlVG90YWxEYXRhW3RdID0gWy4uLnR5cGVUb3RhbERhdGFbdF0sIC4uLnJlY3REYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXVt0XV0NCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgY29uc29sZS5sb2codHlwZVRvdGFsRGF0YSkNCiAgICAgIF90aGlzLmRhdGEgPSBkYXRhOw0KICAgICAgLy8gY29uc29sZS5sb2coZW50UmVjdHMsZW50UmVjdHNbMF0pDQoNCiAgICAgIF90aGlzLmRyYXdFbnRpdHkoY3VyRW50KTsNCiAgICAgIF90aGlzLmRyYXdTb25MaW5lKGN1ckVudCk7DQogICAgICBfdGhpcy5kcmF3cm9vdFRyZWUoKTsNCiAgICAgIF90aGlzLiRidXMuJGVtaXQoImdyYXBoRGF0YSIsIGRhdGEpOw0KICAgIH0sDQogICAgY2xpY2tfbm9kZSgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBub2RlSWQgPSBfdGhpcy5jdXJFbnRJZDsNCiAgICAgIGxldCBhZGREYXRhSWQgPSBfdGhpcy5pbnNlcnRFbnRJZDsvL3BhcnNlSW50KG5vZGVJZCkrMSsnJzsNCiAgICAgIGxldCBvcmlEYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCBzdGF0ZSA9IF90aGlzLnRvb2xzU3RhdGU7DQogICAgICBsZXQgcmV0dXJuRGF0YSA9IFtdOw0KICAgICAgbGV0IHJldHVyblJlbERhdGEgPSB7fTsNCiAgICAgIGxldCByZWxEYXRhID0gX3RoaXMucmVsRGF0YTsNCg0KICAgICAgaWYgKHN0YXRlID09ICdhZGROb2RlU29uJykgew0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaURhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICBsZXQgY0RhdGEgPSBvcmlEYXRhW2ldOw0KICAgICAgICAgIGxldCBjRGF0YUlkID0gY0RhdGFbJ2lkJ10NCiAgICAgICAgICANCiAgICAgICAgICBsZXQgc29ucyA9IGNEYXRhWydzb24nXTsNCiAgICAgICAgICBsZXQgc29uc05ldyA9IFtdOw0KICAgICAgICAgIGZvcihsZXQgcz0wO3M8c29ucy5sZW5ndGg7cysrKXsNCiAgICAgICAgICAgIGxldCBzcyA9IHNvbnNbc10NCiAgICAgICAgICAgICAgaWYocGFyc2VJbnQoc3MpPj1wYXJzZUludChhZGREYXRhSWQpKSBzcyA9IHBhcnNlSW50KHNzKSsxDQogICAgICAgICAgICAgIHNvbnNOZXcucHVzaChzcysnJykNCiAgICAgICAgICB9DQogICAgICAgICAgY0RhdGFbJ3NvbiddID0gc29uc05ldzsNCg0KICAgICAgICAgIGlmIChwYXJzZUludChjRGF0YUlkKSA9PSBwYXJzZUludChhZGREYXRhSWQpKSB7DQogICAgICAgICAgICBsZXQgcGVyRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShjRGF0YSk7DQogICAgICAgICAgICBsZXQgYWRkRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShwZXJEYXRhKTsNCiAgICAgICAgICAgIGFkZERhdGFbJ2lkJ10gPSBhZGREYXRhSWQ7DQogICAgICAgICAgICBwZXJEYXRhWydpZCddID0gKHBhcnNlSW50KGFkZERhdGFJZCkgKyAxKSsnJzsNCiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFkZERhdGEscGVyRGF0YSkNCiAgICAgICAgICAgIGxldCBzdGFydFQgPSBjRGF0YVsndGltZSddWzBdOw0KICAgICAgICAgICAgbGV0IGVuZFQgPSBjRGF0YVsndGltZSddWzFdOw0KICAgICAgICAgICAgbGV0IG1pZFQgPSB0b29scy5zZWNvbmRzMnRpbWUoKHRvb2xzLnRpbWUyc2Vjb25kcyhlbmRUKSArIHRvb2xzLnRpbWUyc2Vjb25kcyhzdGFydFQpKSAvIDIpOw0KICAgICAgICAgICAgYWRkRGF0YVsndGltZSddID0gW3N0YXJ0VCwgbWlkVF07DQogICAgICAgICAgICBwZXJEYXRhWyd0aW1lJ10gPSBbbWlkVCwgZW5kVF07DQogICAgICAgICAgICBhZGREYXRhWydzb24nXSA9IFtdOw0KICAgICAgICAgICAgYWRkRGF0YVsndG90YWxEdXJhdGlvbiddID0gKHRvb2xzLnRpbWUyc2Vjb25kcyhtaWRUKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyhzdGFydFQpKTsNCiAgICAgICAgICAgIHBlckRhdGFbJ3RvdGFsRHVyYXRpb24nXSAtPSBhZGREYXRhWyd0b3RhbER1cmF0aW9uJ107DQogICAgICAgICAgICBsZXQgdHlwZVRpbWVzID0gcGVyRGF0YVsnYXR0cmlidXRlJ11bJ2V4cHJlc3Npb25zJ107DQogICAgICAgICAgICBsZXQgdHlwZVByZURhdGEgPSB7ICIxIjogW10sICIyIjogW10sICIzIjogW10gfTsNCiAgICAgICAgICAgIGxldCB0eXBlQWRkRGF0YSA9IHsgIjEiOiBbXSwgIjIiOiBbXSwgIjMiOiBbXSB9Ow0KICAgICAgICAgICAgZm9yIChsZXQgdCBpbiB0eXBlVGltZXMpIHsNCiAgICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0eXBlVGltZXNbdF0ubGVuZ3RoOyBhKyspIHsNCiAgICAgICAgICAgICAgICBsZXQgc3QgPSB0eXBlVGltZXNbdF1bYV1bMF07DQogICAgICAgICAgICAgICAgbGV0IGV0ID0gdHlwZVRpbWVzW3RdW2FdWzFdOw0KICAgICAgICAgICAgICAgIGlmICh0b29scy50aW1lMnNlY29uZHMoZXQpIDw9IHRvb2xzLnRpbWUyc2Vjb25kcyhtaWRUKSkgeyB0eXBlQWRkRGF0YVt0XS5wdXNoKFtzdCwgZXRdKSB9DQogICAgICAgICAgICAgICAgZWxzZSBpZiAodG9vbHMudGltZTJzZWNvbmRzKHN0KSA+PSB0b29scy50aW1lMnNlY29uZHMobWlkVCkpIHsgdHlwZVByZURhdGFbdF0ucHVzaChbc3QsIGV0XSkgfQ0KICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0b29scy50aW1lMnNlY29uZHMoc3QpIDwgdG9vbHMudGltZTJzZWNvbmRzKG1pZFQpKSAmJiAodG9vbHMudGltZTJzZWNvbmRzKGV0KSA+IHRvb2xzLnRpbWUyc2Vjb25kcyhtaWRUKSkpIHsNCiAgICAgICAgICAgICAgICAgIHR5cGVBZGREYXRhW3RdLnB1c2goW3N0LCBtaWRUXSk7DQogICAgICAgICAgICAgICAgICB0eXBlUHJlRGF0YVt0XS5wdXNoKFttaWRULCBldF0pOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcGVyRGF0YVsnYXR0cmlidXRlJ11bJ2V4cHJlc3Npb25zJ10gPSB0eXBlUHJlRGF0YTsNCiAgICAgICAgICAgIGFkZERhdGFbJ2F0dHJpYnV0ZSddWydleHByZXNzaW9ucyddID0gdHlwZUFkZERhdGE7DQogICAgICAgICAgICByZXR1cm5EYXRhLnB1c2goYWRkRGF0YSk7DQogICAgICAgICAgICByZXR1cm5EYXRhLnB1c2gocGVyRGF0YSk7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKHBhcnNlSW50KGNEYXRhWydpZCddKSA8IHBhcnNlSW50KGFkZERhdGFJZCkpIHsNCiAgICAgICAgICAgIHJldHVybkRhdGEucHVzaCh0b29scy5kZWVwQ2xvbmUoY0RhdGEpKTsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAocGFyc2VJbnQoY0RhdGFbJ2lkJ10pID4gcGFyc2VJbnQoYWRkRGF0YUlkKSl7DQogICAgICAgICAgICBsZXQgcGVyRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShjRGF0YSk7DQogICAgICAgICAgICBwZXJEYXRhWydpZCddID0gKHBhcnNlSW50KGNEYXRhSWQpICsgMSkgKyAnJzsNCiAgICAgICAgICAgIHJldHVybkRhdGEucHVzaChwZXJEYXRhKTsNCiAgICAgICAgICB9DQoNCiAgICAgICAgfQ0KICAgICAgDQogICAgICBsZXQgYnNOZXcgPSBbXTsNCiAgICAgIGxldCBiYXNpY1JlbCA9IHJlbERhdGFbJ2Jhc2ljUmVsJ107DQogICAgICBmb3IgKGxldCByID0gMDsgciA8IGJhc2ljUmVsLmxlbmd0aDsgcisrKSB7DQogICAgICAgIGxldCBzb3VyY2VJZCA9IGJhc2ljUmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyXVsxXTsNCiAgICAgICAgaWYocGFyc2VJbnQoc291cmNlSWQpPj1wYXJzZUludChhZGREYXRhSWQpKSBzb3VyY2VJZCA9IHBhcnNlSW50KHNvdXJjZUlkKSsxOw0KICAgICAgICBpZihwYXJzZUludCh0YXJnZXRJZCk+PXBhcnNlSW50KGFkZERhdGFJZCkpIHRhcmdldElkID0gcGFyc2VJbnQodGFyZ2V0SWQpKzE7DQogICAgICAgIGJzTmV3LnB1c2goW3NvdXJjZUlkKycnLHRhcmdldElkKycnXSkNCiAgICAgIH0NCiAgICAgIGxldCBzc05ldyA9IFtdDQogICAgICBsZXQgc2ltaWxhcml0eVJlbCA9IHJlbERhdGFbJ3NpbWlsYXJpdHlSZWwnXTsNCiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgc2ltaWxhcml0eVJlbC5sZW5ndGg7IHIrKykgew0KICAgICAgICBsZXQgc291cmNlSWQgPSBzaW1pbGFyaXR5UmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzaW1pbGFyaXR5UmVsW3JdWzFdOw0KICAgICAgICBpZihwYXJzZUludChzb3VyY2VJZCk+PXBhcnNlSW50KGFkZERhdGFJZCkpIHNvdXJjZUlkID0gcGFyc2VJbnQoc291cmNlSWQpKzE7DQogICAgICAgIGlmKHBhcnNlSW50KHRhcmdldElkKT49cGFyc2VJbnQoYWRkRGF0YUlkKSkgdGFyZ2V0SWQgPSBwYXJzZUludCh0YXJnZXRJZCkrMTsNCiAgICAgICAgc3NOZXcucHVzaChbc291cmNlSWQrJycsdGFyZ2V0SWQrJyddKQ0KICAgICAgfQ0KICAgICAgcmV0dXJuUmVsRGF0YSA9IHsnYmFzaWNSZWwnOmJzTmV3LCdzaW1pbGFyaXR5UmVsJzpzc05ld307DQogICAgICBsZXQgbkRhdGEgPSByZXR1cm5EYXRhLmZpbmQoZnVuY3Rpb24oZCl7cmV0dXJuIGRbJ2lkJ10gPT0gbm9kZUlkfSk7DQogICAgICBsZXQgYURhdGEgPSByZXR1cm5EYXRhLmZpbmQoZnVuY3Rpb24oZCl7cmV0dXJuIGRbJ2lkJ10gPT0gYWRkRGF0YUlkfSk7DQogICAgICBpZihub2RlSWQhPSctMScpew0KICAgICAgICBuRGF0YVsnc29uJ10ucHVzaChhZGREYXRhSWQpOw0KICAgICAgICBhRGF0YVsnbGF5b3V0J10gPSBwYXJzZUludChuRGF0YVsnbGF5b3V0J10rMSk7DQogICAgICAgIGFEYXRhWydmYXRoZXInXSA9IFtub2RlSWRdOw0KICAgICAgfQ0KICAgICAgZWxzZXsNCiAgICAgICAgYURhdGFbJ2xheW91dCddID0gJzAnOw0KICAgICAgfQ0KICAgICAgX3RoaXMuZGF0YSA9IChyZXR1cm5EYXRhKTsNCiAgICAgIF90aGlzLnJlbERhdGEgPSByZXR1cm5SZWxEYXRhOw0KICAgICAgX3RoaXMuZ2V0VHJlZURhdGEoKTsNCiAgICAgIF90aGlzLnVwZGF0YSgpOw0KICAgICAgfQ0KICAgICAgaWYgKHN0YXRlID09ICdhZGRMaW5rQmFzaWMnKSB7DQogICAgICAgIGxldCBhZGRTb3VyY2VEYXRhSWQgPSBfdGhpcy5pbnNlcnRTb3VyY2VFbnRJZDsNCiAgICAgICAgbGV0IGFkZFRhcmdldERhdGFJZCA9IF90aGlzLmluc2VydFRhcmdldEVudElkOw0KICAgICAgICBpZigoYWRkU291cmNlRGF0YUlkICE9ICctMScpJiYoYWRkVGFyZ2V0RGF0YUlkICE9ICctMScpKXsNCiAgICAgICAgICByZXR1cm5SZWxEYXRhID0gIHRvb2xzLmRlZXBDbG9uZShyZWxEYXRhKTsNCiAgICAgICAgICByZXR1cm5SZWxEYXRhWydiYXNpY1JlbCddLnB1c2goW2FkZFNvdXJjZURhdGFJZCxhZGRUYXJnZXREYXRhSWRdKTsNCiAgICAgICAgICBfdGhpcy5pbnNlcnRTb3VyY2VFbnRJZCA9ICctMSc7DQogICAgICAgICAgX3RoaXMuaW5zZXJ0VGFyZ2V0RW50SWQgPSAnLTEnOw0KICAgICAgICAgIF90aGlzLnJlbERhdGEgPSByZXR1cm5SZWxEYXRhOw0KICAgICAgICAgIF90aGlzLmdldFRyZWVEYXRhKCk7DQogICAgICAgICAgX3RoaXMudXBkYXRhKCk7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9LA0KICAgIGFkZE5vZGVTb25DbGsoKSB7DQogICAgICB0aGlzLnRvb2xzU3RhdGUgPSAnYWRkTm9kZVNvbic7DQogICAgfSwNCiAgICBhZGROb2RlUGVyQ2xrKCkgew0KICAgICAgdGhpcy50b29sc1N0YXRlID0gJ2FkZE5vZGVQZXInOw0KICAgIH0sDQogICAgYWRkTGlua0Jhc2ljQ2xrKCkgew0KICAgICAgdGhpcy50b29sc1N0YXRlID0gJ2FkZExpbmtCYXNpYyc7DQogICAgfSwNCiAgICBkcmF3dG9waWNMaW5lKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgY29uc3QgbWFyZ2luID0gX3RoaXMubWFyZ2luOw0KICAgICAgY29uc3QgY29sb3IgPSBfdGhpcy5tY29sb3I7DQoNCiAgICAgIGxldCB3aWR0aCA9IHRoaXMuJHJlZnMudG9waWNMaW5lLm9mZnNldFdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7DQogICAgICBsZXQgaGVpZ2h0ID0gdGhpcy4kcmVmcy50b3BpY0xpbmUub2Zmc2V0SGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207DQogICAgICBfdGhpcy50b3BpY0xpbmVXaWR0aCA9IHdpZHRoOw0KICAgICAgX3RoaXMudG9waWNMaW5lSGVpZ2h0ID0gaGVpZ2h0Ow0KICAgICAgZDMuc2VsZWN0KCIjdG9waWNMaW5lIikuc2VsZWN0KCJzdmciKS5yZW1vdmUoKTsNCiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiN0b3BpY0xpbmUiKS5hcHBlbmQoInN2ZyIpDQogICAgICAgIC5hdHRyKCJpZCIsICJ0b3BpY0xpbmVTdmciKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQoNCiAgICAgIGxldCBncm91cHMgPSBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZ3JvdXBzIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCByb290RW50RyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJyb290RW50RyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgb3JpTGluZUcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAib3JpTGluZUciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICBvcmlMaW5lRy5hcHBlbmQoImxpbmUiKQ0KICAgICAgICAuYXR0cigieDEiLCAwKQ0KICAgICAgICAuYXR0cigieTEiLCBoZWlnaHQgLyAyKQ0KICAgICAgICAuYXR0cigieDIiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoInkyIiwgaGVpZ2h0IC8gMikNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsICJyZ2IoMjAwLDIwMCwyMDApIikNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsICI1cHgiKTsNCg0KICAgICAgbGV0IGN4TGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIF90aGlzLnZpZGVvRHVyYXRpb25dLCBbbWFyZ2luLmxlZnQsIHdpZHRoXSkNCg0KICAgICAgbGV0IGRhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuZGF0YSk7DQogICAgICBsZXQgRGl2aXNpb25EYXRhTGlzdCA9IFtdOw0KICAgICAgbGV0IGNvbG9ySW5kZXggPSAwOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGlmIChkYXRhW2ldWydsYXlvdXQnXSA9PSAnMCcpIHsNCiAgICAgICAgICBpZiAoRGl2aXNpb25EYXRhTGlzdC5sZW5ndGggIT0gMCkgew0KICAgICAgICAgICAgRGl2aXNpb25EYXRhTGlzdFtEaXZpc2lvbkRhdGFMaXN0Lmxlbmd0aCAtIDFdWyduZXh0SWQnXSA9IGRhdGFbaV1bJ2lkJ107DQogICAgICAgICAgICBkYXRhW2ldWydwcmVJZCddID0gRGl2aXNpb25EYXRhTGlzdFtEaXZpc2lvbkRhdGFMaXN0Lmxlbmd0aCAtIDFdWydpZCddOw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIHsgZGF0YVtpXVsncHJlSWQnXSA9ICItMSI7IH0NCiAgICAgICAgICBEaXZpc2lvbkRhdGFMaXN0LnB1c2goZGF0YVtpXSk7DQogICAgICAgICAgbGV0IHRpbWUgPSB0b29scy50aW1lMnNlY29uZHMoZGF0YVtpXVsndGltZSddWzBdKTsNCiAgICAgICAgICBsZXQgZW5kVGltZSA9IHRvb2xzLnRpbWUyc2Vjb25kcyhkYXRhW2ldWyd0aW1lJ11bMF0pICsgZGF0YVtpXVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgICAgIGxldCBjeCA9IGN4TGluZWFyKHRpbWUpOw0KICAgICAgICAgIGxldCBlbmR4ID0gY3hMaW5lYXIoZW5kVGltZSk7DQogICAgICAgICAgX3RoaXMuY29sb3JNYXBbZGF0YVtpXVsnaWQnXV0gPSBjb2xvckluZGV4ICUgY29sb3IubGVuZ3RoOw0KICAgICAgICAgIF90aGlzLmRyYXdSZWN0KG9yaUxpbmVHLCBjeCAtIDUsIGhlaWdodCAvIDIgLSA1LCAxMCwgMTAsIGhlaWdodCAvIDIsICJkaXZpc2lvbl8iICsgZGF0YVtpXVsiaWQiXSwgInJvb3RkaXZpc2lvbkxpbmUiLCAicmdiKDI1MCwyNTAsMjUwKSIsIDAsICcnLCAxKQ0KICAgICAgICAgIF90aGlzLmRyYXdSZWN0KHJvb3RFbnRHLCBjeCwgbWFyZ2luLnRvcCwgZW5keCAtIGN4LCBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSwgaGVpZ2h0IC8gMiwgInJvb3RFbnRfIiArIGRhdGFbaV1bJ2lkJ10sICJyb290RW50IiwgY29sb3JbX3RoaXMuY29sb3JNYXBbZGF0YVtpXVsnaWQnXV1dLCA1LCAicmdiKDE1MCwxNTAsMTUwKSIsIDAuMSkNCiAgICAgICAgICBjb2xvckluZGV4Kys7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIERpdmlzaW9uRGF0YUxpc3RbRGl2aXNpb25EYXRhTGlzdC5sZW5ndGggLSAxXVsnbmV4dElkJ10gPSAiLTEiOw0KICAgICAgX3RoaXMucm9vdERpdmlzaW9uRGF0YUxpc3QgPSBEaXZpc2lvbkRhdGFMaXN0Ow0KDQogICAgICAvLyBvcmlMaW5lRy5hcHBlbmQoImVsbGlwc2UiKQ0KICAgICAgLy8gLmF0dHIoImN4Iiw1MCkNCiAgICAgIC8vIC5hdHRyKCJjeSIsaGVpZ2h0LzIpDQogICAgICAvLyAuYXR0cigicngiLDUwKQ0KICAgICAgLy8gLmF0dHIoInJ5IixoZWlnaHQvMikNCiAgICAgIC8vIC5hdHRyKCJmaWxsIixjb2xvclszXSkNCiAgICAgIC8vIC5hdHRyKCJzdHJva2UiLCBjb2xvclszXSkNCg0KICAgICAgLy8gLmF0dHIoInN0cm9rZS13aWR0aCIsICI1cHgiKTsNCiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpDQogICAgICAvLyB0aGlzLiRidXMuJGVtaXQoImdldERhdGEiLGRhdGEpDQogICAgfSwNCiAgICBkcmF3UmVjdChzdmcsIHgsIHksIHcsIGgsIHJ4LCBpZE5hbWUsIGNsYXNzTmFtZSwgZmlsbCwgc3Ryb2tlV2lkdGgsIHN0cm9rZSwgb3BhY2l0eSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgc3ZnLmFwcGVuZCgicmVjdCIpDQogICAgICAgIC5hdHRyKCJ4IiwgeCkNCiAgICAgICAgLmF0dHIoInkiLCB5KQ0KICAgICAgICAuYXR0cigiaWQiLCBpZE5hbWUpDQogICAgICAgIC5hdHRyKCJjbGFzcyIsIGNsYXNzTmFtZSkNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBvcGFjaXR5KQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3KQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaCkNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgICAgICAuYXR0cigicngiLCByeCkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkvLyJyZ2IoMTUwLDE1MCwxNTApIikNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIHN0cm9rZVdpZHRoKQ0KICAgICAgICAub24oIm1vdXNlZG93biIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgX3RoaXMuc2VsZWN0UmVjdElkID0gaWROYW1lLnNwbGl0KCJfIilbMV0gLy9kMy5zZWxlY3QodGhpcykuYXR0cigiaWQiKTsNCiAgICAgICAgICBpZiAoZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIikgPT0gInJvb3RkaXZpc2lvbkxpbmUiKSB7DQogICAgICAgICAgICBfdGhpcy5zZWxlY3RSZWN0Q2xhc3MgPSAicm9vdEVudCI7DQogICAgICAgICAgICBfdGhpcy5tb3ZlTGluZVdpZHRoID0gX3RoaXMudG9waWNMaW5lV2lkdGg7DQogICAgICAgICAgICBfdGhpcy5EaXZpc2lvbkRhdGFMaXN0ID0gX3RoaXMucm9vdERpdmlzaW9uRGF0YUxpc3Q7DQogICAgICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9waWNMaW5lU3ZnJykuYWRkRXZlbnRMaXN0ZW5lcigibW91c2Vtb3ZlIiwgX3RoaXMubW92ZVJlY3QpOyAvLyDnm5HlkKzngrnlh7vkuovku7YNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAoZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIikgPT0gImVudGRpdmlzaW9uTGluZSIpIHsNCiAgICAgICAgICAgIF90aGlzLnNlbGVjdFJlY3RDbGFzcyA9ICJlZGl0RW50IjsNCiAgICAgICAgICAgIF90aGlzLm1vdmVMaW5lV2lkdGggPSBfdGhpcy5lbnRMaW5lV2lkdGg7DQogICAgICAgICAgICBfdGhpcy5EaXZpc2lvbkRhdGFMaXN0ID0gX3RoaXMuZW50RGl2aXNpb25EYXRhTGlzdDsNCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0RW50JykuYWRkRXZlbnRMaXN0ZW5lcigibW91c2Vtb3ZlIiwgX3RoaXMubW92ZVJlY3QpOyAvLyDnm5HlkKzngrnlh7vkuovku7YNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2V1cCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvcGljTGluZVN2ZycpLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1vdXNlbW92ZSIsIF90aGlzLm1vdmVSZWN0KTsgLy8gDQogICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRFbnQnKS5yZW1vdmVFdmVudExpc3RlbmVyKCJtb3VzZW1vdmUiLCBfdGhpcy5tb3ZlUmVjdCk7IC8vIA0KICAgICAgICAgIC8vIF90aGlzLiRidXMuJGVtaXQoImdyYXBoRGF0YSIsIF90aGlzLmRhdGEpOw0KDQogICAgICAgICAgX3RoaXMuJGJ1cy4kZW1pdCgidHJlZURhdGEiLCBfdGhpcy50cmVlRGF0YSk7DQogICAgICAgIH0pDQogICAgfSwNCiAgICBtb3ZlUmVjdChlKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgc2VsZWN0UmVjdCA9IF90aGlzLkRpdmlzaW9uRGF0YUxpc3QuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBfdGhpcy5zZWxlY3RSZWN0SWQ7IH0pLy/lj7PovrnnmoRyZWN0DQogICAgICBsZXQgcHJlSWQgPSBzZWxlY3RSZWN0WydwcmVJZCddOy8v5bem6L6555qEcmVjdA0KICAgICAgbGV0IG5leHRJZCA9IHNlbGVjdFJlY3RbJ25leHRJZCddOy8v5Y+z6L6555qE5Y+z6L65cmVjdA0KICAgICAgbGV0IHJlY3RDbGFzcyA9IF90aGlzLnNlbGVjdFJlY3RDbGFzczsNCiAgICAgIGxldCBwcmV4ID0gMDsNCiAgICAgIGlmIChwcmVJZCAhPSAnLTEnKSB7DQogICAgICAgIHByZXggPSBkMy5zZWxlY3QoIiMiICsgcmVjdENsYXNzICsgIl8iICsgcHJlSWQpLmF0dHIoIngiKQ0KICAgICAgICBkMy5zZWxlY3QoIiMiICsgcmVjdENsYXNzICsgIl8iICsgcHJlSWQpDQogICAgICAgICAgLmF0dHIoIndpZHRoIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgIHJldHVybiBlLm9mZnNldFggLSBwcmV4Ow0KICAgICAgICAgIH0pDQogICAgICB9DQogICAgICBsZXQgbmV4dFggPSAxMDA7DQogICAgICBpZiAobmV4dElkID09ICctMScpIHsNCiAgICAgICAgbmV4dFggPSBfdGhpcy5tb3ZlTGluZVdpZHRoOw0KICAgICAgfQ0KICAgICAgZWxzZSB7DQogICAgICAgIG5leHRYID0gZDMuc2VsZWN0KCIjIiArIHJlY3RDbGFzcyArICJfIiArIG5leHRJZCkuYXR0cigieCIpOw0KICAgICAgfQ0KICAgICAgZDMuc2VsZWN0KCIjIiArIHJlY3RDbGFzcyArICJfIiArIF90aGlzLnNlbGVjdFJlY3RJZCkNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4gbmV4dFggLSBlLm9mZnNldFg7DQogICAgICAgIH0pDQogICAgICAgIC5hdHRyKCJ4IiwgZS5vZmZzZXRYKQ0KICAgICAgZDMuc2VsZWN0KCIjZGl2aXNpb25fIiArIF90aGlzLnNlbGVjdFJlY3RJZCkNCiAgICAgICAgLmF0dHIoIngiLCBlLm9mZnNldFggLSA1KQ0KDQogICAgICBpZiAoKGUub2Zmc2V0WCA+IChfdGhpcy50b3BpY0xpbmVXaWR0aCkpIHx8IChlLm9mZnNldFggPCAoMCkpIHx8IChlLm9mZnNldFkgPiAoX3RoaXMudG9waWNMaW5lSGVpZ2h0KSkgfHwgKGUub2Zmc2V0WSA8ICgwKSkpIHsNCiAgICAgICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvcGljTGluZVN2ZycpLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1vdXNlbW92ZSIsIF90aGlzLm1vdmVSZWN0KTsgLy8gDQogICAgICB9DQogICAgfSwNCiAgICBnZXRUcmVlRGF0YSgpew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IG9yaURhdGEgPSB0b29scy5kZWVwQ2xvbmUodGhpcy5kYXRhKTsNCiAgICAgIHZhciBkYXRhID0gew0KICAgICAgICAibmFtZSI6ICJyb290IiwNCiAgICAgICAgImNoaWxkcmVuIjogW10NCiAgICAgIH07DQoNCiAgICAgIGZvciAobGV0IGkgPSBvcmlEYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7DQogICAgICAgIGxldCBzb25zID0gb3JpRGF0YVtpXVsnc29uJ107DQogICAgICAgIG9yaURhdGFbaV1bJ2NoaWxkcmVuJ10gPSBbXTsNCiAgICAgICAgaWYgKHNvbnMubGVuZ3RoID4gMCkgew0KICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgc29ucy5sZW5ndGg7IHMrKykgew0KICAgICAgICAgICAgb3JpRGF0YVtpXVsnY2hpbGRyZW4nXS5wdXNoKG9yaURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb25zW3NdIH0pKQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgbGV0IGMgPSAwIDsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpRGF0YS5sZW5ndGg7IGkrKykgew0KDQogICAgICAgIGxldCBsYXlvdXQgPSBvcmlEYXRhW2ldWydsYXlvdXQnXTsNCiAgICAgICAgaWYgKGxheW91dCA9PSAnMCcpIHsNCiAgICAgICAgICBkYXRhWydjaGlsZHJlbiddLnB1c2gob3JpRGF0YVtpXSk7DQogICAgICAgICAgaWYob3JpRGF0YVtpXVsnbmFtZSddIT0iVGVzdCIpew0KICAgICAgICAgICAgX3RoaXMucm9vdENvbG9yTWFwW29yaURhdGFbaV1bJ2lkJ11dID0gX3RoaXMubWNvbG9yW2NdOw0KICAgICAgICAgICAgYysrOw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlew0KICAgICAgICAgICAgX3RoaXMucm9vdENvbG9yTWFwW29yaURhdGFbaV1bJ2lkJ11dID0icmdiKDI1MCwgMTk5LCA4OCkiOw0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfQ0KDQogICAgICB0aGlzLnRyZWVEYXRhID0gZGF0YTsNCiAgICAgIGNvbnNvbGUubG9nKF90aGlzLnJvb3RDb2xvck1hcCkNCiAgICAgIHRoaXMuJGJ1cy4kZW1pdCgidHJlZURhdGEiLCBbZGF0YSxfdGhpcy5yb290Q29sb3JNYXBdKTsNCiAgICB9LA0KICAgIGRyYXdyb290VHJlZSgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGNvbnN0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGxldCB3aWR0aCA9IHRoaXMuJHJlZnMucm9vdFRyZWUub2Zmc2V0V2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCBoZWlnaHQgPSB0aGlzLiRyZWZzLnJvb3RUcmVlLm9mZnNldEhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tOw0KDQogICAgICBsZXQgY29sb3IgPSBfdGhpcy5tY29sb3I7DQogICAgICBsZXQgY29sb3JNYXAgPSBfdGhpcy5jb2xvck1hcDsNCiAgICAgIC8vIHZhciB0cmVlID0gZDMudHJlZSgpDQogICAgICAvLyAgIC5zaXplKFt3aWR0aCwgaGVpZ2h0IC0gMjAwXSk7DQogICAgICBkMy5zZWxlY3QoIiNyb290VHJlZSIpLnNlbGVjdCgic3ZnIikucmVtb3ZlKCk7DQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjcm9vdFRyZWUiKS5hcHBlbmQoInN2ZyIpDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIHdpZHRoKQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KQ0KDQogICAgICBsZXQgdHJhbnNZID0gaGVpZ2h0Ow0KICAgICAgbGV0IHRyZWVHVHJhbnNmb3JtWCA9IF90aGlzLnRyZWVHVHJhbnNmb3JtWDsNCiAgICAgIGxldCB0cmVlR1RyYW5zZm9ybVkgPSBfdGhpcy50cmVlR1RyYW5zZm9ybVk7DQogICAgICBsZXQgdHJlZUdUcmFuc2Zvcm1LID0gX3RoaXMudHJlZUdUcmFuc2Zvcm1LOw0KICAgICAgbGV0IGdyb3VwcyA9IHN2Zy5hcHBlbmQoImciKQ0KICAgICAgICAuYXR0cigiaWQiLCAiZWRpdHJvb3RUcmVlZyIpDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIHdpZHRoKQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KQ0KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgICJ0cmFuc2xhdGUoIit0cmVlR1RyYW5zZm9ybVgrJywnICt0cmVlR1RyYW5zZm9ybVkgKyAiKSBzY2FsZSgiK3RyZWVHVHJhbnNmb3JtSysiKSIpOw0KDQogICAgICAgIGxldCBzdHggPSAwOw0KICAgICAgICBsZXQgc3R5ID0gMDsNCiAgICAgICAgbGV0IHN0ayA9MTsNCiAgICAgIHZhciBncmFwaFpvb20gPSBkMy56b29tKCkNCiAgICAgICAgLnNjYWxlRXh0ZW50KFswLCAxMF0pDQogICAgICAgIC5vbigic3RhcnQiLCAoZSkgPT4gew0KICAgICAgICAgIHN0eSA9IGUudHJhbnNmb3JtLnk7DQogICAgICAgICAgc3R4ID0gZS50cmFuc2Zvcm0ueDsNCiAgICAgICAgICBzdGsgPSBlLnRyYW5zZm9ybS5rOw0KICAgICAgICB9KQ0KICAgICAgICAub24oJ3pvb20nLCAoZSkgPT4gew0KICAgICAgICAgIHRyZWVHVHJhbnNmb3JtWCA9IF90aGlzLnRyZWVHVHJhbnNmb3JtWCArIGUudHJhbnNmb3JtLnggLSBzdHg7DQogICAgICAgICAgdHJlZUdUcmFuc2Zvcm1ZID0gX3RoaXMudHJlZUdUcmFuc2Zvcm1ZICsgZS50cmFuc2Zvcm0ueSAtIHN0eTsNCiAgICAgICAgICB0cmVlR1RyYW5zZm9ybUsgPSBfdGhpcy50cmVlR1RyYW5zZm9ybUsgKyBlLnRyYW5zZm9ybS5rIC0gc3RrOw0KICAgICAgICAgIGdyb3Vwcy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAodHJlZUdUcmFuc2Zvcm1YKSArICcsJyArICh0cmVlR1RyYW5zZm9ybVkpICsgJykgc2NhbGUoJyArICh0cmVlR1RyYW5zZm9ybUspICsgJyknKQ0KICAgICAgICB9KQ0KICAgICAgICAub24oJ2VuZCcsIChlKSA9PiB7DQogICAgICAgICAgX3RoaXMudHJlZUdUcmFuc2Zvcm1YID0gdHJlZUdUcmFuc2Zvcm1YOw0KICAgICAgICAgIF90aGlzLnRyZWVHVHJhbnNmb3JtWSA9IHRyZWVHVHJhbnNmb3JtWTsNCiAgICAgICAgICBfdGhpcy50cmVlR1RyYW5zZm9ybUsgPSB0cmVlR1RyYW5zZm9ybUs7DQogICAgICAgICAgZ3JvdXBzLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICh0cmVlR1RyYW5zZm9ybVgpICsgJywnICsgKHRyZWVHVHJhbnNmb3JtWSkgKyAnKSBzY2FsZSgnICsgKHRyZWVHVHJhbnNmb3JtSykgKyAnKScpDQogICAgICAgIH0pOw0KICAgICAgc3ZnLmNhbGwoZ3JhcGhab29tKQ0KDQogICAgICBjb25zdCBnTGluayA9IGdyb3Vwcy5hcHBlbmQoImciKQ0KICAgICAgICAuYXR0cigiZmlsbCIsICJub25lIikNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsICIjNTU1IikNCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoIiArIG1hcmdpbi5sZWZ0ICsgIiwiICsgbWFyZ2luLnRvcCArICIpIikNCiAgICAgICAgLmF0dHIoInN0cm9rZS1vcGFjaXR5IiwgMC40KQ0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgMS41KTsNCg0KICAgICAgY29uc3QgZ05vZGUgPSBncm91cHMuYXBwZW5kKCJnIikNCiAgICAgICAgLmF0dHIoImN1cnNvciIsICJwb2ludGVyIikNCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoIiArIG1hcmdpbi5sZWZ0ICsgIiwiICsgbWFyZ2luLnRvcCArICIpIikNCiAgICAgICAgLmF0dHIoInBvaW50ZXItZXZlbnRzIiwgImFsbCIpDQoNCiAgICAgIGxldCBkYXRhID0gX3RoaXMudHJlZURhdGE7DQogICAgICBsZXQgZGlhZ29uYWwgPSBkMy5saW5rSG9yaXpvbnRhbCgpLngoZCA9PiBkLnkpLnkoZCA9PiBkLngpOw0KICAgICAgbGV0IHRyZWUgPSBkMy50cmVlKCkubm9kZVNpemUoWzUwLCAxNTBdKTsvLy5zaXplKFsoaGVpZ2h0IC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpICogMiwgKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLTEwXSkNCiAgICAgIGNvbnN0IHJvb3QgPSBkMy5oaWVyYXJjaHkoZGF0YSk7DQogICAgICBjb25zdCBub2RlcyA9IHJvb3QuZGVzY2VuZGFudHMoKS5yZXZlcnNlKCk7DQogICAgICBjb25zdCBsaW5rcyA9IHJvb3QubGlua3MoKTsNCiAgICAgIHRyZWUocm9vdCk7DQogICAgICBjb25zb2xlLmxvZyhub2RlcykNCiAgICAgIGNvbnN0IG5vZGUgPSBnTm9kZS5zZWxlY3RBbGwoImciKQ0KICAgICAgICAuZGF0YShub2RlcywgZCA9PiBkLmlkKTsNCg0KICAgICAgY29uc3Qgbm9kZUVudGVyID0gbm9kZS5kYXRhKG5vZGVzKS5lbnRlcigpLmFwcGVuZCgiZyIpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAoZCkgPT4gew0KICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7ZC55fSwke2QueH0pYA0KICAgICAgICB9KQ0KICAgICAgICAub24oImNsaWNrIiwgKGV2ZW50LCBkKSA9PiB7DQogICAgICAgICAgZC5jaGlsZHJlbiA9IGQuY2hpbGRyZW4gPyBudWxsIDogZC5fY2hpbGRyZW47DQogICAgICAgICAgLy8gdXBkYXRlKGQpOw0KICAgICAgICB9KQ0KDQogICAgICBub2RlRW50ZXIuYXBwZW5kKCJjaXJjbGUiKQ0KICAgICAgICAuYXR0cigiciIsIDEwKQ0KICAgICAgICAuYXR0cigiaWQiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGNvbnNvbGUubG9nKGQpDQogICAgICAgICAgaWYoZC5kYXRhLm5hbWUgPT0gJ3Jvb3QnKQ0KICAgICAgICAgICAgcmV0dXJuICJ0cmVlTm9kZV8tMSI7DQogICAgICAgICAgcmV0dXJuICJ0cmVlTm9kZV8iICsgZC5kYXRhLmlkOw0KICAgICAgICB9KQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgaWYgKGQuZGF0YS5uYW1lID09ICdyb290Jykgew0KICAgICAgICAgICAgcmV0dXJuICdncmV5Jw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBkLnBhcmVudDsNCiAgICAgICAgICAgIGxldCByb290ZCA9IG51bGw7DQogICAgICAgICAgICB3aGlsZSAocGFyZW50LmRhdGEubmFtZSAhPSAncm9vdCcpIHsNCiAgICAgICAgICAgICAgcm9vdGQgPSBwYXJlbnQ7DQogICAgICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50LmRhdGEubmFtZSA9PSAncm9vdCcpIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JbY29sb3JNYXBbcGFyZW50LmRhdGEuaWRdXQ0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gY29sb3JbY29sb3JNYXBbZC5kYXRhLmlkXV0NCiAgICAgICAgICB9DQoNCiAgICAgICAgfSkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsICJyZ2IoMTAwLDEwMCwxMDApIikNCiAgICAgICAgLy8gLmF0dHIoImZpbGwiLCBkID0+IGQuX2NoaWxkcmVuID8gIiM1NTUiIDogIiM5OTkiKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgMSkNCiAgICAgICAgLm9uKCJtb3VzZW92ZXIiLCBmdW5jdGlvbiAoKSB7DQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInIiLCAxNSk7DQoNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCJtb3VzZWxlYXZlIiwgZnVuY3Rpb24gKCkgew0KICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJyIiwgMTApDQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2Vkb3duIiwgZnVuY3Rpb24gKCkgew0KICAgICAgICAgIGxldCBub2RlSWROID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoImlkIik7DQogICAgICAgICAgbGV0IG5vZGVJZCA9IG5vZGVJZE4uc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgICBfdGhpcy5jdXJFbnRJZCA9IG5vZGVJZDsNCiAgICAgICAgICBpZihub2RlSWQgPT0gJy0xJyl7DQogICAgICAgICAgICBfdGhpcy5pbnNlcnRFbnRJZCA9IHBhcnNlSW50KG5vZGVJZCkgKyAxICsgJyc7DQogICAgICAgICAgX3RoaXMuY2xpY2tfbm9kZSgpOw0KICAgICAgICAgICAgcmV0dXJuDQogICAgICAgICAgfQ0KICAgICAgICAgIGxldCBjdXJEYXRhID0gX3RoaXMuZGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IG5vZGVJZDsgfSk7DQogICAgICAgICAgaWYgKF90aGlzLnRvb2xzU3RhdGUgPT0gJ2FkZE5vZGVTb24nKSB7DQogICAgICAgICAgICBfdGhpcy5pbnNlcnRFbnRJZCA9IHBhcnNlSW50KG5vZGVJZCkgKyAxICsgJyc7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnRvb2xzU3RhdGUgPT0gJ2FkZExpbmtCYXNpYycpIHsNCiAgICAgICAgICAgIGlmKF90aGlzLmluc2VydFNvdXJjZUVudElkID09Ii0xIikNCiAgICAgICAgICAgICAgX3RoaXMuaW5zZXJ0U291cmNlRW50SWQgPSBwYXJzZUludChub2RlSWQpICsgJyc7DQogICAgICAgICAgICBlbHNlew0KICAgICAgICAgICAgICBfdGhpcy5pbnNlcnRUYXJnZXRFbnRJZCA9IHBhcnNlSW50KG5vZGVJZCkgKyAnJzsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgaWYgKCAoY3VyRGF0YVsnc29uJ10ubGVuZ3RoID4gMCkpIHsNCiAgICAgICAgICAgIF90aGlzLmluc2VydEVudElkID0gcGFyc2VJbnQoY3VyRGF0YVsnc29uJ11bMF0pICsgMSArJyc7DQogICAgICAgICAgfTsNCiAgICAgICAgICBfdGhpcy5jbGlja19ub2RlKCk7DQogICAgICAgIH0pDQoNCiAgICAgIC8vIG5vZGVFbnRlci5hcHBlbmQoInRleHQiKQ0KICAgICAgLy8gICAuYXR0cigiZHkiLCAiMC4zMWVtIikNCiAgICAgIC8vICAgLmF0dHIoIngiLCBkID0+IGQuX2NoaWxkcmVuID8gLTYgOiA2KQ0KICAgICAgLy8gICAuYXR0cigidGV4dC1hbmNob3IiLCBkID0+IGQuX2NoaWxkcmVuID8gImVuZCIgOiAic3RhcnQiKQ0KICAgICAgLy8gICAudGV4dChkID0+IGQuZGF0YS5uYW1lKQ0KICAgICAgLy8gICAuY2xvbmUodHJ1ZSkubG93ZXIoKQ0KICAgICAgLy8gICAuYXR0cigic3Ryb2tlLWxpbmVqb2luIiwgInJvdW5kIikNCiAgICAgIC8vICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIDMpDQogICAgICAvLyAgIC5hdHRyKCJzdHJva2UiLCAid2hpdGUiKTsNCg0KICAgICAgY29uc3QgbGluayA9IGdMaW5rLnNlbGVjdEFsbCgicGF0aCIpDQogICAgICAgIC5kYXRhKGxpbmtzLCBkID0+IGQudGFyZ2V0LmlkKTsNCg0KICAgICAgY29uc3QgbGlua0VudGVyID0gbGluay5lbnRlcigpLmFwcGVuZCgicGF0aCIpDQogICAgICAgIC5hdHRyKCJkIiwgZCA9PiB7DQogICAgICAgICAgY29uc3QgbyA9IHsgeDogZC5zb3VyY2UueCwgeTogZC5zb3VyY2UueSB9Ow0KICAgICAgICAgIGNvbnN0IHAgPSB7IHg6IGQudGFyZ2V0LngsIHk6IGQudGFyZ2V0LnkgfQ0KICAgICAgICAgIHJldHVybiBkaWFnb25hbCh7IHNvdXJjZTogbywgdGFyZ2V0OiBwIH0pOw0KICAgICAgICB9KQ0KICAgICAgICAuYXR0cigic3Ryb2tlIiwgInJnYigxMDAsMTAwLDEwMCkiKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgNSkNCiAgICAgIF90aGlzLmRyYXdSb290VHJlZVJlbChnTGluaywgbm9kZXMpOw0KICAgIH0sDQogICAgZHJhd1Jvb3RUcmVlUmVsKHN2Zywgbm9kZURhdGEpIHsNCg0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHJlbERhdGEgPSBfdGhpcy5yZWxEYXRhOw0KICAgICAgbGV0IG9EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgY29uc29sZS5sb2cobm9kZURhdGEpDQogICAgICBsZXQgbWFyZ2luID0gX3RoaXMubWFyZ2luOw0KICAgICAgbGV0IGhlaWdodCA9IHN2Zy5hdHRyKCdoZWlnaHQnKTsNCiAgICAgIC8vIGxldCBiYXNpY1JlbCA9IHJlbERhdGFbJ3NpbWlsYXJpdHlSZWwnXTsNCiAgICAgIGxldCBiYXNpY1JlbCA9IHJlbERhdGFbJ2Jhc2ljUmVsJ107DQogICAgICBmb3IgKGxldCByID0gMDsgciA8IGJhc2ljUmVsLmxlbmd0aDsgcisrKSB7DQoNCiAgICAgICAgbGV0IHNvdXJjZUlkID0gYmFzaWNSZWxbcl1bMF07DQogICAgICAgIGxldCB0YXJnZXRJZCA9IGJhc2ljUmVsW3JdWzFdOw0KICAgICAgICBsZXQgaWROID0gImJhc2ljUmVsIiArIHNvdXJjZUlkICsgIl8iICsgdGFyZ2V0SWQ7DQogICAgICAgIGxldCBjbGFzc04gPSAiYmFzaWNSZWwgc291cmNlIiArIHNvdXJjZUlkICsgIiB0YXJnZXQiICsgdGFyZ2V0SWQ7DQogICAgICAgIGxldCBzb3VyY2VOb2RlID0gbm9kZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnZGF0YSddWydpZCddID09IHNvdXJjZUlkIH0pOw0KICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9IG5vZGVEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2RhdGEnXVsnaWQnXSA9PSB0YXJnZXRJZCB9KTsNCiAgICAgICAgaWYgKHNvdXJjZU5vZGVbJ3gnXSA+IHRhcmdldE5vZGVbJ3gnXSkgew0KICAgICAgICAgIGxldCB0cCA9IHNvdXJjZU5vZGU7DQogICAgICAgICAgc291cmNlTm9kZSA9IHRhcmdldE5vZGU7DQogICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRwOw0KICAgICAgICB9DQogICAgICAgIGNvbnN0IHBhdGggPSBkMy5wYXRoKCk7DQoNCiAgICAgICAgbGV0IHN0YXJ0WCA9IHNvdXJjZU5vZGVbJ3knXTsNCiAgICAgICAgbGV0IGVuZFggPSB0YXJnZXROb2RlWyd5J107DQogICAgICAgIGxldCBzdGFydFkgPSBzb3VyY2VOb2RlWyd4J107DQogICAgICAgIGxldCBlbmRZID0gdGFyZ2V0Tm9kZVsneCddOw0KICAgICAgICBsZXQgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7DQogICAgICAgIGxldCBtaWRZID0gKHN0YXJ0WSArIGVuZFkpIC8gMjsNCiAgICAgICAgbGV0IGNueCA9IChzdGFydFggPiBlbmRYKSA/IChzdGFydFggKyAxMCArIDAuMjUgKiAoZW5kWSAtIHN0YXJ0WSkpIDogKGVuZFggKyAxMCArIDAuMjUgKiAoZW5kWSAtIHN0YXJ0WSkpOw0KICAgICAgICBwYXRoLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7DQogICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhjbngsIG1pZFksIGNueCwgbWlkWSwgZW5kWCwgZW5kWSk7DQogICAgICAgIF90aGlzLmRyYXdUaW1lTGluZShzdmcsIHBhdGgsICJyZ2IoMjAwLDIwMCwyMDApIiwgNSwgIjksOSIsIGlkTiwgY2xhc3NOKTsNCg0KDQogICAgICB9Ow0KICAgICAgbGV0IHNpbWlsYXJpdHlSZWwgPSByZWxEYXRhWydzaW1pbGFyaXR5UmVsJ107DQogICAgICAvLyBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBzaW1pbGFyaXR5UmVsLmxlbmd0aDsgcisrKSB7DQoNCiAgICAgICAgbGV0IHNvdXJjZUlkID0gc2ltaWxhcml0eVJlbFtyXVswXTsNCiAgICAgICAgbGV0IHRhcmdldElkID0gc2ltaWxhcml0eVJlbFtyXVsxXTsNCg0KICAgICAgICBsZXQgaWROID0gInNpbWlsYXJpdHlSZWwiICsgc291cmNlSWQgKyAiXyIgKyB0YXJnZXRJZDsNCg0KICAgICAgICBsZXQgY2xhc3NOID0gInNpbWlsYXJpdHlSZWwgc291cmNlIiArIHNvdXJjZUlkICsgIiB0YXJnZXQiICsgdGFyZ2V0SWQ7DQogICAgICAgIGxldCBzb3VyY2VOb2RlID0gbm9kZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnZGF0YSddWydpZCddID09IHNvdXJjZUlkIH0pOw0KICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9IG5vZGVEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2RhdGEnXVsnaWQnXSA9PSB0YXJnZXRJZCB9KTsNCiAgICAgICAgaWYgKHNvdXJjZU5vZGVbJ3gnXSA+IHRhcmdldE5vZGVbJ3gnXSkgew0KICAgICAgICAgIGxldCB0cCA9IHNvdXJjZU5vZGU7DQogICAgICAgICAgc291cmNlTm9kZSA9IHRhcmdldE5vZGU7DQogICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRwOw0KICAgICAgICB9DQogICAgICAgIGNvbnN0IHBhdGggPSBkMy5wYXRoKCk7DQoNCiAgICAgICAgbGV0IHN0YXJ0WCA9IHNvdXJjZU5vZGVbJ3knXTsNCiAgICAgICAgbGV0IGVuZFggPSB0YXJnZXROb2RlWyd5J107DQogICAgICAgIGxldCBzdGFydFkgPSBzb3VyY2VOb2RlWyd4J107DQogICAgICAgIGxldCBlbmRZID0gdGFyZ2V0Tm9kZVsneCddOw0KICAgICAgICBsZXQgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7DQogICAgICAgIGxldCBtaWRZID0gKHN0YXJ0WSArIGVuZFkpIC8gMjsNCiAgICAgICAgbGV0IGNueCA9IChzdGFydFggPiBlbmRYKSA/IChzdGFydFggKyAxMDAgKyAwLjUgKiAoZW5kWSAtIHN0YXJ0WSkpIDogKGVuZFggKyAxMDAgKyAwLjUgKiAoZW5kWSAtIHN0YXJ0WSkpOw0KDQogICAgICAgIHBhdGgubW92ZVRvKHN0YXJ0WCwgc3RhcnRZKTsNCiAgICAgICAgcGF0aC5saW5lVG8oY254LCBzdGFydFkpOw0KICAgICAgICBwYXRoLmxpbmVUbyhjbngsIGVuZFkpOw0KICAgICAgICBwYXRoLmxpbmVUbyhlbmRYLCBlbmRZKTsNCiAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgcGF0aCwgInJnYigyMDAsMjAwLDIwMCkiLCA1LCAiMCIsIGlkTiwgY2xhc3NOKTsNCg0KDQogICAgICB9Ow0KICAgIH0sDQogICAgZHJhd2VkaXREYXRhKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgY29uc3QgbWFyZ2luID0gX3RoaXMubWFyZ2luOw0KICAgICAgbGV0IHdpZHRoID0gdGhpcy4kcmVmcy5lZGl0RGF0YS5vZmZzZXRXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0IC0gNjA7DQogICAgICBsZXQgaGVpZ2h0ID0gdGhpcy4kcmVmcy5lZGl0RGF0YS5vZmZzZXRIZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCiAgICAgIGQzLnNlbGVjdCgiI2VkaXREYXRhIikuc2VsZWN0KCJzdmciKS5yZW1vdmUoKTsNCiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiNlZGl0RGF0YSIpLmFwcGVuZCgic3ZnIikNCiAgICAgICAgLmF0dHIoImlkIiwgImVkaXRFbnQiKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQoNCiAgICAgIGxldCBlbnRHID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImVudEciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHNvbkcgPSBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAic29uRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCkuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgxLDMyMCkiKTsNCiAgICAgIC8vIF90aGlzLmVudEcgPSBlbnRHOw0KICAgICAgLy8gX3RoaXMuc29uRyA9IHNvbkc7DQogICAgICBfdGhpcy5kcmF3RW50aXR5KF90aGlzLmRhdGFbMF0pOw0KICAgICAgX3RoaXMuZHJhd1NvbkxpbmUoX3RoaXMuZGF0YVsxXSk7DQogICAgfSwNCiAgICBkcmF3U29uTGluZShkYXRhKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcHN2ZyA9IGQzLnNlbGVjdCgiI3NvbkciKTsNCiAgICAgIGxldCB3ID0gcHN2Zy5hdHRyKCJ3aWR0aCIpIC0gMTsNCiAgICAgIGxldCBoID0gMzU7DQogICAgICBwc3ZnLnJlbW92ZSgpOw0KICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCgiI2VkaXRFbnQiKS5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJzb25HIikuYXR0cigid2lkdGgiLCB3ICsgMSkuYXR0cigiaGVpZ2h0IiwgaCArIDIpLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoMSwyODApIik7DQogICAgICBsZXQgY29sb3JfbGluZWFyID0gX3RoaXMuaW1wb3J0YW5jZUNvbG9yX2xpbmVhcjsNCiAgICAgIGxldCBjb21wdXRlX2NvbG9yID0gX3RoaXMuaW1wb3J0YW5jZUNvbXB1dGVfY29sb3I7DQogICAgICBsZXQgb0RhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgX3RoaXMuZW50TGluZVdpZHRoID0gdzsNCiAgICAgIC8vIGlmIChzb25MaXN0Lmxlbmd0aCA+IDApIHsNCiAgICAgIHN2Zy5zZWxlY3RBbGwoKS5yZW1vdmUoKTsNCiAgICAgIHN2Zy5hcHBlbmQoImxpbmUiKQ0KICAgICAgICAuYXR0cigieDEiLCAwKQ0KICAgICAgICAuYXR0cigieTEiLCBoIC8gMikNCiAgICAgICAgLmF0dHIoIngyIiwgdykNCiAgICAgICAgLmF0dHIoInkyIiwgaCAvIDIpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCAicmdiKDIwMCwyMDAsMjAwKSIpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCAiNXB4Iik7DQoNCiAgICAgIGxldCB0b3RhbFNvbkR1cmF0aW9uID0gMDsNCiAgICAgIGxldCBkYXRhSW5kZXggPSBvRGF0YS5tYXAoaXRlbSA9PiBpdGVtLmlkKS5pbmRleE9mKGRhdGFbJ2lkJ10pOw0KICAgICAgbGV0IHN0YXJ0SW5kZXggPSAoKGRhdGFJbmRleCAtIDIpID4gMCkgPyAoZGF0YUluZGV4IC0gMikgOiAoMCk7DQogICAgICBsZXQgZW5kSW5kZXggPSAoKGRhdGFJbmRleCArIDEpIDwgb0RhdGEubGVuZ3RoKSA/IChkYXRhSW5kZXggKyAyKSA6IChvRGF0YS5sZW5ndGggLSAxKTsNCg0KICAgICAgbGV0IGRhdGFMaSA9IHRvb2xzLmRlZXBDbG9uZShvRGF0YSkuc3BsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4IC0gc3RhcnRJbmRleCArIDEpOw0KICAgICAgLy8gbGV0IGRhdGEgPSBzb25MaXN0Ow0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhTGkubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IGN1ckVudCA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gZGF0YUxpW2ldWydpZCddIH0pOw0KICAgICAgICBsZXQgdGltZSA9IHRvb2xzLnRpbWUyc2Vjb25kcyhjdXJFbnRbJ3RpbWUnXVswXSk7DQogICAgICAgIGxldCBlbmRUaW1lID0gdG9vbHMudGltZTJzZWNvbmRzKGN1ckVudFsndGltZSddWzFdKTsNCiAgICAgICAgdG90YWxTb25EdXJhdGlvbiArPSBlbmRUaW1lIC0gdGltZTsNCiAgICAgIH0NCiAgICAgIF90aGlzLnRvdGFsU29uRHVyYXRpb24gPSB0b3RhbFNvbkR1cmF0aW9uOw0KICAgICAgbGV0IGN4TGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHRvdGFsU29uRHVyYXRpb25dLCBbMCwgd10pOw0KICAgICAgbGV0IERpdmlzaW9uRGF0YUxpc3QgPSBbXTsNCiAgICAgIC8vIGxldCBjb2xvckluZGV4ID0gMDsNCiAgICAgIGxldCBwcmV4ID0gMDsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxpLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBjdXJFbnQgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGRhdGFMaVtpXVsnaWQnXSB9KTsNCiAgICAgICAgbGV0IHRlbXAgPSB0b29scy5kZWVwQ2xvbmUoY3VyRW50KTsNCiAgICAgICAgaWYgKERpdmlzaW9uRGF0YUxpc3QubGVuZ3RoICE9IDApIHsNCiAgICAgICAgICBEaXZpc2lvbkRhdGFMaXN0W0RpdmlzaW9uRGF0YUxpc3QubGVuZ3RoIC0gMV1bJ25leHRJZCddID0gdGVtcFsnaWQnXTsNCiAgICAgICAgICB0ZW1wWydwcmVJZCddID0gRGl2aXNpb25EYXRhTGlzdFtEaXZpc2lvbkRhdGFMaXN0Lmxlbmd0aCAtIDFdWydpZCddOw0KICAgICAgICB9DQogICAgICAgIGVsc2UgeyB0ZW1wWydwcmVJZCddID0gIi0xIjsgfQ0KICAgICAgICBEaXZpc2lvbkRhdGFMaXN0LnB1c2godGVtcCk7DQogICAgICAgIGxldCB0aW1lID0gdG9vbHMudGltZTJzZWNvbmRzKGN1ckVudFsndGltZSddWzBdKTsNCiAgICAgICAgbGV0IGVuZFRpbWUgPSB0b29scy50aW1lMnNlY29uZHMoY3VyRW50Wyd0aW1lJ11bMV0pOw0KICAgICAgICBsZXQgY3VyRW50RHVyID0gZW5kVGltZSAtIHRpbWU7DQogICAgICAgIGxldCBjeCA9IHByZXg7DQogICAgICAgIGxldCBlbmR4ID0gcHJleCArIGN4TGluZWFyKGN1ckVudER1cik7DQogICAgICAgIGxldCBpbXBvcnRhbmNlVmFsdWUgPSBjdXJFbnRbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107DQogICAgICAgIGxldCBlbnRDb2xvciA9IGNvbXB1dGVfY29sb3IoY29sb3JfbGluZWFyKGltcG9ydGFuY2VWYWx1ZSkpOw0KICAgICAgICBpZiAoaSAhPSAwKSB7DQogICAgICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCBjeCAtIDIsIDAsIDUsIGgsIGggLyAyLCAiZGl2aXNpb25fIiArIGN1ckVudFsnaWQnXSwgImVudGRpdmlzaW9uTGluZSIsICJyZ2IoMCwyNTAsMjUwKSIsIDUwLCAnJywgMCk7DQogICAgICAgIH0NCiAgICAgICAgaWYgKGRhdGFMaVtpXVsnaWQnXSA9PSBkYXRhWydpZCddKSBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCAwLCBlbmR4IC0gY3gtMiwgaCwgMSwgImVkaXRFbnRfIiArIGN1ckVudFsnaWQnXSwgImVkaXRFbnQiLCBlbnRDb2xvciwgMSwgInJnYmEoMjU1LDI1NSwyNTUsMSkiLCAxKS8vY29sb3JbX3RoaXMuY29sb3JNYXBbc29uWydpZCddXV0sIDUsIDAuMSkNCiAgICAgICAgZWxzZSBfdGhpcy5kcmF3UmVjdChzdmcsIGN4LCAwLCBlbmR4IC0gY3gtMiwgaCwgMSwgImVkaXRFbnRfIiArIGN1ckVudFsnaWQnXSwgImVkaXRFbnQiLCBlbnRDb2xvciwgMSwgInJnYmEoMjU1LDI1NSwyNTUsMSkiLCAzKS8vY29sb3JbX3RoaXMuY29sb3JNYXBbc29uWydpZCddXV0sIDUsIDAuMSkNCiAgICAgICAgcHJleCA9IGVuZHg7DQogICAgICB9DQogICAgICBEaXZpc2lvbkRhdGFMaXN0W0RpdmlzaW9uRGF0YUxpc3QubGVuZ3RoIC0gMV1bJ25leHRJZCddID0gIi0xIjsNCiAgICAgIF90aGlzLmVudERpdmlzaW9uRGF0YUxpc3QgPSBEaXZpc2lvbkRhdGFMaXN0Ow0KICAgIH0sDQogICAgZHJhd0VudGl0eU9yaShkYXRhKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcHN2ZyA9IGQzLnNlbGVjdCgiI2VudEciKTsNCiAgICAgIGxldCB3ID0gcHN2Zy5hdHRyKCJ3aWR0aCIpOw0KICAgICAgbGV0IGggPSBwc3ZnLmF0dHIoImhlaWdodCIpOw0KICAgICAgcHN2Zy5yZW1vdmUoKTsNCiAgICAgIGxldCBzdmcgPSBkMy5zZWxlY3QoIiNlZGl0RW50IikuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZW50RyIpLmF0dHIoIndpZHRoIiwgdykuYXR0cigiaGVpZ2h0IiwgaCk7DQogICAgICBsZXQgY29sb3JfbGluZWFyID0gX3RoaXMuaW1wb3J0YW5jZUNvbG9yX2xpbmVhcjsNCiAgICAgIGxldCBjb21wdXRlX2NvbG9yID0gX3RoaXMuaW1wb3J0YW5jZUNvbXB1dGVfY29sb3I7DQogICAgICBsZXQgdG90YWxEdXJhdGlvblZhbHVlID0gZGF0YVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgbGV0IHJTY2FsZSA9IF90aGlzLnRvdGFsRHVyYXRpb25TY2FsZV9saW5lYXI7DQogICAgICBsZXQgciA9IHJTY2FsZSh0b3RhbER1cmF0aW9uVmFsdWUpOw0KICAgICAgbGV0IG9EYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCB4ID0gc3ZnLmF0dHIoIndpZHRoIikgLyAyOw0KICAgICAgbGV0IHkgPSAxMjA7DQogICAgICBsZXQgaW1wb3J0YW5jZVZhbHVlID0gZGF0YVsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXTsNCiAgICAgIGxldCByZWxldmFuY2VWYWx1ZSA9IGRhdGFbJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsNCiAgICAgIHN2Zy5zZWxlY3RBbGwoKS5yZW1vdmUoKTsNCg0KICAgICAgaWYgKGRhdGFbJ3R5cGUnXSA9PSAnMScpIHsNCiAgICAgICAgbGV0IGFyZWEgPSB0b29scy5jYWxjVHJpYW5nbGUoeCwgeSwgcik7DQogICAgICAgIF90aGlzLmRyYXdUcmlhbmdsZShzdmcsICJyZ2IoMjUwLCAxOTksIDg4KSIsIGFyZWEsICJyZ2IoMjUwLCAxOTksIDg4KSIpOw0KICAgICAgfQ0KICAgICAgZWxzZSB7DQoNCiAgICAgICAgbGV0IGN5ID0geTsNCiAgICAgICAgbGV0IHRvdGFsRHVyYXRpb24gPSBfdGhpcy50b3RhbER1cmF0aW9uOw0KICAgICAgICBsZXQgdGltZUxpbmVTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgdG90YWxEdXJhdGlvbl0sIFt4IC0gciAqIE1hdGguc3FydCgzKSAvIDIsIHggKyByICogTWF0aC5zcXJ0KDMpIC8gMl0pDQogICAgICAgIGxldCB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgX3RoaXMubWF4RER1cmF0aW9uXSwgWzAsIHIgKiAoMSArIE1hdGguc3FydCgzKSAvIDIpXSkNCiAgICAgICAgbGV0IGNpcmNsZUNvbG9yID0gY29tcHV0ZV9jb2xvcihjb2xvcl9saW5lYXIoaW1wb3J0YW5jZVZhbHVlKSk7DQogICAgICAgIF90aGlzLmRyYXdDaXJjbGUoc3ZnLCB4LCBjeSwgciwgY2lyY2xlQ29sb3IsIGRhdGEsIDEsICJlbnRDaXJjbGUiLCAiZW50Q2lyY2xlXyIgKyBkYXRhWydpZCddKTsNCg0KICAgICAgICByID0gciAqIE1hdGguc3FydCgzKSAvIDI7DQogICAgICAgIHkgKz0gciAvIDI7DQogICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpOw0KDQoNCiAgICAgICAgcGF0aC5tb3ZlVG8oeCAtIHIsIHkpOw0KICAgICAgICBsZXQgbGluZUxpID0gW2RhdGFbJ3RpbWUnXV07DQogICAgICAgIGxldCBsaW5lUG9pbnQgPSBbeyAnaWQnOiBkYXRhWydpZCddLCAndGltZSc6IGRhdGFbJ3RpbWUnXSwgJ3gnOiAwLCAneSc6IDAgfV07DQogICAgICAgIGZvciAobGV0IHNyZWwgaW4gZGF0YVsic2ltaWxhcml0eVJlbCJdKSB7DQogICAgICAgICAgbGV0IGNkYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBkYXRhWyJzaW1pbGFyaXR5UmVsIl1bc3JlbF0gfSkNCiAgICAgICAgICBsaW5lTGkucHVzaChjZGF0YVsndGltZSddKQ0KICAgICAgICAgIGxpbmVQb2ludC5wdXNoKHsgJ2lkJzogY2RhdGFbJ2lkJ10sICd0aW1lJzogY2RhdGFbJ3RpbWUnXSwgJ3gnOiAwLCAneSc6IDAgfSkNCiAgICAgICAgfQ0KICAgICAgICBjb25zdCBzb3J0bXQgPSAoYSwgYikgPT4gew0KICAgICAgICAgIHJldHVybiB0b29scy50aW1lMnNlY29uZHMoYVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlswXSk7DQogICAgICAgIH0NCiAgICAgICAgY29uc3Qgc29ydGxwID0gKGEsIGIpID0+IHsNCiAgICAgICAgICByZXR1cm4gdG9vbHMudGltZTJzZWNvbmRzKGFbJ3RpbWUnXVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlsndGltZSddWzBdKTsNCiAgICAgICAgfQ0KICAgICAgICBsaW5lTGkgPSBsaW5lTGkuc29ydChzb3J0bXQpOw0KICAgICAgICBsaW5lUG9pbnQgPSBsaW5lUG9pbnQuc29ydChzb3J0bHApOw0KICAgICAgICBsZXQgbGluZURhdGEgPSBbW3ggLSByLCB5XV07DQogICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbGluZUxpLmxlbmd0aDsgdCsrKSB7DQogICAgICAgICAgbGV0IHN0YXJ0VCA9IGxpbmVMaVt0XVswXTsNCiAgICAgICAgICBsZXQgZW5kVCA9IGxpbmVMaVt0XVsxXTsNCiAgICAgICAgICBsZXQgc3RhcnRTID0gdG9vbHMudGltZTJzZWNvbmRzKHN0YXJ0VCk7DQogICAgICAgICAgbGV0IGVuZFMgPSB0b29scy50aW1lMnNlY29uZHMoZW5kVCk7DQogICAgICAgICAgbGV0IGR1cmF0aW9uID0gZW5kUyAtIHN0YXJ0UzsNCg0KICAgICAgICAgIGxldCBzdGFydHggPSB0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTIC0gZHVyYXRpb24gKiAxMCkpOw0KICAgICAgICAgIGxldCBlbmR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKGVuZFMgKyBkdXJhdGlvbiAqIDEwKSk7DQoNCiAgICAgICAgICBsZXQgc3RhcnR5ZiA9IHkgKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyA4Ow0KICAgICAgICAgIGxldCBzdGFydHlmMSA9IHkgKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyA4Ow0KICAgICAgICAgIGxldCBlbmR5ZiA9IHkgKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyA4Ow0KICAgICAgICAgIGxldCBlbmR5ZjEgPSB5ICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gODsNCiAgICAgICAgICBsZXQgeXogPSB5IC0gdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpOw0KICAgICAgICAgIGxldCBtaWR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKGVuZFMgKyBzdGFydFMpIC8gMik7DQogICAgICAgICAgbGluZVBvaW50W3RdWyd4J10gPSBtaWR4Ow0KICAgICAgICAgIGxpbmVQb2ludFt0XVsneSddID0geSAtIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcihkdXJhdGlvbikgLyAxLjc7DQogICAgICAgICAgbGV0IHkxID0geTsNCiAgICAgICAgICBpZiAoc3RhcnR4IDwgKGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdKSkgew0KICAgICAgICAgICAgaWYgKHQgPiAwKSB7DQogICAgICAgICAgICAgIGxpbmVEYXRhLnNwbGljZShsaW5lRGF0YS5sZW5ndGggLSAzLCAzKTsNCiAgICAgICAgICAgICAgc3RhcnR4ID0gKGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdICsgbWlkeCkgLyAyOw0KICAgICAgICAgICAgICB5MSA9IGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzFdICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gMjsNCiAgICAgICAgICAgICAgc3RhcnR5ZiA9IGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzFdICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gMjsNCiAgICAgICAgICAgICAgc3RhcnR5ZjEgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVsxXSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDI7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIGxldCBzdGFydHgxID0gc3RhcnR4ICsgKHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMgKyBkdXJhdGlvbikpIC0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKTsNCiAgICAgICAgICBsZXQgZW5keDEgPSBlbmR4IC0gKHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMgKyBkdXJhdGlvbikpIC0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKTsNCiAgICAgICAgICBsZXQgc3RhcnR4MiA9IHN0YXJ0eDEgKyAodGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyArIGR1cmF0aW9uKSkgLSB0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTKSkpOw0KICAgICAgICAgIGxldCBlbmR4MiA9IGVuZHgxIC0gKHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMgKyBkdXJhdGlvbikpIC0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKTsNCiAgICAgICAgICBpZiAoZW5keCA+IChyICsgeCkpIGVuZHggPSByICsgeDsNCiAgICAgICAgICBpZiAoc3RhcnR4MSA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHN0YXJ0eDEgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXTsNCiAgICAgICAgICBpZiAoZW5keDEgPiAociArIHgpKSBlbmR4MSA9IHIgKyB4Ow0KICAgICAgICAgIGlmIChzdGFydHgyIDwgKGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdKSkgc3RhcnR4MiA9IGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdOw0KICAgICAgICAgIGlmIChlbmR4MiA+IChyICsgeCkpIGVuZHgyID0gciArIHg7DQogICAgICAgICAgbGluZURhdGEucHVzaChbc3RhcnR4LCB5MV0sIFtzdGFydHgxLCBzdGFydHlmMV0sIFtzdGFydHgyLCBzdGFydHlmXSwgW21pZHgsIHl6XSwgW2VuZHgyLCBlbmR5Zl0sIFtlbmR4MSwgZW5keWYxXSwgW2VuZHgsIHldKQ0KICAgICAgICB9DQogICAgICAgIGxpbmVEYXRhLnB1c2goW3ggKyByLCB5XSkNCiAgICAgICAgbGV0IGN1cnZlX2dlbmVyYXRvciA9IGQzLmxpbmUoKQ0KICAgICAgICAgIC54KChkKSA9PiBkWzBdKQ0KICAgICAgICAgIC55KChkKSA9PiB7DQogICAgICAgICAgICBsZXQgaCA9IE1hdGguc3FydChNYXRoLnBvdyhyLCAyKSAtIE1hdGgucG93KChkWzBdIC0gKHggLSByKSksIDIpKTsNCiAgICAgICAgICAgIGlmICgoeSAtIGRbMV0pID4gKGggKyByICogTWF0aC5zcXJ0KDMpIC8gMikpDQogICAgICAgICAgICAgIHJldHVybiB5IC0gKGggKyByICogTWF0aC5zcXJ0KDMpIC8gMikgKyAyOw0KICAgICAgICAgICAgcmV0dXJuIGRbMV07DQogICAgICAgICAgfSkNCiAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgY3VydmVfZ2VuZXJhdG9yKGxpbmVEYXRhKSwgIndoaXRlIiwgMiwgJzAnLCAnc29uTGluZSAnLCAnc29uTGluZSAnKTsNCg0KDQogICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbGluZVBvaW50Lmxlbmd0aDsgcCsrKSB7DQogICAgICAgICAgX3RoaXMuZHJhd0NpcmNsZShzdmcsIGxpbmVQb2ludFtwXVsneCddLCBsaW5lUG9pbnRbcF1bJ3knXSwgNSwgInJlZCIsIGxpbmVQb2ludFtwXSwgMCwgImxpbmVQb2ludCIsICJsaW5lUG9pbnRfIiArIGxpbmVQb2ludFtwXVsnaWQnXSk7DQogICAgICAgIH0NCg0KICAgICAgICAvLyAiMSI6ICJyZ2IoMTQ1LCAyMDQsIDExNykiLA0KICAgICAgICAvLyAgICIyIjogInJnYig4NCwgMTEyLCAxOTgpIiwNCiAgICAgICAgLy8gICAiMyI6ICJyZ2IoMjM4LCAxMDIsIDEwMikiLA0KICAgICAgICBsZXQgdHlwZUNvbG9yID0gew0KICAgICAgICAgICIxIjogIiNmZjljOWMiLA0KICAgICAgICAgICIyIjogIiNmNGY0ZDAiLA0KICAgICAgICAgICIzIjogIiM2ZjhiZTAiLA0KICAgICAgICB9Ow0KICAgICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHMoZGF0YVsndGltZSddWzBdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyhkYXRhWyd0aW1lJ11bMV0pOw0KICAgICAgICBsZXQgdHlwZURhdGEgPSBkYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXTsNCiAgICAgICAgbGV0IHNvbkxpc3QgPSBkYXRhWydzb24nXTsNCiAgICAgICAgbGV0IHR5cGVBcmNTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgZHVyYXRpb25dLCBbMCwgTWF0aC5QSSAqIDJdKTsNCg0KICAgICAgICB2YXIgdHlwZVN0YXJ0UiA9IDAvL01hdGguUEkvNDsNCg0KICAgICAgICB2YXIgdHlwZVN0ZXBSID0gTWF0aC5QSSAvIDE7DQoNCiAgICAgICAgaWYgKHNvbkxpc3QubGVuZ3RoID4gMCkgew0KICAgICAgICAgIGZvciAobGV0IGkgaW4gdHlwZURhdGEpIHsNCiAgICAgICAgICAgIGxldCBjb2xvciA9IHR5cGVDb2xvcltpXTsNCiAgICAgICAgICAgIGxldCB0eXBlRHVyaXRpb24gPSB0eXBlRGF0YVtpXTsNCiAgICAgICAgICAgIGxldCB0b3RhbFR5cGVTZWNvbmRzID0gMDsNCiAgICAgICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgICAgIHRvdGFsVHlwZVNlY29uZHMgKz0gKHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVswXSkpDQogICAgICAgICAgICB9DQogICAgICAgICAgICBsZXQgdHlwZVN0ZXBSID0gdHlwZUFyY1NjYWxlX2xpbmVhcih0b3RhbFR5cGVTZWNvbmRzKS8vTWF0aC5QSS8yOw0KDQogICAgICAgICAgICBsZXQgZW5kQW5nbGV0ID0gdHlwZVN0YXJ0UiArIDEgKiB0eXBlU3RlcFINCiAgICAgICAgICAgIHZhciBkYXRhc2V0ID0geyBzdGFydEFuZ2xlOiB0eXBlU3RhcnRSLCBlbmRBbmdsZTogZW5kQW5nbGV0IH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQogICAgICAgICAgICB0eXBlU3RhcnRSID0gZW5kQW5nbGV0Ow0KICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgICAgICAuaW5uZXJSYWRpdXMociArIDEwKQ0KICAgICAgICAgICAgICAub3V0ZXJSYWRpdXMociArIDI1KTsNCiAgICAgICAgICAgIHZhciBwYXRoQXJjID0gYXJjUGF0aChkYXRhc2V0KTsNCiAgICAgICAgICAgIF90aGlzLmRyYXdBcmMoc3ZnLCB4LCB5IC0gciAvIDIsIHBhdGhBcmMsIGNvbG9yLCBjb2xvciwgJ3R5cGUgZicgKyBkYXRhWydpZCddICsgIiB0IiArIGkpOw0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgc29uVG90YWwgPSAwOw0KICAgICAgICAgIGxldCBzb25OdW0gPSAwDQogICAgICAgICAgZm9yIChsZXQgcyBpbiBzb25MaXN0KSB7DQogICAgICAgICAgICBsZXQgc29uRGF0YSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29uTGlzdFtzXSB9KTsNCiAgICAgICAgICAgIGxldCBzb25EdXIgPSBzb25EYXRhWyd0b3RhbER1cmF0aW9uJ107DQogICAgICAgICAgICBzb25Ub3RhbCArPSBzb25EdXI7DQogICAgICAgICAgICBzb25OdW0gKz0gMTsNCiAgICAgICAgICB9DQogICAgICAgICAgbGV0IHNraXBBcmMgPSBNYXRoLlBJIC8gKHNvbk51bSArIDIpOw0KICAgICAgICAgIGxldCB0aW1lU29uTGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHNvblRvdGFsXSwgWzAsIE1hdGguUEkgKiAyIC0gc2tpcEFyYyAqIHNvbk51bV0pOw0KICAgICAgICAgIGxldCB0aW1lU29uSGVpZ2hMaW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgc29uVG90YWxdLCBbNDAsIDQwXSk7DQoNCiAgICAgICAgICBsZXQgdGltZVNvbkNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBzb25Ub3RhbF0pLnJhbmdlKFswLCAxXSk7DQogICAgICAgICAgbGV0IHRpbWVTb25Db21wdXRlX2NvbG9yID0gZDMuaW50ZXJwb2xhdGUoIndoaXRlIiwgY2lyY2xlQ29sb3IpOw0KICAgICAgICAgIHZhciBzb25TdGFydFIgPSAwOy8vLU1hdGguUEkvMjsNCiAgICAgICAgICBmb3IgKGxldCBzIGluIHNvbkxpc3QpIHsNCiAgICAgICAgICAgIGxldCBzb25EYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb25MaXN0W3NdIH0pOw0KICAgICAgICAgICAgbGV0IHNvbkR1ciA9IHNvbkRhdGFbJ3RvdGFsRHVyYXRpb24nXTsNCg0KICAgICAgICAgICAgbGV0IHNvblN0ZXBSID0gdGltZVNvbkxpbmVhcihzb25EdXIpLy9NYXRoLlBJLzI7DQoNCiAgICAgICAgICAgIGxldCBlbmRBbmdsZXQgPSBzb25TdGFydFIgKyBzb25TdGVwUjsNCiAgICAgICAgICAgIHZhciBkYXRhc2V0ID0geyBzdGFydEFuZ2xlOiBzb25TdGFydFIsIGVuZEFuZ2xlOiBlbmRBbmdsZXQgfTsgLy/liJvlu7rkuIDkuKrlvKfnlJ/miJDlmagNCiAgICAgICAgICAgIHNvblN0YXJ0UiA9IGVuZEFuZ2xldDsNCiAgICAgICAgICAgIGxldCBjb2xvciA9ICdibHVlJzsNCiAgICAgICAgICAgIHZhciBhcmNQYXRoID0gZDMuYXJjKCkNCiAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKHIgKyAyOCkNCiAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKHIgKyB0aW1lU29uSGVpZ2hMaW5lYXIoc29uRHVyKSk7DQogICAgICAgICAgICB2YXIgYXJjTWlkUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKQ0KICAgICAgICAgICAgICAub3V0ZXJSYWRpdXMociArIDMyKTsNCiAgICAgICAgICAgIHZhciBwYXRoQXJjID0gYXJjUGF0aChkYXRhc2V0KTsNCg0KICAgICAgICAgICAgZW5kQW5nbGV0ID0gc29uU3RhcnRSICsgc2tpcEFyYzsNCiAgICAgICAgICAgIHZhciBtaWREYXRhc2V0ID0geyBzdGFydEFuZ2xlOiBzb25TdGFydFIsIGVuZEFuZ2xlOiBlbmRBbmdsZXQgfTsgLy/liJvlu7rkuIDkuKrlvKfnlJ/miJDlmagNCg0KICAgICAgICAgICAgbGV0IGppYW50b3VQYXRoID0gZDMucGF0aCgpOw0KICAgICAgICAgICAgamlhbnRvdVBhdGguYXJjKHgsIHkgLSByIC8gMiwgciArIDMyLCBzb25TdGFydFIgLSBNYXRoLlBJIC8gMiwgZW5kQW5nbGV0IC0gTWF0aC5QSSAvIDIpOw0KDQogICAgICAgICAgICBzb25TdGFydFIgKz0gc2tpcEFyYzsNCiAgICAgICAgICAgIHZhciBwYXRoTWlkQXJjID0gYXJjTWlkUGF0aChtaWREYXRhc2V0KTsNCiAgICAgICAgICAgIGxldCB0aW1lU29uQ29sb3IgPSBjb21wdXRlX2NvbG9yKGNvbG9yX2xpbmVhcihzb25EYXRhWydhdHRyaWJ1dGUnXVsnaW1wb3J0YW5jZSddKSk7DQogICAgICAgICAgICBfdGhpcy5kcmF3QXJjKHN2ZywgeCwgeSAtIHIgLyAyLCBwYXRoQXJjLCB0aW1lU29uQ29sb3IsIHRpbWVTb25Db2xvciwgJ3NvbiBmJyArIGRhdGFbJ2lkJ10gKyAiIHMiICsgc29uTGlzdFtzXSwgJzAnKTsNCiAgICAgICAgICAgIGlmIChzICE9IHNvbkxpc3QubGVuZ3RoIC0gMSkgew0KICAgICAgICAgICAgICBfdGhpcy5kcmF3VGltZUxpbmUoc3ZnLCBqaWFudG91UGF0aCwgInJnYigyMDAsMjAwLDIwMCkiLCAzLCAnOSw1JywgJ21pZEFyYyAnLCAnbWlkQXJjICcpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCg0KICAgICAgICB9DQoNCg0KICAgICAgfQ0KICAgICAgbGV0IHR4dHMgPSBfdGhpcy5uYW1laW5wdXQuc3BsaXQoIiAiKQ0KICAgICAgX3RoaXMuZHJhd1R4dChzdmcsIHggLSByIC0gMzIsIHkgKyByICsgNTAsIHIgKiAyICsgNjQsIHR4dHMsICJncmV5Iik7DQogICAgfSwNCiAgICBkcmF3RW50aXR5KGRhdGEpIHsNCiAgICAgIC8vIGQzLnNlbGVjdCgiI2VkaXRFbnQiKS5yZW1vdmUoKQ0KICAgIH0sDQogICAgLy8gZHJhd0VudGl0eShkYXRhKSB7DQogICAgLy8gICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgLy8gICBsZXQgcHN2ZyA9IGQzLnNlbGVjdCgiI2VudEciKTsNCiAgICAvLyAgIGxldCB3ID0gcHN2Zy5hdHRyKCJ3aWR0aCIpOw0KICAgIC8vICAgbGV0IGggPSBwc3ZnLmF0dHIoImhlaWdodCIpOw0KICAgIC8vICAgcHN2Zy5yZW1vdmUoKTsNCiAgICAvLyAgIGxldCBzdmcgPSBkMy5zZWxlY3QoIiNlZGl0RW50IikuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZW50RyIpLmF0dHIoIndpZHRoIiwgdykuYXR0cigiaGVpZ2h0IiwgaCk7DQogICAgLy8gICBsZXQgY29sb3JfbGluZWFyID0gX3RoaXMuaW1wb3J0YW5jZUNvbG9yX2xpbmVhcjsNCiAgICAvLyAgIGxldCBjb21wdXRlX2NvbG9yID0gX3RoaXMuaW1wb3J0YW5jZUNvbXB1dGVfY29sb3I7DQogICAgLy8gICBsZXQgdG90YWxEdXJhdGlvblZhbHVlID0gZGF0YVsndG90YWxEdXJhdGlvbiddOw0KICAgIC8vICAgbGV0IHJTY2FsZSA9IF90aGlzLnRvdGFsRHVyYXRpb25TY2FsZV9saW5lYXI7DQogICAgLy8gICBsZXQgciA9IHJTY2FsZSh0b3RhbER1cmF0aW9uVmFsdWUpOw0KICAgIC8vICAgbGV0IG9EYXRhID0gX3RoaXMuZGF0YTsNCiAgICAvLyAgIGxldCB4ID0gc3ZnLmF0dHIoIndpZHRoIikgLyAyOw0KICAgIC8vICAgbGV0IHkgPSAxMjA7DQogICAgLy8gICBsZXQgaW1wb3J0YW5jZVZhbHVlID0gZGF0YVsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXTsNCiAgICAvLyAgIGxldCByZWxldmFuY2VWYWx1ZSA9IGRhdGFbJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsNCiAgICAvLyAgIHN2Zy5zZWxlY3RBbGwoKS5yZW1vdmUoKTsNCg0KICAgIC8vICAgaWYgKGRhdGFbJ3R5cGUnXSA9PSAnMScpIHsNCiAgICAvLyAgICAgbGV0IGFyZWEgPSB0b29scy5jYWxjVHJpYW5nbGUoeCwgeSwgcik7DQogICAgLy8gICAgIF90aGlzLmRyYXdUcmlhbmdsZShzdmcsICJyZ2IoMjUwLCAxOTksIDg4KSIsIGFyZWEsICJyZ2IoMjUwLCAxOTksIDg4KSIpOw0KICAgIC8vICAgfQ0KICAgIC8vICAgZWxzZSB7DQoNCiAgICAvLyAgICAgbGV0IGN5ID0geTsNCiAgICAvLyAgICAgbGV0IHRvdGFsRHVyYXRpb24gPSBfdGhpcy50b3RhbER1cmF0aW9uOw0KICAgIC8vICAgICBsZXQgdGltZUxpbmVTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgdG90YWxEdXJhdGlvbl0sIFt4IC0gciAqIE1hdGguc3FydCgzKSAvIDIsIHggKyByICogTWF0aC5zcXJ0KDMpIC8gMl0pDQogICAgLy8gICAgIGxldCB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgX3RoaXMubWF4RER1cmF0aW9uXSwgWzAsIHIgKiAoMSArIE1hdGguc3FydCgzKSAvIDIpXSkNCiAgICAvLyAgICAgbGV0IGNpcmNsZUNvbG9yID0gY29tcHV0ZV9jb2xvcihjb2xvcl9saW5lYXIoaW1wb3J0YW5jZVZhbHVlKSk7DQogICAgLy8gICAgIF90aGlzLmRyYXdDaXJjbGUoc3ZnLCB4LCBjeSwgciwgY2lyY2xlQ29sb3IsIGRhdGEsIDEsICJlbnRDaXJjbGUiLCAiZW50Q2lyY2xlXyIgKyBkYXRhWydpZCddKTsNCg0KICAgIC8vICAgICByID0gciAqIE1hdGguc3FydCgzKSAvIDI7DQogICAgLy8gICAgIHkgKz0gciAvIDI7DQogICAgLy8gICAgIGxldCBwYXRoID0gZDMucGF0aCgpOw0KDQoNCiAgICAvLyAgICAgcGF0aC5tb3ZlVG8oeCAtIHIsIHkpOw0KICAgIC8vICAgICBsZXQgbGluZUxpID0gW2RhdGFdOw0KICAgIC8vICAgICBsZXQgbGluZVBvaW50ID0gW3sgJ2lkJzogZGF0YVsnaWQnXSwgJ3RpbWUnOiBkYXRhWyd0aW1lJ10sICd4JzogMCwgJ3knOiAwIH1dOw0KICAgIC8vICAgICBsZXQgamdpZEwgPSBbZGF0YVsnaWQnXV07DQogICAgLy8gICAgIGxldCBzaW1pbGFyaXR5UmVsc2xpID0gW2RhdGFbInNpbWlsYXJpdHlSZWwiXV07DQogICAgLy8gICAgIHdoaWxlKHNpbWlsYXJpdHlSZWxzbGkubGVuZ3RoPjApew0KICAgIC8vICAgICAgIGxldCBzaW1pbGFyaXR5UmVscyA9IHNpbWlsYXJpdHlSZWxzbGlbMF07DQogICAgLy8gICAgICAgc2ltaWxhcml0eVJlbHNsaS5zcGxpY2UoMCwxKTsNCiAgICAvLyAgICAgICBsZXQgamcgPSAwOw0KICAgIC8vICAgICAgIGZvciAobGV0IHNyZWwgaW4gc2ltaWxhcml0eVJlbHMpIHsNCiAgICAvLyAgICAgICAgIGxldCBjZGF0YSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc2ltaWxhcml0eVJlbHNbc3JlbF0gfSk7DQogICAgLy8gICAgICAgICBpZihqZ2lkTC5pbmRleE9mKGNkYXRhWydpZCddKT09LTEpew0KICAgIC8vICAgICAgICAgICBzaW1pbGFyaXR5UmVsc2xpLnB1c2goY2RhdGFbInNpbWlsYXJpdHlSZWwiXSkNCiAgICAvLyAgICAgICAgICAgamc9MTsNCiAgICAvLyAgICAgICAgICAgbGluZUxpLnB1c2goY2RhdGEpDQogICAgLy8gICAgICAgICAgIGpnaWRMLnB1c2goY2RhdGFbJ2lkJ10pDQogICAgLy8gICAgICAgICAgIGxpbmVQb2ludC5wdXNoKHsgJ2lkJzogY2RhdGFbJ2lkJ10sICd0aW1lJzogY2RhdGFbJ3RpbWUnXSwgJ3gnOiAwLCAneSc6IDAgfSkNCiAgICAvLyAgICAgICAgIH0NCiAgICAvLyAgICAgICB9DQogICAgLy8gICAgICAgLy8gaWYoamc9PTApew0KICAgIC8vICAgICAgICAgLy8gYnJlYWs7DQogICAgLy8gICAgICAgLy8gfQ0KICAgIC8vICAgICB9DQogICAgICAgIA0KICAgIC8vICAgICBjb25zdCBzb3J0bXQgPSAoYSwgYikgPT4gew0KICAgIC8vICAgICAgIHJldHVybiB0b29scy50aW1lMnNlY29uZHMoYVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlswXSk7DQogICAgLy8gICAgIH0NCiAgICAvLyAgICAgY29uc3Qgc29ydGxwID0gKGEsIGIpID0+IHsNCiAgICAvLyAgICAgICByZXR1cm4gdG9vbHMudGltZTJzZWNvbmRzKGFbJ3RpbWUnXVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlsndGltZSddWzBdKTsNCiAgICAvLyAgICAgfQ0KICAgIC8vICAgICBjb25zb2xlLmxvZyhsaW5lTGkpOw0KICAgIC8vICAgICBsaW5lTGkgPSBsaW5lTGkuc29ydChzb3J0bHApOw0KICAgIC8vICAgICBsaW5lUG9pbnQgPSBsaW5lUG9pbnQuc29ydChzb3J0bHApOw0KICAgIC8vICAgICBsZXQgbGluZURhdGEgPSBbW3ggLSByICogTWF0aC5zcXJ0KDMpLzItNCAsIHldXTsNCiAgICAvLyAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBsaW5lTGkubGVuZ3RoOyB0KyspIHsNCiAgICAvLyAgICAgICBsZXQgc3RhcnRUID0gbGluZUxpW3RdWyd0aW1lJ11bMF07DQogICAgLy8gICAgICAgbGV0IGR1cmF0aW9uID1saW5lTGlbdF1bJ3RvdGFsRHVyYXRpb24nXQ0KICAgIC8vICAgICAgIC8vIGxldCBlbmRUID0gbGluZUxpW3RdWyd0aW1lJ11bMV07DQogICAgLy8gICAgICAgbGV0IHN0YXJ0UyA9IHRvb2xzLnRpbWUyc2Vjb25kcyhzdGFydFQpOw0KICAgIC8vICAgICAgIGxldCBlbmRTID0gc3RhcnRTICtkdXJhdGlvbjsNCiAgICAvLyAgICAgICAvLyBsZXQgc3RhcnR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyAtIGR1cmF0aW9uICogMTApKTsNCiAgICAvLyAgICAgICAvLyBsZXQgZW5keCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTICsgZHVyYXRpb24gKiAxMCkpOw0KICAgIC8vICAgICAgIGxldCBsaW1zdCA9ICh4IC0gciAqIE1hdGguc3FydCgzKSAvIDIpOw0KICAgIC8vICAgICAgIGxldCBsaW1lZCA9ICh4ICsgciAqIE1hdGguc3FydCgzKSAvIDIpOw0KICAgIC8vICAgICAgIGxldCBzdGFydHggPSAobGltc3Q8dGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKT8odGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKToobGltc3QpOw0KICAgIC8vICAgICAgIGxldCBlbmR4ID0gKGxpbWVkPnRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTKSkpPyh0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUykpKToobGltZWQpOw0KICAgIC8vICAgICAgIC8vIGxldCBtaWR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKGVuZFMgKyBzdGFydFMpIC8gMik7DQogICAgLy8gICAgICAgbGV0IG1pZHggPSAoc3RhcnR4K2VuZHgpIC8gMjsNCiAgICAvLyAgICAgICBsZXQgeXMgPSB5Ow0KICAgIC8vICAgICAgIGxldCB5eiA9IHkgLSB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSk7DQogICAgLy8gICAgICAgbGluZVBvaW50W3RdWyd4J10gPSBtaWR4Ow0KICAgIC8vICAgICAgIGxpbmVQb2ludFt0XVsneSddID0geSAtIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcihkdXJhdGlvbikgLyAxLjc7DQogICAgLy8gICAgICAgLy8gaWYgKHN0YXJ0eCA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHsNCiAgICAvLyAgICAgICAgIGlmICh0ID4gMCkgew0KICAgIC8vICAgICAgICAgICBsaW5lRGF0YS5zcGxpY2UobGluZURhdGEubGVuZ3RoIC0gMSwgMSk7DQogICAgLy8gICAgICAgICAgIG1pZHgrPXQqNTsNCiAgICAvLyAgICAgICAgICAgc3RhcnR4ID0gbWlkeC0oKG1pZHgtKGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdICsgbWlkeCkgLyAyKSkvMjsNCiAgICAvLyAgICAgICAgICAgZW5keCs9dCo1Ow0KICAgIC8vICAgICAgICAgICB5cyA9IHkrKHktbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMV0pLzMNCiAgICAvLyAgICAgICAgIH0NCiAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKHlzKQ0KICAgIC8vICAgICAgIC8vIH0NCiAgICAvLyAgICAgICBsaW5lRGF0YS5wdXNoKFtzdGFydHgsIHlzXSxbbWlkeCwgeXpdLFtlbmR4LCB5XSl9DQogICAgLy8gICAgIGxpbmVEYXRhLnB1c2goW3ggKyByLCB5XSkNCiAgICAvLyAgICAgbGV0IGN1cnZlX2dlbmVyYXRvciA9IGQzLmxpbmUoKQ0KICAgIC8vICAgICAgIC54KChkKSA9PiBkWzBdKQ0KICAgIC8vICAgICAgIC55KChkKSA9PiB7DQogICAgLy8gICAgICAgICBsZXQgaCA9IE1hdGguc3FydChNYXRoLnBvdyhyLCAyKSAtIE1hdGgucG93KChkWzBdIC0gKHggLSByKSksIDIpKTsNCiAgICAvLyAgICAgICAgIGlmICgoeSAtIGRbMV0pID4gKGggKyByICogTWF0aC5zcXJ0KDMpIC8gMikpDQogICAgLy8gICAgICAgICAgIHJldHVybiB5IC0gKGggKyByICogTWF0aC5zcXJ0KDMpIC8gMikgKyAyOw0KICAgIC8vICAgICAgICAgcmV0dXJuIGRbMV07DQogICAgLy8gICAgICAgfSkNCiAgICAvLyAgICAgICAuY3VydmUoZDMuY3VydmVCdW5kbGUgKQ0KICAgIC8vICAgICAgIC8vIC5jdXJ2ZShkMy5jdXJ2ZUNhdG11bGxSb20gICkNCiAgICAvLyAgICAgICAvLyAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAvLyAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgY3VydmVfZ2VuZXJhdG9yKGxpbmVEYXRhKSwgIndoaXRlIiwgMiwgJzAnLCAnc29uTGluZSAnLCAnc29uTGluZSAnKTsNCg0KDQogICAgLy8gICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbGluZVBvaW50Lmxlbmd0aDsgcCsrKSB7DQogICAgLy8gICAgICAgX3RoaXMuZHJhd0NpcmNsZShzdmcsIGxpbmVQb2ludFtwXVsneCddLCBsaW5lUG9pbnRbcF1bJ3knXSwgNSwgInJlZCIsIGxpbmVQb2ludFtwXSwgMCwgImxpbmVQb2ludCIsICJsaW5lUG9pbnRfIiArIGxpbmVQb2ludFtwXVsnaWQnXSk7DQogICAgLy8gICAgIH0NCg0KICAgIC8vICAgICAvLyAiMSI6ICJyZ2IoMTQ1LCAyMDQsIDExNykiLA0KICAgIC8vICAgICAvLyAgICIyIjogInJnYig4NCwgMTEyLCAxOTgpIiwNCiAgICAvLyAgICAgLy8gICAiMyI6ICJyZ2IoMjM4LCAxMDIsIDEwMikiLA0KICAgIC8vICAgICBsZXQgdHlwZUNvbG9yID0gew0KICAgIC8vICAgICAgICIxIjogIiNmZjljOWMiLA0KICAgIC8vICAgICAgICIyIjogIiNmNGY0ZDAiLA0KICAgIC8vICAgICAgICIzIjogIiM2ZjhiZTAiLA0KICAgIC8vICAgICB9Ow0KICAgIC8vICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHMoZGF0YVsndGltZSddWzBdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyhkYXRhWyd0aW1lJ11bMV0pOw0KICAgIC8vICAgICBsZXQgdHlwZURhdGEgPSBkYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXTsNCiAgICAvLyAgICAgbGV0IHNvbkxpc3QgPSBkYXRhWydzb24nXTsNCiAgICAvLyAgICAgbGV0IHNvbnMgPSBbc29uTGlzdF07DQogICAgLy8gICAgIHdoaWxlIChzb25zLmxlbmd0aCA+IDApIHsNCiAgICAvLyAgICAgICBsZXQgY3VyU29uTGlzdCA9IHNvbnNbMF07DQogICAgLy8gICAgICAgc29ucy5zcGxpY2UoMCwgMSk7DQogICAgLy8gICAgICAgaWYgKGN1clNvbkxpc3QubGVuZ3RoID4gMCkgew0KICAgIC8vICAgICAgICAgZm9yIChsZXQgcyBpbiBjdXJTb25MaXN0KSB7DQogICAgLy8gICAgICAgICAgIGxldCBzb25EYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBjdXJTb25MaXN0W3NdIH0pOw0KICAgIC8vICAgICAgICAgICBsZXQgc29uVHlwZURhdGEgPSBzb25EYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXTsNCg0KICAgIC8vICAgICAgICAgICBmb3IgKGxldCB0IGluIHNvblR5cGVEYXRhKSB7DQogICAgLy8gICAgICAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHNvblR5cGVEYXRhW3RdOw0KICAgIC8vICAgICAgICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgLy8gICAgICAgICAgICAgICAgdHlwZURhdGFbdF0ucHVzaCh0eXBlRHVyaXRpb25bZF0pDQogICAgLy8gICAgICAgICAgICAgfQ0KICAgIC8vICAgICAgICAgICB9DQogICAgLy8gICAgICAgICAgIHNvbnMucHVzaChzb25EYXRhWydzb24nXSk7DQogICAgLy8gICAgICAgICB9DQogICAgLy8gICAgICAgfQ0KICAgIC8vICAgICB9DQogICAgLy8gICAgIHZhciB0eXBlU3RhcnRSID0gMC8vTWF0aC5QSS80Ow0KDQogICAgLy8gICAgIHZhciB0eXBlU3RlcFIgPSBNYXRoLlBJIC8gMTsNCg0KICAgIC8vICAgICBpZiAoc29uTGlzdC5sZW5ndGggPiAwKSB7DQogICAgLy8gICAgICAgbGV0IHR5cGVUb3RhbER1ciA9IDA7DQogICAgLy8gICAgICAgZm9yIChsZXQgdCBpbiB0eXBlRGF0YSkgew0KICAgIC8vICAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHR5cGVEYXRhW3RdOw0KICAgIC8vICAgICAgICAgZm9yIChsZXQgZCBpbiB0eXBlRHVyaXRpb24pIHsNCiAgICAvLyAgICAgICAgICAgdHlwZVRvdGFsRHVyICs9ICh0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMF0pKQ0KICAgIC8vICAgICAgICAgfQ0KICAgIC8vICAgICAgIH0NCiAgICAvLyAgICAgICBsZXQgdHlwZUFyY1NjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCB0eXBlVG90YWxEdXJdLCBbMCwgTWF0aC5QSSAqIDJdKTsNCiAgICAvLyAgICAgICBmb3IgKGxldCBpIGluIHR5cGVEYXRhKSB7DQogICAgLy8gICAgICAgICBsZXQgY29sb3IgPSB0eXBlQ29sb3JbaV07DQogICAgLy8gICAgICAgICBsZXQgdHlwZUR1cml0aW9uID0gdHlwZURhdGFbaV07DQogICAgLy8gICAgICAgICBsZXQgdG90YWxUeXBlU2Vjb25kcyA9IDA7DQogICAgLy8gICAgICAgICBmb3IgKGxldCBkIGluIHR5cGVEdXJpdGlvbikgew0KICAgIC8vICAgICAgICAgICB0b3RhbFR5cGVTZWNvbmRzICs9ICh0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzFdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMF0pKQ0KICAgIC8vICAgICAgICAgfQ0KICAgIC8vICAgICAgICAgaWYodG90YWxUeXBlU2Vjb25kcz4wKQ0KICAgIC8vICAgICAgICAge2xldCB0eXBlU3RlcFIgPSB0eXBlQXJjU2NhbGVfbGluZWFyKHRvdGFsVHlwZVNlY29uZHMpLy9NYXRoLlBJLzI7DQoNCiAgICAvLyAgICAgICAgIGxldCBlbmRBbmdsZXQgPSB0eXBlU3RhcnRSICsgMSAqIHR5cGVTdGVwUg0KICAgIC8vICAgICAgICAgdmFyIGRhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHR5cGVTdGFydFIsIGVuZEFuZ2xlOiBlbmRBbmdsZXQgfTsgLy/liJvlu7rkuIDkuKrlvKfnlJ/miJDlmagNCiAgICAvLyAgICAgICAgIHR5cGVTdGFydFIgPSBlbmRBbmdsZXQ7DQogICAgLy8gICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgLy8gICAgICAgICAgIC5pbm5lclJhZGl1cyhyICsgMTApDQogICAgLy8gICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgMjUpOw0KICAgIC8vICAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KICAgIC8vICAgICAgICAgX3RoaXMuZHJhd0FyYyhzdmcsIHgsIHkgLSByIC8gMiwgcGF0aEFyYywgY29sb3IsIGNvbG9yLCAndHlwZSBmJyArIGRhdGFbJ2lkJ10gKyAiIHQiICsgaSk7fQ0KICAgIC8vICAgICAgIH0NCg0KICAgIC8vICAgICAgIGxldCBzb25Ub3RhbCA9IDA7DQogICAgLy8gICAgICAgbGV0IHNvbk51bSA9IDANCiAgICAvLyAgICAgICBmb3IgKGxldCBzIGluIHNvbkxpc3QpIHsNCiAgICAvLyAgICAgICAgIGxldCBzb25EYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb25MaXN0W3NdIH0pOw0KICAgIC8vICAgICAgICAgbGV0IHNvbkR1ciA9IHNvbkRhdGFbJ3RvdGFsRHVyYXRpb24nXTsNCiAgICAvLyAgICAgICAgIHNvblRvdGFsICs9IHNvbkR1cjsNCiAgICAvLyAgICAgICAgIHNvbk51bSArPSAxOw0KICAgIC8vICAgICAgIH0NCiAgICAvLyAgICAgICBsZXQgc2tpcEFyYyA9IE1hdGguUEkgLyAoc29uTnVtICsgMik7DQogICAgLy8gICAgICAgbGV0IHRpbWVTb25MaW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgc29uVG90YWxdLCBbMCwgTWF0aC5QSSAqIDIgLSBza2lwQXJjICogc29uTnVtXSk7DQogICAgLy8gICAgICAgbGV0IHRpbWVTb25IZWlnaExpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBzb25Ub3RhbF0sIFs0MCwgNDBdKTsNCg0KICAgIC8vICAgICAgIGxldCB0aW1lU29uQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIHNvblRvdGFsXSkucmFuZ2UoWzAsIDFdKTsNCiAgICAvLyAgICAgICBsZXQgdGltZVNvbkNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZSgid2hpdGUiLCBjaXJjbGVDb2xvcik7DQogICAgLy8gICAgICAgdmFyIHNvblN0YXJ0UiA9IDA7Ly8tTWF0aC5QSS8yOw0KICAgIC8vICAgICAgIGZvciAobGV0IHMgaW4gc29uTGlzdCkgew0KICAgIC8vICAgICAgICAgbGV0IHNvbkRhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNvbkxpc3Rbc10gfSk7DQogICAgLy8gICAgICAgICBsZXQgc29uRHVyID0gc29uRGF0YVsndG90YWxEdXJhdGlvbiddOw0KDQogICAgLy8gICAgICAgICBsZXQgc29uU3RlcFIgPSB0aW1lU29uTGluZWFyKHNvbkR1cikvL01hdGguUEkvMjsNCg0KICAgIC8vICAgICAgICAgbGV0IGVuZEFuZ2xldCA9IHNvblN0YXJ0UiArIHNvblN0ZXBSOw0KICAgIC8vICAgICAgICAgdmFyIGRhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHNvblN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgIC8vICAgICAgICAgc29uU3RhcnRSID0gZW5kQW5nbGV0Ow0KICAgIC8vICAgICAgICAgbGV0IGNvbG9yID0gJ2JsdWUnOw0KICAgIC8vICAgICAgICAgdmFyIGFyY1BhdGggPSBkMy5hcmMoKQ0KICAgIC8vICAgICAgICAgICAuaW5uZXJSYWRpdXMociArIDI4KQ0KICAgIC8vICAgICAgICAgICAub3V0ZXJSYWRpdXMociArIHRpbWVTb25IZWlnaExpbmVhcihzb25EdXIpKTsNCiAgICAvLyAgICAgICAgIHZhciBhcmNNaWRQYXRoID0gZDMuYXJjKCkNCiAgICAvLyAgICAgICAgICAgLmlubmVyUmFkaXVzKDApDQogICAgLy8gICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgMzIpOw0KICAgIC8vICAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KDQogICAgLy8gICAgICAgICBlbmRBbmdsZXQgPSBzb25TdGFydFIgKyBza2lwQXJjOw0KICAgIC8vICAgICAgICAgdmFyIG1pZERhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHNvblN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KDQogICAgLy8gICAgICAgICBsZXQgamlhbnRvdVBhdGggPSBkMy5wYXRoKCk7DQogICAgLy8gICAgICAgICBqaWFudG91UGF0aC5hcmMoeCwgeSAtIHIgLyAyLCByICsgMzIsIHNvblN0YXJ0UiAtIE1hdGguUEkgLyAyLCBlbmRBbmdsZXQgLSBNYXRoLlBJIC8gMik7DQoNCiAgICAvLyAgICAgICAgIHNvblN0YXJ0UiArPSBza2lwQXJjOw0KICAgIC8vICAgICAgICAgdmFyIHBhdGhNaWRBcmMgPSBhcmNNaWRQYXRoKG1pZERhdGFzZXQpOw0KICAgIC8vICAgICAgICAgbGV0IHRpbWVTb25Db2xvciA9IGNvbXB1dGVfY29sb3IoY29sb3JfbGluZWFyKHNvbkRhdGFbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ10pKTsNCiAgICAvLyAgICAgICAgIF90aGlzLmRyYXdBcmMoc3ZnLCB4LCB5IC0gciAvIDIsIHBhdGhBcmMsIHRpbWVTb25Db2xvciwgdGltZVNvbkNvbG9yLCAnc29uIGYnICsgZGF0YVsnaWQnXSArICIgcyIgKyBzb25MaXN0W3NdLCAnMCcpOw0KICAgIC8vICAgICAgICAgaWYgKHMgIT0gc29uTGlzdC5sZW5ndGggLSAxKSB7DQogICAgLy8gICAgICAgICAgIF90aGlzLmRyYXdUaW1lTGluZShzdmcsIGppYW50b3VQYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDMsICc5LDUnLCAnbWlkQXJjICcsICdtaWRBcmMgJyk7DQogICAgLy8gICAgICAgICB9DQogICAgLy8gICAgICAgfQ0KDQogICAgLy8gICAgIH0NCg0KDQogICAgLy8gICB9DQogICAgLy8gICBsZXQgdHh0cyA9IGRhdGFbJ25hbWUnXS5zcGxpdCgiICIpDQogICAgLy8gICBsZXQgdHggPSB4IC0gciAtIDMwOw0KICAgIC8vICAgbGV0IHR5ID0geSArIHIgKzYwOw0KICAgIC8vICAgbGV0IHR3ID0gcioyOw0KICAgIC8vICAgdHggPSB4Ow0KICAgIC8vICAgaWYoZGF0YVsnc29uJ10ubGVuZ3RoPT0wKXsNCiAgICAvLyAgICAgdHggPSB4Ly8tci0xMDsNCiAgICAvLyAgICAgdHkgPSB5K3IqMjsNCiAgICAvLyAgIH0NCiAgICAvLyAgIGlmKGRhdGFbJ2lkJ109PSIzIil7DQogICAgLy8gICAgIHR4ID0geC0xMDsNCiAgICAvLyAgICAgdHkgPSB5K3IqMjsNCiAgICAvLyAgIH0NCiAgICAvLyAgIGlmKGRhdGFbJ2lkJ109PSI0Iil7DQogICAgLy8gICAgIHR4ID0geCsxMDsNCiAgICAvLyAgICAgdHkgPSB5K3IqMjsNCiAgICAvLyAgIH0NCiAgICAvLyAgIC8vIGlmKGRhdGFbJ3R5cGUnXT09JzEnKXsNCiAgICAvLyAgIC8vICAgdHggPSB4LXIvMjsNCiAgICAvLyAgIC8vICAgdHkgPSB5K3IqMjsNCiAgICAvLyAgIC8vIH0NCg0KICAgIC8vICAgX3RoaXMuZHJhd1R4dChzdmcsIHR4LCB0eSx0dyAsIHR4dHMsICJncmV5IiwyMiwgYHRleHRfJHtkYXRhWydpZCddfWApOw0KICAgIC8vICAgLy8gbGV0IHR4dHMgPSBfdGhpcy5uYW1laW5wdXQuc3BsaXQoIiAiKQ0KICAgIC8vICAgLy8gX3RoaXMuZHJhd1R4dChzdmcsIHggLSByIC0gMzIsIHkgKyByICsgNTAsIHIgKiAyICsgNjQsIHR4dHMsICJncmV5Iik7DQogICAgLy8gfSwNCiAgICBkcmF3VHh0KHN2ZywgeCwgeSwgd2lkdGgsIHR4dHMsIGZpbGwsIGZvbnRzaXplID0gMTIsIGlkTikgew0KICAgICAgbGV0IHR4ID0geDsNCiAgICAgIGxldCB0eSA9IHk7DQogICAgICBsZXQgcHJlV2lkdGggPSAwOw0KICAgICAgbGV0IHByZUlkTiA9IDA7DQogICAgICBsZXQgcHJldGV4dCA9ICcnDQogICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHR4dHMubGVuZ3RoOyB0KyspIHsNCiAgICAgICAgcHJldGV4dCArPSIgIisgdHh0c1t0XTsNCiAgICAgICAgbGV0IHR4dCA9IHN2Zy5hcHBlbmQoInRleHQiKQ0KICAgICAgICAgIC5hdHRyKCJ5IiwgdHkpDQogICAgICAgICAgLmF0dHIoIngiLCB0eCkNCiAgICAgICAgICAuYXR0cigiaWQiLCBgJHtpZE59XyR7dH1gKQ0KICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgICAuYXR0cigiZm9udC1zaXplIiwgZm9udHNpemUpDQogICAgICAgICAgLnN0eWxlKCJ0ZXh0LWFuY2hvciIsICJtaWRkbGUiKQ0KICAgICAgICAgIC50ZXh0KHByZXRleHQpDQogICAgICAgIGxldCB0ZXh0V2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtpZE59XyR7dH1gKS5nZXRCQm94KCkud2lkdGg7DQogICAgICAgIGlmKCh0ZXh0V2lkdGg+d2lkdGgpfHwodD09dHh0cy5sZW5ndGggLTEpKXsNCiAgICAgICAgICBwcmV0ZXh0ID0gJyc7DQogICAgICAgICAgdHggPSB4Ow0KICAgICAgICAgIHR5ICs9IDI1Ow0KICAgICAgICB9DQogICAgICAgIGVsc2V7DQogICAgICAgICAgdHh0LnJlbW92ZSgpDQogICAgICAgIH0NCiAgICAgICAgcHJlV2lkdGggKz0gdGV4dFdpZHRoOw0KICAgICAgfQ0KICAgIH0sDQogICAgZHJhd1R4dE9yaTEoc3ZnLCB4LCB5LCB3aWR0aCwgdHh0cywgZmlsbCxmb250c2l6ZT0xMikgew0KICAgICAgbGV0IHR4ID0geDsNCiAgICAgIGxldCB0eSA9IHk7DQogICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHR4dHMubGVuZ3RoOyB0KyspIHsNCg0KICAgICAgbGV0IHR4dCA9ICAgc3ZnLmFwcGVuZCgidGV4dCIpDQogICAgICAgICAgLmF0dHIoInkiLCB0eSkNCiAgICAgICAgICAuYXR0cigieCIsIHR4KQ0KICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgICAuYXR0cigiZm9udC1zaXplIixmb250c2l6ZSkNCiAgICAgICAgICAuc3R5bGUoInRleHQtYW5jaG9yIiwgIm1pZGRsZSIpDQogICAgICAgICAgLnRleHQodHh0c1t0XSkNCiAgICAgICAgdHggKz0gdHh0c1t0XS5sZW5ndGggKiAxNDsNCiAgICAgICAgaWYgKHR4IC0geCA+IHdpZHRoKSB7DQogICAgICAgICAgdHggPSB4Ow0KICAgICAgICAgIHR5ICs9IDI1Ow0KICAgICAgICB9DQogICAgICB9DQogICAgfSwNCiAgICBkcmF3VHh0T3JpKHN2ZywgeCwgeSwgd2lkdGgsIHR4dHMsIGZpbGwpIHsNCiAgICAgIGxldCB0eCA9IHg7DQogICAgICBsZXQgdHkgPSB5Ow0KICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0eHRzLmxlbmd0aDsgdCsrKSB7DQoNCiAgICAgICAgc3ZnLmFwcGVuZCgidGV4dCIpDQogICAgICAgICAgLmF0dHIoInkiLCB0eSkNCiAgICAgICAgICAuYXR0cigieCIsIHR4KQ0KICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgICAudGV4dCh0eHRzW3RdKQ0KICAgICAgICB0eCArPSB0eHRzW3RdLmxlbmd0aCAqIDEwOw0KICAgICAgICBpZiAodHggLSB4ID4gd2lkdGgpIHsNCiAgICAgICAgICB0eCA9IHg7DQogICAgICAgICAgdHkgKz0gMjU7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9LA0KICAgIGRyYXdUcmlhbmdsZShzdmcsIGNvbG9yLCBwb2ludHMsIHN0cm9rZSwgb3BhY2l0eSA9IDEpIHsNCiAgICAgIHN2Zy5hcHBlbmQoInBvbHlnb24iKQ0KICAgICAgICAuYXR0cigicG9pbnRzIiwgcG9pbnRzKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGNvbG9yKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWxpbmVqb2luIiwgInJvdW5kIikNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBvcGFjaXR5KQ0KICAgICAgICAuYXR0cigic3Ryb2tlIiwgc3Ryb2tlKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgIjE1cHgiKTsNCiAgICB9LA0KICAgIGRyYXdDaXJjbGUoc3ZnLCB4LCB5LCByLCBmaWxsLCBkYXRhLCBvcGFjaXR5LCBjbGFzc05hbWUgPSAnZW50Q2lyY2xlJywgaWROYW1lKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBjb25zdCBvRGF0YSA9IF90aGlzLmRhdGENCiAgICAgIHN2Zy5hcHBlbmQoImNpcmNsZSIpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkTmFtZSkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJjeCIsIHgpDQogICAgICAgIC5hdHRyKCJjeSIsIHkpDQogICAgICAgIC5hdHRyKCJyIiwgcikNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgICAgICAub24oIm1vdXNlb3ZlciIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInIiLCByICogMS4xKQ0KICAgICAgICAgIGxldCBjbGFzc04gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBpZiAoY2xhc3NOID09ICdsaW5lUG9pbnQnKSB7DQogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigib3BhY2l0eSIsIDEpLmF0dHIoInIiLCA1KQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmYiICsgZGF0YVsnaWQnXSkNCiAgICAgICAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWQgPSBkMy5zZWxlY3QodGhpcykuYXR0cigidHJhbnNmb3JtIikNCiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZC5zcGxpdCgiICIpWzBdICsgIiBzY2FsZSgxLjEpIg0KICAgICAgICAgICAgICB9KQ0KDQogICAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5iYXNpY1JlbCIpDQogICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IGNsYXNzTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgICAgICAgIGxldCBjbGFzc05MaXN0ID0gY2xhc3NOLnNwbGl0KCIgIik7DQogICAgICAgICAgICAgICAgbGV0IGpnID0gMDsNCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc291cmNlJyArIGRhdGFbJ2lkJ10sIGNsYXNzTkxpc3RbaV0pDQogICAgICAgICAgICAgICAgICBpZiAoJ3NvdXJjZScgKyBkYXRhWydpZCddID09IGNsYXNzTkxpc3RbaV0pIHsgamcgPSAxOyB9DQogICAgICAgICAgICAgICAgICBpZiAoJ3RhcmdldCcgKyBkYXRhWydpZCddID09IGNsYXNzTkxpc3RbaV0pIHsgamcgPSAxOyB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmIChqZyA9PSAxKSB7DQogICAgICAgICAgICAgICAgICBjbGFzc04gKz0gIiBhY3RpdmVTIjsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTjsNCiAgICAgICAgICAgICAgfSkNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2VsZWF2ZSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInIiLCByKQ0KICAgICAgICAgIGxldCBjbGFzc04gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBpZiAoY2xhc3NOID09ICdsaW5lUG9pbnQnKSB7DQogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigib3BhY2l0eSIsIDApLmF0dHIoInIiLCA1KQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmYiICsgZGF0YVsnaWQnXSkNCiAgICAgICAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWQgPSBkMy5zZWxlY3QodGhpcykuYXR0cigidHJhbnNmb3JtIikNCiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZC5zcGxpdCgiICIpWzBdICsgIiBzY2FsZSgxKSINCiAgICAgICAgICAgICAgfSkNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgicGF0aCIpDQogICAgICAgICAgICAgIC5hdHRyKCJjbGFzcyIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICAgICAgbGV0IHRoaXNTZWxlY3QgPSBkMy5zZWxlY3QodGhpcykNCiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOID0gdGhpc1NlbGVjdC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgICAgICAgIGxldCBjbGFzc05MaXN0ID0gY2xhc3NOLnNwbGl0KCIgIikNCiAgICAgICAgICAgICAgICBpZiAoY2xhc3NOTGlzdFtjbGFzc05MaXN0Lmxlbmd0aCAtIDFdID09ICJhY3RpdmVTIikgew0KICAgICAgICAgICAgICAgICAgY2xhc3NOID0gIiI7DQogICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgICAgICAgIGNsYXNzTiArPSBjbGFzc05MaXN0W2ldICsgIiAiOw0KICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NODQogICAgICAgICAgICAgIH0pDQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlZG93biIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoInIiLCByKTsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5mIiArIGRhdGFbJ2lkJ10pDQogICAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWQgPSBkMy5zZWxlY3QodGhpcykuYXR0cigidHJhbnNmb3JtIikNCiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWQuc3BsaXQoIiAiKVswXSArICIgc2NhbGUoMSkiDQogICAgICAgICAgICB9KQ0KICAgICAgICAgIGxldCB0aGlzSWQgPSB0aGlzLmlkLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgbGV0IHRoaXNEYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnaWQnXSA9PSB0aGlzSWQgfSkNCiAgICAgICAgICBsZXQgdGhpc1RpbWUgPSB0aGlzRGF0YVsndGltZSddOw0KICAgICAgICAgIF90aGlzLmNsaWNrX0VudCh0aGlzVGltZSk7DQogICAgICAgICAgLy8gY29uc29sZS5sb2codGhpc1RpbWUsdGhpc0lkLHRoaXNEYXRhKQ0KICAgICAgICB9KQ0KICAgICAgLy8gLm9uKCIiKQ0KICAgIH0sDQogICAgZHJhd1RpbWVMaW5lKHN2ZywgcGF0aCwgc3Ryb2tlLCB3aWR0aCwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgaWROYW1lLCBjbGFzc05hbWUpIHsNCiAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKQ0KICAgICAgICAuYXR0cignZCcsIHBhdGgudG9TdHJpbmcoKSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cignaWQnLCBpZE5hbWUpDQogICAgICAgIC5hdHRyKCJzdHJva2UtZGFzaGFycmF5Iiwgc3Ryb2tlX2Rhc2hhcnJheSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cignZmlsbCcsICdub25lJykNCiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCB0aGlzU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMpDQogICAgICAgICAgbGV0IGNsYXNzTiA9IHRoaXNTZWxlY3QuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBsZXQgaWROID0gdGhpc1NlbGVjdC5hdHRyKCJpZCIpOw0KICAgICAgICAgIGlmIChjbGFzc04uc3BsaXQoIiAiKVswXSA9PSAiYmFzaWNSZWwiKSB7DQogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiLCBjbGFzc04gKyAiIGFjdGl2ZVMiKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IHRoaXNTZWxlY3QgPSBkMy5zZWxlY3QodGhpcykNCiAgICAgICAgICBsZXQgY2xhc3NOID0gdGhpc1NlbGVjdC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBjbGFzc05MaXN0ID0gY2xhc3NOLnNwbGl0KCIgIikNCiAgICAgICAgICBpZiAoY2xhc3NOTGlzdFtjbGFzc05MaXN0Lmxlbmd0aCAtIDFdID09ICJhY3RpdmVTIikgew0KICAgICAgICAgICAgY2xhc3NOID0gIiI7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgIGNsYXNzTiArPSBjbGFzc05MaXN0W2ldICsgIiAiOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIiwgY2xhc3NOKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgfSwNCiAgICBkcmF3QXJjKHN2ZywgeCwgeSwgYXJjUGF0aCwgc3Ryb2tlLCBmaWxsLCBjbGFzc05hbWUsIHN0cm9rZV9kYXNoYXJyYXkgPSAiMCIsIHdpZHRoID0gMykgew0KICAgICAgc3ZnLmFwcGVuZCgicGF0aCIpDQogICAgICAgIC5hdHRyKCJkIiwgYXJjUGF0aCkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgeCArICIsIiArIHkgKyAiKSIpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1kYXNoYXJyYXkiLCBzdHJva2VfZGFzaGFycmF5KQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWxpbmVqb2luIiwgInJvdW5kIikNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgIH0sDQogICAgdXBkYXRhKCkgew0KICAgICAgDQogICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IG1heERJbXBvcnRhbmNlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107IH0pKQ0KICAgICAgbGV0IG1pbkRJbXBvcnRhbmNlID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107IH0pKQ0KICAgICAgbGV0IG1heERSZWxldmFuY2UgPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnYXR0cmlidXRlJ11bJ3JlbGV2YW5jZSddOyB9KSkNCiAgICAgIGxldCBtaW5EUmVsZXZhbmNlID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsgfSkpDQogICAgICBsZXQgbWF4RER1cmF0aW9uID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHRvb2xzLnRpbWUyc2Vjb25kcyhkWyd0aW1lJ11bMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGRbJ3RpbWUnXVswXSk7IH0pKQ0KICAgICAgbGV0IG1heFRvdGFsRHVyYXRpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsndG90YWxEdXJhdGlvbiddOyB9KSkNCg0KICAgICAgX3RoaXMubWluREltcG9ydGFuY2UgPSBtaW5ESW1wb3J0YW5jZTsNCiAgICAgIF90aGlzLm1heERJbXBvcnRhbmNlID0gbWF4REltcG9ydGFuY2U7DQogICAgICBfdGhpcy5taW5EUmVsZXZhbmNlID0gbWluRFJlbGV2YW5jZTsNCiAgICAgIF90aGlzLm1heERSZWxldmFuY2UgPSBtYXhEUmVsZXZhbmNlOw0KICAgICAgX3RoaXMubWF4RER1cmF0aW9uID0gbWF4RER1cmF0aW9uOw0KICAgICAgX3RoaXMubWF4VG90YWxEdXJhdGlvbiA9IG1heFRvdGFsRHVyYXRpb247DQoNCiAgICAgIGxldCBjdXJyZW50TWF4Q29sb3IgPSBfdGhpcy5pbXBvcnRhbmNlTWF4Q29sb3I7DQogICAgICBsZXQgY3VycmVudE1pbkNvbG9yID0gX3RoaXMuaW1wb3J0YW5jZU1pbkNvbG9yOw0KICAgICAgX3RoaXMuaW1wb3J0YW5jZUNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFttaW5ESW1wb3J0YW5jZSwgbWF4REltcG9ydGFuY2VdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgX3RoaXMuaW1wb3J0YW5jZUNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50TWluQ29sb3IsIGN1cnJlbnRNYXhDb2xvcik7DQogICAgICBfdGhpcy5yZWxldmFuY2VTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbbWluRFJlbGV2YW5jZSwgbWF4RFJlbGV2YW5jZV0sIFsyMCwgNTBdKQ0KICAgICAgX3RoaXMudG90YWxEdXJhdGlvblNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBtYXhUb3RhbER1cmF0aW9uXSkucmFuZ2UoWzIwLCA2MF0pOw0KDQoNCg0KDQogICAgICBfdGhpcy4kYnVzLiRlbWl0KCJncmFwaERhdGEiLCBfdGhpcy5kYXRhKTsNCiAgICAgIF90aGlzLiRidXMuJGVtaXQoInJlbERhdGEiLCBfdGhpcy5yZWxEYXRhKTsNCiAgICAgIC8vIF90aGlzLmRyYXd0b3BpY0xpbmUoKTsNCiAgICAgIC8vIF90aGlzLmRyYXdyb290VHJlZSgpOw0KICAgICAgX3RoaXMuZHJhd2VkaXREYXRhKCk7DQogICAgfSwNCiAgICBjbGlja19FbnQodGltZSkgew0KICAgICAgdGhpcy4kZW1pdCgidGltZUR1ciIsIHRpbWUpOw0KICAgIH0sDQogIH0sDQogIGNyZWF0ZWQoKSB7DQogICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsNCiAgICAgIF90aGlzLmdldFRyZWVEYXRhKCk7DQogICAgICBfdGhpcy51cGRhdGEoKTsNCg0KICAgIHRoaXMuJGJ1cy4kb24oJ3NlbGVjdEUnLCAodmFsKSA9PiB7DQogICAgIGNvbnNvbGUubG9nKDExMSx2YWwpOw0KICAgICBfdGhpcy5jdXJFbnRJZCA9IHZhbDsNCiAgICB9KTsNCiAgICB9KTsNCiAgfSwNCiAgbW91bnRlZCgpIHsNCiAgICBjb25zdCBfdGhpcyA9IHRoaXMNCiAgICBfdGhpcy50YWJsZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsna2V5J10gPT0gJ25hbWUnIH0pWyd2YWx1ZSddID0gJ0NvbXB1dGVyIE5ldHdvcmsnOw0KICAgIGNvbnNvbGUubG9nKDIzMjEzKQ0KICAgIA0KICAgIHRoaXMuJGJ1cy4kb24oJ2ltcG9ydGFuY2VMaW5lYXInLCAodmFsKSA9PiB7DQogICAgICBjb25zb2xlLmxvZyh2YWwpDQogICAgICBfdGhpcy5pbXBvcnRhbmNlTGluZWFyID0gdmFsOw0KICAgIH0pOw0KDQogICAgDQogICAgLy8gZGlzYWJsZWQgaW4gdGhlIG9ubGluZSBkZW1vDQogICAgLy8gdGhpcy4kYnVzLiRvbignZW50RGF0YScsICh2YWwpID0+IHsNCiAgICAvLyAgIF90aGlzLmRhdGEgPSB2YWw7DQogICAgLy8gfSk7DQogICAgLy8gdGhpcy4kYnVzLiRvbigncmVsRGF0YScsICh2YWwpID0+IHsNCiAgICAvLyAgIF90aGlzLnJlbERhdGEgPSB2YWw7DQogICAgLy8gfSk7DQogIH0sDQogIC8vIGJlZm9yZURlc3Ryb3koKSB7DQogIC8vICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vdmVUaW1lcik7DQogIC8vIH0sDQp9IA0K"},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6EA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/EditPanel","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"editPanel\">\r\n    <div class=\"panelHead\">SupportPanel</div>\r\n    <div id=\"editPanelDiv\" class=\"panelBody\" ref=\"editPanelDiv\">\r\n      <div id=\"topicLine\" ref=\"topicLine\"></div>\r\n      <!-- <div id=\"rootTree\" ref=\"rootTree\">\r\n        <div id=\"toolsButs\">\r\n          <el-collapse accordion>\r\n            <el-collapse-item>\r\n              <template slot=\"title\">\r\n                <img class=\"iconUpload\" :src=\"toolsButsUrl\">\r\n              </template>\r\n              <div id=\"addNodeSonDiv\" class=\"toolsBut\" @click=\"addNodeSonClk\">\r\n                <img class=\"iconUpload\" :src=\"addNodeSonUrl\">\r\n              </div>\r\n              <div id=\"addNodePerDiv\" class=\"toolsBut\" @click=\"addNodePerClk\">\r\n                <img class=\"iconUpload\" :src=\"addNodePerUrl\">\r\n              </div>\r\n              <div id=\"addLinkBasicDiv\" class=\"toolsBut\" @click=\"addLinkBasicClk\">\r\n                <img class=\"iconUpload\" :src=\"addLinkBasicUrl\">\r\n              </div>\r\n            </el-collapse-item>\r\n          </el-collapse>\r\n        </div>\r\n      </div> -->\r\n      <div id=\"editData\" ref=\"editData\">\r\n        <el-table class=\"editTable\" :data=\"tableData\" style=\"width: 100%\">\r\n          <el-table-column prop=\"key\" label=\"\" width=\"260\">\r\n          </el-table-column>\r\n          <el-table-column prop=\"value\" label=\"\" width=\"260\">\r\n            <template slot-scope=\"scope\">\r\n              <div v-if=\"scope.row.key == 'Type'\">\r\n                <el-radio-group v-model=\"typeRadio\" size=\"small\" @change=\"selectType\">\r\n                  <el-radio-button label=\"concept\"></el-radio-button>\r\n                  <el-radio-button label=\"test\"></el-radio-button>\r\n                  <el-radio-button label=\"example\"></el-radio-button>\r\n                </el-radio-group>\r\n              </div>\r\n              <div v-if=\"scope.row.key == 'Course style'\">\r\n                <div class=\"block\">\r\n                  <el-slider v-model=\"lectureStyleValue\" range>\r\n                  </el-slider>\r\n                </div>\r\n              </div>\r\n              <div v-if=\"scope.row.key == 'Importance score'\">\r\n                <div class=\"block\">\r\n                  <el-slider id=\"importanceScoreValue\" v-model=\"importanceScoreValue\">\r\n                  </el-slider>\r\n                </div>\r\n              </div>\r\n              <div v-if=\"scope.row.key == 'Name'\">\r\n                <!-- <el-input size=\"small\" :placeholder=\"scope.row.value\" v-model=\"nameinput\" clearable>\r\n                </el-input> -->\r\n                <div id=\"editName\">{{nameinput}}</div>\r\n              </div>\r\n              <div :class=\"scope.row.key + ' tableCell'\" :height=\"scope.row.value === '' ? '10' : '0'\"\r\n                disable-transitions>\r\n                <!-- {{ scope.row.value }} -->\r\n              </div>\r\n            </template>\r\n          </el-table-column>\r\n        </el-table>\r\n        <!-- <div id=\"cancelDiv\" @click=\"cancelClk\">\r\n          <img class=\"iconUpload\" :src=\"cancelUrl\">\r\n        </div> -->\r\n        <div id=\"confirmDiv\" @click=\"confirmClk\">\r\n          <img class=\"iconUpload\" :src=\"confirmUrl\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport domtoimage from 'dom-to-image';\r\nimport TestJson from \"@/assets/json/case1_fin.json\";\r\nimport TestRelJson from \"@/assets/json/case1_fin_rel.json\";\r\nimport tools from \"@/utils/tools.js\";\r\n\r\nexport default {\r\n  props: [],\r\n  data() {\r\n    return {\r\n      typeRadio: \"concept\",\r\n      data: TestJson,  //test in the online demo\r\n      relData: TestRelJson,  //test in the online demo\r\n      treeData: null,\r\n      toolsState: '',\r\n      confirmUrl: require(\"@/assets/img/confirm.svg\"),\r\n      cancelUrl: require(\"@/assets/img/cancel.svg\"),\r\n      toolsButsUrl: require(\"@/assets/img/toolsButs.png\"),\r\n      addNodeSonUrl: require(\"@/assets/img/addNode1.png\"),\r\n      addNodePerUrl: require(\"@/assets/img/addNode2.png\"),\r\n      addLinkBasicUrl: require(\"@/assets/img/addLink.png\"),\r\n      // nameinput: \"Random Variables\",\r\n      nameinput: \"Fundamental Graphs\",\r\n      // nameinput: \"Trees\",\r\n      lectureStyleValue: [0, 80],\r\n      importanceScoreValue: 80,\r\n      tableData: [{\r\n        key: 'Name',\r\n        value: '',\r\n      },{\r\n        key: 'Type',\r\n        value: '',\r\n      }, {\r\n        key: 'Course style',\r\n        value: '',\r\n      }, {\r\n        key: 'Importance score',\r\n        value: '',\r\n      }],\r\n      curEntId: \"\",\r\n      insertEntId: \"\",\r\n      insertSourceEntId: \"-1\",\r\n      insertTargetEntId: \"-1\",\r\n      sonList: [],\r\n      minDImportance: 0,\r\n      maxDImportance: 0,\r\n      minDRelevance: 0,\r\n      maxDRelevance: 0,\r\n      maxDDuration: 0,\r\n      importanceLinear:'',\r\n      maxTotalDuration: 0,\r\n      importanceMinColor: \"rgb(203, 230, 209)\",\r\n      importanceMaxColor: \"rgb(22, 144, 207)\",\r\n      totalDuration: 1000,\r\n      importanceColor_linear: null,\r\n      importanceCompute_color: null,\r\n      relevanceScale_linear: null,\r\n      totalDurationScale_linear: null,\r\n      DivisionDataList: [],\r\n      rootDivisionDataList: [],\r\n      entDivisionDataList: [],\r\n      colorMap: {},\r\n      rootColorMap:{},\r\n      videoDuration: 668,\r\n      selectRectId: \"\",\r\n      selectRectClass: \"\",\r\n      topicLineWidth: 1000,\r\n      topicLineHeight: 1000,\r\n      moveLineWidth: 1000,\r\n      entLineWidth: 1000,\r\n      totalSonDuration: 0,\r\n      treeGTransformK:1,\r\n      treeGTransformX:10,\r\n      treeGTransformY:100,\r\n      margin: { top: 5, right: 5, bottom: 5, left: 5 },\r\n      // mcolor: [\r\n      //   \"rgb(255,60,60)\",\r\n      //   \"rgb(155,20,100)\",\r\n      //   \"rgb(255,83,255)\",\r\n      //   \"rgb(200,100,50)\",\r\n      //   \"rgb(235,135,162)\",\r\n      //   \"rgb(200,200,102)\",\r\n      //   \"rgb(255,178,101)\",\r\n      //   \"rgb(63,151,134)\",\r\n      //   \"rgb(83,155,255)\",\r\n      //   \"rgb(50,200,120)\",\r\n      //   \"rgb(2,50,200)\",\r\n      //   \"rgb(0,122,244)\",\r\n      //   \"rgb(150,122,244)\",\r\n      //   \"rgb(168,168,255)\",\r\n      //   \"rgb(200,200,200)\",\r\n      // ],\r\n      mcolor: [\r\n        \"rgb(91, 107, 255)\",\r\n        \"rgb(6, 214, 160)\",\r\n        \"rgb(255, 120, 90)\",\r\n        \"rgb(125, 98, 211)\",\r\n        \"rgb(255, 113, 212)\",\r\n        \"rgb(112, 214, 255)\",\r\n        \"rgb(255, 159, 28)\",\r\n        \"rgb(255, 77, 109)\",\r\n      ],\r\n      mLightcolor: [\r\n        \"#ff9c9c\",\r\n        \"#cc88b0\",\r\n        \"#ffa8ff\",\r\n        \"#e3b097\",\r\n        \"#f4c3d0\",\r\n        \"#f4f4d0\",\r\n        \"#ffd8b1\",\r\n        \"#9ecac2\",\r\n        \"#a8ccff\",\r\n        \"#97e3ba\",\r\n        \"#6f8be0\",\r\n        \"rgb(0,122,244)\",\r\n        \"#b6a2f7\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n    };\r\n  },\r\n  watch: {\r\n    typeRadio(val) {\r\n    },\r\n    lectureStyleValue(val){\r\n      let mid = (val[0]+val[1])/2;\r\n      d3.select(\"#editData .el-slider__runway\")\r\n      .attr(\"style\",\"background: linear-gradient(90deg, #ff9c9c \"+mid+\"%,#6f8be0 \"+mid+\"%) !important\")\r\n    },\r\n    type(val) {\r\n    },\r\n    // selectEnt(val){\r\n    //   console.log(val);\r\n    // },\r\n    curEntId(curEntId) {\r\n      const _this = this;\r\n      let data = _this.data;\r\n      \r\n      let curEnt = data.find(function (d) { return d['id'] == curEntId; });\r\n      if (curEnt['type'] == '1') {\r\n        _this.typeRadio = \"test\";\r\n      }\r\n      else if(curEnt['type'] == '0') {\r\n        _this.typeRadio = \"concept\";\r\n      }\r\n      else {\r\n        _this.typeRadio = \"example\";\r\n      }\r\n      _this.nameinput = curEnt['name'];\r\n      let duration = 0//tools.time2seconds(curEnt['time'][1]) - tools.time2seconds(curEnt['time'][0]);\r\n      \r\n      let typeData = curEnt[\"attribute\"][\"expressions\"];\r\n      let typeDur = 0;\r\n      let styleValue = [];\r\n      for (let i in typeData) {\r\n        let typeDurition = typeData[i];\r\n        let totalTypeSeconds = 0;\r\n        for (let d in typeDurition) {\r\n          totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n        }\r\n        duration+=totalTypeSeconds\r\n      }\r\n      let typeDurScale_linear = d3.scaleLinear([0, duration], [0, 100]);\r\n      for (let i in typeData) {\r\n        // let color = typeColor[i];\r\n        let typeDurition = typeData[i];\r\n        let totalTypeSeconds = 0;\r\n        for (let d in typeDurition) {\r\n          totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n        }\r\n        typeDur += totalTypeSeconds;\r\n        styleValue.push(typeDurScale_linear(typeDur))\r\n      }\r\n      // console.log\r\n      let importanceColor_linear = d3.scaleLinear().domain([ _this.minDImportance, _this.maxDImportance]).range([0, 1]);\r\n      _this.importanceScoreValue = importanceColor_linear(curEnt['attribute']['importance'])*100\r\n      _this.lectureStyleValue = styleValue;\r\n      // _this.importanceScoreValue = 0;\r\n      _this.drawEntity(curEnt);\r\n      _this.drawSonLine(curEnt);\r\n    }\r\n  },\r\n  methods: {\r\n    selectType(v) {\r\n      // console.log(v)\r\n    },\r\n    cancelClk() {\r\n      const _this = this;\r\n      let data = _this.data;\r\n      let curEntId = _this.curEntId;\r\n      let curEnt = data.find(function (d) { return d['id'] == curEntId; });\r\n      _this.drawEntity(curEnt);\r\n      _this.drawSonLine(curEnt);\r\n      _this.drawrootTree();\r\n\r\n    },\r\n    confirmClk() {\r\n      const _this = this;\r\n      let data = _this.data;\r\n      let curEntId = _this.curEntId;\r\n      let curEnt = data.find(function (d) { return d['id'] == curEntId; });\r\n      if (_this.typeRadio == \"hidden State\") {\r\n        curEnt['type'] = '1'\r\n      }\r\n      else {\r\n        curEnt['type'] = '0';\r\n      }\r\n      curEnt['name'] = _this.nameinput;\r\n\r\n      let styleValue = _this.lectureStyleValue;\r\n      let startSeconds = tools.time2seconds(curEnt['time'][0]);\r\n      let endSeconds = tools.time2seconds(curEnt['time'][1]);\r\n      let totalSeconds = endSeconds - startSeconds;\r\n      let typeDurReScale_linear = d3.scaleLinear([0, 100], [startSeconds, endSeconds]);\r\n      let typeData = { \"1\": [], \"2\": [], \"3\": [] };//;\r\n      let t1 = tools.seconds2time(typeDurReScale_linear(styleValue[0]));\r\n      let t2 = tools.seconds2time(typeDurReScale_linear(styleValue[1]));\r\n      typeData['1'].push([curEnt['time'][0], t1]);\r\n      typeData['2'].push([t1, t2]);\r\n      typeData['3'].push([t2, curEnt['time'][1]]);\r\n      curEnt[\"attribute\"][\"expressions\"] = typeData;\r\n\r\n      let entRects = d3.selectAll(\".editEnt\").nodes();\r\n      console.log(entRects)\r\n      let totalSonDuration = _this.totalSonDuration;\r\n      let wid = _this.entLineWidth;\r\n      let cxReLinear = d3.scaleLinear([0, wid], [0, totalSonDuration]);\r\n      let preTime = '';\r\n      let typeTotalData = { \"1\": [], \"2\": [], \"3\": [] };//;\r\n      for (let n = 0; n < entRects.length; n++) {\r\n        let curRect = entRects[n];\r\n        let rectId = curRect.id.split(\"_\")[1];\r\n        let rectData = data.find(function (d) { return d['id'] == rectId; });\r\n        let perDur = tools.time2seconds(rectData['time'][1]) - tools.time2seconds(rectData['time'][0]);\r\n        if (n == 0) {\r\n          preTime = rectData['time'][0];\r\n        }\r\n        let preSecond = tools.time2seconds(preTime);\r\n        let x = curRect.x.baseVal.value;\r\n        let w = curRect.width.baseVal.value;\r\n        let durSecond = cxReLinear(w);\r\n        let endTime = tools.seconds2time(preSecond + durSecond);\r\n        rectData['time'] = [preTime, endTime];\r\n        rectData['totalDuration'] += durSecond - perDur;\r\n        preTime = endTime;\r\n        for (let t in typeTotalData) {\r\n          typeTotalData[t] = [...typeTotalData[t], ...rectData['attribute']['expressions'][t]]\r\n        }\r\n      }\r\n      console.log(typeTotalData)\r\n      _this.data = data;\r\n      // console.log(entRects,entRects[0])\r\n\r\n      _this.drawEntity(curEnt);\r\n      _this.drawSonLine(curEnt);\r\n      _this.drawrootTree();\r\n      _this.$bus.$emit(\"graphData\", data);\r\n    },\r\n    click_node() {\r\n      const _this = this;\r\n      let nodeId = _this.curEntId;\r\n      let addDataId = _this.insertEntId;//parseInt(nodeId)+1+'';\r\n      let oriData = _this.data;\r\n      let state = _this.toolsState;\r\n      let returnData = [];\r\n      let returnRelData = {};\r\n      let relData = _this.relData;\r\n\r\n      if (state == 'addNodeSon') {\r\n        for (let i = 0; i < oriData.length; i++) {\r\n          let cData = oriData[i];\r\n          let cDataId = cData['id']\r\n          \r\n          let sons = cData['son'];\r\n          let sonsNew = [];\r\n          for(let s=0;s<sons.length;s++){\r\n            let ss = sons[s]\r\n              if(parseInt(ss)>=parseInt(addDataId)) ss = parseInt(ss)+1\r\n              sonsNew.push(ss+'')\r\n          }\r\n          cData['son'] = sonsNew;\r\n\r\n          if (parseInt(cDataId) == parseInt(addDataId)) {\r\n            let perData = tools.deepClone(cData);\r\n            let addData = tools.deepClone(perData);\r\n            addData['id'] = addDataId;\r\n            perData['id'] = (parseInt(addDataId) + 1)+'';\r\n            console.log(addData,perData)\r\n            let startT = cData['time'][0];\r\n            let endT = cData['time'][1];\r\n            let midT = tools.seconds2time((tools.time2seconds(endT) + tools.time2seconds(startT)) / 2);\r\n            addData['time'] = [startT, midT];\r\n            perData['time'] = [midT, endT];\r\n            addData['son'] = [];\r\n            addData['totalDuration'] = (tools.time2seconds(midT) - tools.time2seconds(startT));\r\n            perData['totalDuration'] -= addData['totalDuration'];\r\n            let typeTimes = perData['attribute']['expressions'];\r\n            let typePreData = { \"1\": [], \"2\": [], \"3\": [] };\r\n            let typeAddData = { \"1\": [], \"2\": [], \"3\": [] };\r\n            for (let t in typeTimes) {\r\n              for (let a = 0; a < typeTimes[t].length; a++) {\r\n                let st = typeTimes[t][a][0];\r\n                let et = typeTimes[t][a][1];\r\n                if (tools.time2seconds(et) <= tools.time2seconds(midT)) { typeAddData[t].push([st, et]) }\r\n                else if (tools.time2seconds(st) >= tools.time2seconds(midT)) { typePreData[t].push([st, et]) }\r\n                else if ((tools.time2seconds(st) < tools.time2seconds(midT)) && (tools.time2seconds(et) > tools.time2seconds(midT))) {\r\n                  typeAddData[t].push([st, midT]);\r\n                  typePreData[t].push([midT, et]);\r\n                }\r\n              }\r\n            }\r\n            perData['attribute']['expressions'] = typePreData;\r\n            addData['attribute']['expressions'] = typeAddData;\r\n            returnData.push(addData);\r\n            returnData.push(perData);\r\n          }\r\n          else if (parseInt(cData['id']) < parseInt(addDataId)) {\r\n            returnData.push(tools.deepClone(cData));\r\n          }\r\n          else if (parseInt(cData['id']) > parseInt(addDataId)){\r\n            let perData = tools.deepClone(cData);\r\n            perData['id'] = (parseInt(cDataId) + 1) + '';\r\n            returnData.push(perData);\r\n          }\r\n\r\n        }\r\n      \r\n      let bsNew = [];\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n        let sourceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        if(parseInt(sourceId)>=parseInt(addDataId)) sourceId = parseInt(sourceId)+1;\r\n        if(parseInt(targetId)>=parseInt(addDataId)) targetId = parseInt(targetId)+1;\r\n        bsNew.push([sourceId+'',targetId+''])\r\n      }\r\n      let ssNew = []\r\n      let similarityRel = relData['similarityRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n        let sourceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n        if(parseInt(sourceId)>=parseInt(addDataId)) sourceId = parseInt(sourceId)+1;\r\n        if(parseInt(targetId)>=parseInt(addDataId)) targetId = parseInt(targetId)+1;\r\n        ssNew.push([sourceId+'',targetId+''])\r\n      }\r\n      returnRelData = {'basicRel':bsNew,'similarityRel':ssNew};\r\n      let nData = returnData.find(function(d){return d['id'] == nodeId});\r\n      let aData = returnData.find(function(d){return d['id'] == addDataId});\r\n      if(nodeId!='-1'){\r\n        nData['son'].push(addDataId);\r\n        aData['layout'] = parseInt(nData['layout']+1);\r\n        aData['father'] = [nodeId];\r\n      }\r\n      else{\r\n        aData['layout'] = '0';\r\n      }\r\n      _this.data = (returnData);\r\n      _this.relData = returnRelData;\r\n      _this.getTreeData();\r\n      _this.updata();\r\n      }\r\n      if (state == 'addLinkBasic') {\r\n        let addSourceDataId = _this.insertSourceEntId;\r\n        let addTargetDataId = _this.insertTargetEntId;\r\n        if((addSourceDataId != '-1')&&(addTargetDataId != '-1')){\r\n          returnRelData =  tools.deepClone(relData);\r\n          returnRelData['basicRel'].push([addSourceDataId,addTargetDataId]);\r\n          _this.insertSourceEntId = '-1';\r\n          _this.insertTargetEntId = '-1';\r\n          _this.relData = returnRelData;\r\n          _this.getTreeData();\r\n          _this.updata();\r\n        }\r\n      }\r\n    },\r\n    addNodeSonClk() {\r\n      this.toolsState = 'addNodeSon';\r\n    },\r\n    addNodePerClk() {\r\n      this.toolsState = 'addNodePer';\r\n    },\r\n    addLinkBasicClk() {\r\n      this.toolsState = 'addLinkBasic';\r\n    },\r\n    drawtopicLine() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      const color = _this.mcolor;\r\n\r\n      let width = this.$refs.topicLine.offsetWidth - margin.left - margin.right;\r\n      let height = this.$refs.topicLine.offsetHeight - margin.top - margin.bottom;\r\n      _this.topicLineWidth = width;\r\n      _this.topicLineHeight = height;\r\n      d3.select(\"#topicLine\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#topicLine\").append(\"svg\")\r\n        .attr(\"id\", \"topicLineSvg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height);\r\n      let rootEntG = groups.append(\"g\").attr(\"id\", \"rootEntG\").attr(\"width\", width).attr(\"height\", height);\r\n      let oriLineG = groups.append(\"g\").attr(\"id\", \"oriLineG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      oriLineG.append(\"line\")\r\n        .attr(\"x1\", 0)\r\n        .attr(\"y1\", height / 2)\r\n        .attr(\"x2\", width)\r\n        .attr(\"y2\", height / 2)\r\n        .attr(\"stroke\", \"rgb(200,200,200)\")\r\n        .attr(\"stroke-width\", \"5px\");\r\n\r\n      let cxLinear = d3.scaleLinear([0, _this.videoDuration], [margin.left, width])\r\n\r\n      let data = tools.deepClone(_this.data);\r\n      let DivisionDataList = [];\r\n      let colorIndex = 0;\r\n      for (let i = 0; i < data.length; i++) {\r\n        if (data[i]['layout'] == '0') {\r\n          if (DivisionDataList.length != 0) {\r\n            DivisionDataList[DivisionDataList.length - 1]['nextId'] = data[i]['id'];\r\n            data[i]['preId'] = DivisionDataList[DivisionDataList.length - 1]['id'];\r\n          }\r\n          else { data[i]['preId'] = \"-1\"; }\r\n          DivisionDataList.push(data[i]);\r\n          let time = tools.time2seconds(data[i]['time'][0]);\r\n          let endTime = tools.time2seconds(data[i]['time'][0]) + data[i]['totalDuration'];\r\n          let cx = cxLinear(time);\r\n          let endx = cxLinear(endTime);\r\n          _this.colorMap[data[i]['id']] = colorIndex % color.length;\r\n          _this.drawRect(oriLineG, cx - 5, height / 2 - 5, 10, 10, height / 2, \"division_\" + data[i][\"id\"], \"rootdivisionLine\", \"rgb(250,250,250)\", 0, '', 1)\r\n          _this.drawRect(rootEntG, cx, margin.top, endx - cx, height - margin.top - margin.bottom, height / 2, \"rootEnt_\" + data[i]['id'], \"rootEnt\", color[_this.colorMap[data[i]['id']]], 5, \"rgb(150,150,150)\", 0.1)\r\n          colorIndex++;\r\n        }\r\n      }\r\n      DivisionDataList[DivisionDataList.length - 1]['nextId'] = \"-1\";\r\n      _this.rootDivisionDataList = DivisionDataList;\r\n\r\n      // oriLineG.append(\"ellipse\")\r\n      // .attr(\"cx\",50)\r\n      // .attr(\"cy\",height/2)\r\n      // .attr(\"rx\",50)\r\n      // .attr(\"ry\",height/2)\r\n      // .attr(\"fill\",color[3])\r\n      // .attr(\"stroke\", color[3])\r\n\r\n      // .attr(\"stroke-width\", \"5px\");\r\n      // console.log(data)\r\n      // this.$bus.$emit(\"getData\",data)\r\n    },\r\n    drawRect(svg, x, y, w, h, rx, idName, className, fill, strokeWidth, stroke, opacity) {\r\n      const _this = this;\r\n      svg.append(\"rect\")\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"width\", w)\r\n        .attr(\"height\", h)\r\n        .attr(\"fill\", fill)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"stroke\", stroke)//\"rgb(150,150,150)\")\r\n        .attr(\"stroke-width\", strokeWidth)\r\n        .on(\"mousedown\", function (d) {\r\n          _this.selectRectId = idName.split(\"_\")[1] //d3.select(this).attr(\"id\");\r\n          if (d3.select(this).attr(\"class\") == \"rootdivisionLine\") {\r\n            _this.selectRectClass = \"rootEnt\";\r\n            _this.moveLineWidth = _this.topicLineWidth;\r\n            _this.DivisionDataList = _this.rootDivisionDataList;\r\n            // document.getElementById('topicLineSvg').addEventListener(\"mousemove\", _this.moveRect); // 监听点击事件\r\n          }\r\n          else if (d3.select(this).attr(\"class\") == \"entdivisionLine\") {\r\n            _this.selectRectClass = \"editEnt\";\r\n            _this.moveLineWidth = _this.entLineWidth;\r\n            _this.DivisionDataList = _this.entDivisionDataList;\r\n            document.getElementById('editEnt').addEventListener(\"mousemove\", _this.moveRect); // 监听点击事件\r\n          }\r\n        })\r\n        .on(\"mouseup\", function (d) {\r\n          // document.getElementById('topicLineSvg').removeEventListener(\"mousemove\", _this.moveRect); // \r\n          document.getElementById('editEnt').removeEventListener(\"mousemove\", _this.moveRect); // \r\n          // _this.$bus.$emit(\"graphData\", _this.data);\r\n\r\n          _this.$bus.$emit(\"treeData\", _this.treeData);\r\n        })\r\n    },\r\n    moveRect(e) {\r\n      const _this = this;\r\n      let selectRect = _this.DivisionDataList.find(function (d) { return d['id'] == _this.selectRectId; })//右边的rect\r\n      let preId = selectRect['preId'];//左边的rect\r\n      let nextId = selectRect['nextId'];//右边的右边rect\r\n      let rectClass = _this.selectRectClass;\r\n      let prex = 0;\r\n      if (preId != '-1') {\r\n        prex = d3.select(\"#\" + rectClass + \"_\" + preId).attr(\"x\")\r\n        d3.select(\"#\" + rectClass + \"_\" + preId)\r\n          .attr(\"width\", function (d) {\r\n            return e.offsetX - prex;\r\n          })\r\n      }\r\n      let nextX = 100;\r\n      if (nextId == '-1') {\r\n        nextX = _this.moveLineWidth;\r\n      }\r\n      else {\r\n        nextX = d3.select(\"#\" + rectClass + \"_\" + nextId).attr(\"x\");\r\n      }\r\n      d3.select(\"#\" + rectClass + \"_\" + _this.selectRectId)\r\n        .attr(\"width\", function (d) {\r\n          return nextX - e.offsetX;\r\n        })\r\n        .attr(\"x\", e.offsetX)\r\n      d3.select(\"#division_\" + _this.selectRectId)\r\n        .attr(\"x\", e.offsetX - 5)\r\n\r\n      if ((e.offsetX > (_this.topicLineWidth)) || (e.offsetX < (0)) || (e.offsetY > (_this.topicLineHeight)) || (e.offsetY < (0))) {\r\n        // document.getElementById('topicLineSvg').removeEventListener(\"mousemove\", _this.moveRect); // \r\n      }\r\n    },\r\n    getTreeData(){\r\n      const _this = this;\r\n      let oriData = tools.deepClone(this.data);\r\n      var data = {\r\n        \"name\": \"root\",\r\n        \"children\": []\r\n      };\r\n\r\n      for (let i = oriData.length - 1; i >= 0; i--) {\r\n        let sons = oriData[i]['son'];\r\n        oriData[i]['children'] = [];\r\n        if (sons.length > 0) {\r\n          for (let s = 0; s < sons.length; s++) {\r\n            oriData[i]['children'].push(oriData.find(function (d) { return d['id'] == sons[s] }))\r\n          }\r\n        }\r\n      }\r\n      let c = 0 ;\r\n      for (let i = 0; i < oriData.length; i++) {\r\n\r\n        let layout = oriData[i]['layout'];\r\n        if (layout == '0') {\r\n          data['children'].push(oriData[i]);\r\n          if(oriData[i]['name']!=\"Test\"){\r\n            _this.rootColorMap[oriData[i]['id']] = _this.mcolor[c];\r\n            c++;\r\n          }\r\n          else{\r\n            _this.rootColorMap[oriData[i]['id']] =\"rgb(250, 199, 88)\";\r\n          }\r\n        }\r\n      }\r\n\r\n      this.treeData = data;\r\n      console.log(_this.rootColorMap)\r\n      this.$bus.$emit(\"treeData\", [data,_this.rootColorMap]);\r\n    },\r\n    drawrootTree() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      let width = this.$refs.rootTree.offsetWidth - margin.left - margin.right;\r\n      let height = this.$refs.rootTree.offsetHeight - margin.top - margin.bottom;\r\n\r\n      let color = _this.mcolor;\r\n      let colorMap = _this.colorMap;\r\n      // var tree = d3.tree()\r\n      //   .size([width, height - 200]);\r\n      d3.select(\"#rootTree\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#rootTree\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n\r\n      let transY = height;\r\n      let treeGTransformX = _this.treeGTransformX;\r\n      let treeGTransformY = _this.treeGTransformY;\r\n      let treeGTransformK = _this.treeGTransformK;\r\n      let groups = svg.append(\"g\")\r\n        .attr(\"id\", \"editrootTreeg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n        .attr(\"transform\",  \"translate(\"+treeGTransformX+',' +treeGTransformY + \") scale(\"+treeGTransformK+\")\");\r\n\r\n        let stx = 0;\r\n        let sty = 0;\r\n        let stk =1;\r\n      var graphZoom = d3.zoom()\r\n        .scaleExtent([0, 10])\r\n        .on(\"start\", (e) => {\r\n          sty = e.transform.y;\r\n          stx = e.transform.x;\r\n          stk = e.transform.k;\r\n        })\r\n        .on('zoom', (e) => {\r\n          treeGTransformX = _this.treeGTransformX + e.transform.x - stx;\r\n          treeGTransformY = _this.treeGTransformY + e.transform.y - sty;\r\n          treeGTransformK = _this.treeGTransformK + e.transform.k - stk;\r\n          groups.attr('transform', 'translate(' + (treeGTransformX) + ',' + (treeGTransformY) + ') scale(' + (treeGTransformK) + ')')\r\n        })\r\n        .on('end', (e) => {\r\n          _this.treeGTransformX = treeGTransformX;\r\n          _this.treeGTransformY = treeGTransformY;\r\n          _this.treeGTransformK = treeGTransformK;\r\n          groups.attr('transform', 'translate(' + (treeGTransformX) + ',' + (treeGTransformY) + ') scale(' + (treeGTransformK) + ')')\r\n        });\r\n      svg.call(graphZoom)\r\n\r\n      const gLink = groups.append(\"g\")\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", \"#555\")\r\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\r\n        .attr(\"stroke-opacity\", 0.4)\r\n        .attr(\"stroke-width\", 1.5);\r\n\r\n      const gNode = groups.append(\"g\")\r\n        .attr(\"cursor\", \"pointer\")\r\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\r\n        .attr(\"pointer-events\", \"all\")\r\n\r\n      let data = _this.treeData;\r\n      let diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);\r\n      let tree = d3.tree().nodeSize([50, 150]);//.size([(height - margin.left - margin.right) * 2, (width - margin.left - margin.right)-10])\r\n      const root = d3.hierarchy(data);\r\n      const nodes = root.descendants().reverse();\r\n      const links = root.links();\r\n      tree(root);\r\n      console.log(nodes)\r\n      const node = gNode.selectAll(\"g\")\r\n        .data(nodes, d => d.id);\r\n\r\n      const nodeEnter = node.data(nodes).enter().append(\"g\")\r\n        .attr(\"transform\", (d) => {\r\n          return `translate(${d.y},${d.x})`\r\n        })\r\n        .on(\"click\", (event, d) => {\r\n          d.children = d.children ? null : d._children;\r\n          // update(d);\r\n        })\r\n\r\n      nodeEnter.append(\"circle\")\r\n        .attr(\"r\", 10)\r\n        .attr(\"id\", function (d) {\r\n          console.log(d)\r\n          if(d.data.name == 'root')\r\n            return \"treeNode_-1\";\r\n          return \"treeNode_\" + d.data.id;\r\n        })\r\n        .attr(\"fill\", function (d) {\r\n          if (d.data.name == 'root') {\r\n            return 'grey'\r\n          }\r\n          else {\r\n            let parent = d.parent;\r\n            let rootd = null;\r\n            while (parent.data.name != 'root') {\r\n              rootd = parent;\r\n              if (parent.parent.data.name == 'root') {\r\n                return color[colorMap[parent.data.id]]\r\n              }\r\n              parent = parent.parent;\r\n            }\r\n            return color[colorMap[d.data.id]]\r\n          }\r\n\r\n        })\r\n        .attr(\"stroke\", \"rgb(100,100,100)\")\r\n        // .attr(\"fill\", d => d._children ? \"#555\" : \"#999\")\r\n        .attr(\"stroke-width\", 1)\r\n        .on(\"mouseover\", function () {\r\n          d3.select(this).attr(\"r\", 15);\r\n\r\n        })\r\n        .on(\"mouseleave\", function () {\r\n          d3.select(this).attr(\"r\", 10)\r\n        })\r\n        .on(\"mousedown\", function () {\r\n          let nodeIdN = d3.select(this).attr(\"id\");\r\n          let nodeId = nodeIdN.split(\"_\")[1];\r\n          _this.curEntId = nodeId;\r\n          if(nodeId == '-1'){\r\n            _this.insertEntId = parseInt(nodeId) + 1 + '';\r\n          _this.click_node();\r\n            return\r\n          }\r\n          let curData = _this.data.find(function (d) { return d['id'] == nodeId; });\r\n          if (_this.toolsState == 'addNodeSon') {\r\n            _this.insertEntId = parseInt(nodeId) + 1 + '';\r\n          }\r\n          else if (_this.toolsState == 'addLinkBasic') {\r\n            if(_this.insertSourceEntId ==\"-1\")\r\n              _this.insertSourceEntId = parseInt(nodeId) + '';\r\n            else{\r\n              _this.insertTargetEntId = parseInt(nodeId) + '';\r\n            }\r\n          }\r\n          if ( (curData['son'].length > 0)) {\r\n            _this.insertEntId = parseInt(curData['son'][0]) + 1 +'';\r\n          };\r\n          _this.click_node();\r\n        })\r\n\r\n      // nodeEnter.append(\"text\")\r\n      //   .attr(\"dy\", \"0.31em\")\r\n      //   .attr(\"x\", d => d._children ? -6 : 6)\r\n      //   .attr(\"text-anchor\", d => d._children ? \"end\" : \"start\")\r\n      //   .text(d => d.data.name)\r\n      //   .clone(true).lower()\r\n      //   .attr(\"stroke-linejoin\", \"round\")\r\n      //   .attr(\"stroke-width\", 3)\r\n      //   .attr(\"stroke\", \"white\");\r\n\r\n      const link = gLink.selectAll(\"path\")\r\n        .data(links, d => d.target.id);\r\n\r\n      const linkEnter = link.enter().append(\"path\")\r\n        .attr(\"d\", d => {\r\n          const o = { x: d.source.x, y: d.source.y };\r\n          const p = { x: d.target.x, y: d.target.y }\r\n          return diagonal({ source: o, target: p });\r\n        })\r\n        .attr(\"stroke\", \"rgb(100,100,100)\")\r\n        .attr(\"stroke-width\", 5)\r\n      _this.drawRootTreeRel(gLink, nodes);\r\n    },\r\n    drawRootTreeRel(svg, nodeData) {\r\n\r\n      const _this = this;\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      console.log(nodeData)\r\n      let margin = _this.margin;\r\n      let height = svg.attr('height');\r\n      // let basicRel = relData['similarityRel'];\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n\r\n        let sourceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        let idN = \"basicRel\" + sourceId + \"_\" + targetId;\r\n        let classN = \"basicRel source\" + sourceId + \" target\" + targetId;\r\n        let sourceNode = nodeData.find(function (d) { return d['data']['id'] == sourceId });\r\n        let targetNode = nodeData.find(function (d) { return d['data']['id'] == targetId });\r\n        if (sourceNode['x'] > targetNode['x']) {\r\n          let tp = sourceNode;\r\n          sourceNode = targetNode;\r\n          targetNode = tp;\r\n        }\r\n        const path = d3.path();\r\n\r\n        let startX = sourceNode['y'];\r\n        let endX = targetNode['y'];\r\n        let startY = sourceNode['x'];\r\n        let endY = targetNode['x'];\r\n        let midX = (startX + endX) / 2;\r\n        let midY = (startY + endY) / 2;\r\n        let cnx = (startX > endX) ? (startX + 10 + 0.25 * (endY - startY)) : (endX + 10 + 0.25 * (endY - startY));\r\n        path.moveTo(startX, startY);\r\n        path.bezierCurveTo(cnx, midY, cnx, midY, endX, endY);\r\n        _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"9,9\", idN, classN);\r\n\r\n\r\n      };\r\n      let similarityRel = relData['similarityRel'];\r\n      // let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n\r\n        let sourceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n\r\n        let idN = \"similarityRel\" + sourceId + \"_\" + targetId;\r\n\r\n        let classN = \"similarityRel source\" + sourceId + \" target\" + targetId;\r\n        let sourceNode = nodeData.find(function (d) { return d['data']['id'] == sourceId });\r\n        let targetNode = nodeData.find(function (d) { return d['data']['id'] == targetId });\r\n        if (sourceNode['x'] > targetNode['x']) {\r\n          let tp = sourceNode;\r\n          sourceNode = targetNode;\r\n          targetNode = tp;\r\n        }\r\n        const path = d3.path();\r\n\r\n        let startX = sourceNode['y'];\r\n        let endX = targetNode['y'];\r\n        let startY = sourceNode['x'];\r\n        let endY = targetNode['x'];\r\n        let midX = (startX + endX) / 2;\r\n        let midY = (startY + endY) / 2;\r\n        let cnx = (startX > endX) ? (startX + 100 + 0.5 * (endY - startY)) : (endX + 100 + 0.5 * (endY - startY));\r\n\r\n        path.moveTo(startX, startY);\r\n        path.lineTo(cnx, startY);\r\n        path.lineTo(cnx, endY);\r\n        path.lineTo(endX, endY);\r\n        _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"0\", idN, classN);\r\n\r\n\r\n      };\r\n    },\r\n    draweditData() {\r\n      const _this = this;\r\n      const margin = _this.margin;\r\n      let width = this.$refs.editData.offsetWidth - margin.left - margin.right - 60;\r\n      let height = this.$refs.editData.offsetHeight - margin.top - margin.bottom;\r\n      d3.select(\"#editData\").select(\"svg\").remove();\r\n      var svg = d3.select(\"#editData\").append(\"svg\")\r\n        .attr(\"id\", \"editEnt\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n\r\n      let entG = svg.append(\"g\").attr(\"id\", \"entG\").attr(\"width\", width).attr(\"height\", height);\r\n      let sonG = svg.append(\"g\").attr(\"id\", \"sonG\").attr(\"width\", width).attr(\"height\", height).attr(\"transform\", \"translate(1,320)\");\r\n      // _this.entG = entG;\r\n      // _this.sonG = sonG;\r\n      _this.drawEntity(_this.data[0]);\r\n      _this.drawSonLine(_this.data[1]);\r\n    },\r\n    drawSonLine(data) {\r\n      const _this = this;\r\n      let psvg = d3.select(\"#sonG\");\r\n      let w = psvg.attr(\"width\") - 1;\r\n      let h = 35;\r\n      psvg.remove();\r\n      let svg = d3.select(\"#editEnt\").append(\"g\").attr(\"id\", \"sonG\").attr(\"width\", w + 1).attr(\"height\", h + 2).attr(\"transform\", \"translate(1,280)\");\r\n      let color_linear = _this.importanceColor_linear;\r\n      let compute_color = _this.importanceCompute_color;\r\n      let oData = _this.data;\r\n      _this.entLineWidth = w;\r\n      // if (sonList.length > 0) {\r\n      svg.selectAll().remove();\r\n      svg.append(\"line\")\r\n        .attr(\"x1\", 0)\r\n        .attr(\"y1\", h / 2)\r\n        .attr(\"x2\", w)\r\n        .attr(\"y2\", h / 2)\r\n        .attr(\"stroke\", \"rgb(200,200,200)\")\r\n        .attr(\"stroke-width\", \"5px\");\r\n\r\n      let totalSonDuration = 0;\r\n      let dataIndex = oData.map(item => item.id).indexOf(data['id']);\r\n      let startIndex = ((dataIndex - 2) > 0) ? (dataIndex - 2) : (0);\r\n      let endIndex = ((dataIndex + 1) < oData.length) ? (dataIndex + 2) : (oData.length - 1);\r\n\r\n      let dataLi = tools.deepClone(oData).splice(startIndex, endIndex - startIndex + 1);\r\n      // let data = sonList;\r\n      for (let i = 0; i < dataLi.length; i++) {\r\n        let curEnt = oData.find(function (d) { return d['id'] == dataLi[i]['id'] });\r\n        let time = tools.time2seconds(curEnt['time'][0]);\r\n        let endTime = tools.time2seconds(curEnt['time'][1]);\r\n        totalSonDuration += endTime - time;\r\n      }\r\n      _this.totalSonDuration = totalSonDuration;\r\n      let cxLinear = d3.scaleLinear([0, totalSonDuration], [0, w]);\r\n      let DivisionDataList = [];\r\n      // let colorIndex = 0;\r\n      let prex = 0;\r\n      for (let i = 0; i < dataLi.length; i++) {\r\n        let curEnt = oData.find(function (d) { return d['id'] == dataLi[i]['id'] });\r\n        let temp = tools.deepClone(curEnt);\r\n        if (DivisionDataList.length != 0) {\r\n          DivisionDataList[DivisionDataList.length - 1]['nextId'] = temp['id'];\r\n          temp['preId'] = DivisionDataList[DivisionDataList.length - 1]['id'];\r\n        }\r\n        else { temp['preId'] = \"-1\"; }\r\n        DivisionDataList.push(temp);\r\n        let time = tools.time2seconds(curEnt['time'][0]);\r\n        let endTime = tools.time2seconds(curEnt['time'][1]);\r\n        let curEntDur = endTime - time;\r\n        let cx = prex;\r\n        let endx = prex + cxLinear(curEntDur);\r\n        let importanceValue = curEnt['attribute']['importance'];\r\n        let entColor = compute_color(color_linear(importanceValue));\r\n        if (i != 0) {\r\n          _this.drawRect(svg, cx - 2, 0, 5, h, h / 2, \"division_\" + curEnt['id'], \"entdivisionLine\", \"rgb(0,250,250)\", 50, '', 0);\r\n        }\r\n        if (dataLi[i]['id'] == data['id']) _this.drawRect(svg, cx, 0, endx - cx-2, h, 1, \"editEnt_\" + curEnt['id'], \"editEnt\", entColor, 1, \"rgba(255,255,255,1)\", 1)//color[_this.colorMap[son['id']]], 5, 0.1)\r\n        else _this.drawRect(svg, cx, 0, endx - cx-2, h, 1, \"editEnt_\" + curEnt['id'], \"editEnt\", entColor, 1, \"rgba(255,255,255,1)\", 3)//color[_this.colorMap[son['id']]], 5, 0.1)\r\n        prex = endx;\r\n      }\r\n      DivisionDataList[DivisionDataList.length - 1]['nextId'] = \"-1\";\r\n      _this.entDivisionDataList = DivisionDataList;\r\n    },\r\n    drawEntityOri(data) {\r\n      const _this = this;\r\n      let psvg = d3.select(\"#entG\");\r\n      let w = psvg.attr(\"width\");\r\n      let h = psvg.attr(\"height\");\r\n      psvg.remove();\r\n      let svg = d3.select(\"#editEnt\").append(\"g\").attr(\"id\", \"entG\").attr(\"width\", w).attr(\"height\", h);\r\n      let color_linear = _this.importanceColor_linear;\r\n      let compute_color = _this.importanceCompute_color;\r\n      let totalDurationValue = data['totalDuration'];\r\n      let rScale = _this.totalDurationScale_linear;\r\n      let r = rScale(totalDurationValue);\r\n      let oData = _this.data;\r\n      let x = svg.attr(\"width\") / 2;\r\n      let y = 120;\r\n      let importanceValue = data['attribute']['importance'];\r\n      let relevanceValue = data['attribute']['relevance'];\r\n      svg.selectAll().remove();\r\n\r\n      if (data['type'] == '1') {\r\n        let area = tools.calcTriangle(x, y, r);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n      }\r\n      else {\r\n\r\n        let cy = y;\r\n        let totalDuration = _this.totalDuration;\r\n        let timeLineScale_linear = d3.scaleLinear([0, totalDuration], [x - r * Math.sqrt(3) / 2, x + r * Math.sqrt(3) / 2])\r\n        let timeLineHighScale_linear = d3.scaleLinear([0, _this.maxDDuration], [0, r * (1 + Math.sqrt(3) / 2)])\r\n        let circleColor = compute_color(color_linear(importanceValue));\r\n        _this.drawCircle(svg, x, cy, r, circleColor, data, 1, \"entCircle\", \"entCircle_\" + data['id']);\r\n\r\n        r = r * Math.sqrt(3) / 2;\r\n        y += r / 2;\r\n        let path = d3.path();\r\n\r\n\r\n        path.moveTo(x - r, y);\r\n        let lineLi = [data['time']];\r\n        let linePoint = [{ 'id': data['id'], 'time': data['time'], 'x': 0, 'y': 0 }];\r\n        for (let srel in data[\"similarityRel\"]) {\r\n          let cdata = oData.find(function (d) { return d['id'] == data[\"similarityRel\"][srel] })\r\n          lineLi.push(cdata['time'])\r\n          linePoint.push({ 'id': cdata['id'], 'time': cdata['time'], 'x': 0, 'y': 0 })\r\n        }\r\n        const sortmt = (a, b) => {\r\n          return tools.time2seconds(a[0]) - tools.time2seconds(b[0]);\r\n        }\r\n        const sortlp = (a, b) => {\r\n          return tools.time2seconds(a['time'][0]) - tools.time2seconds(b['time'][0]);\r\n        }\r\n        lineLi = lineLi.sort(sortmt);\r\n        linePoint = linePoint.sort(sortlp);\r\n        let lineData = [[x - r, y]];\r\n        for (let t = 0; t < lineLi.length; t++) {\r\n          let startT = lineLi[t][0];\r\n          let endT = lineLi[t][1];\r\n          let startS = tools.time2seconds(startT);\r\n          let endS = tools.time2seconds(endT);\r\n          let duration = endS - startS;\r\n\r\n          let startx = timeLineScale_linear((startS - duration * 10));\r\n          let endx = timeLineScale_linear((endS + duration * 10));\r\n\r\n          let startyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          let startyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          let endyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          let endyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          let yz = y - timeLineHighScale_linear((duration));\r\n          let midx = timeLineScale_linear((endS + startS) / 2);\r\n          linePoint[t]['x'] = midx;\r\n          linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n          let y1 = y;\r\n          if (startx < (lineData[lineData.length - 1][0])) {\r\n            if (t > 0) {\r\n              lineData.splice(lineData.length - 3, 3);\r\n              startx = (lineData[lineData.length - 1][0] + midx) / 2;\r\n              y1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n              startyf = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n              startyf1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n            }\r\n          }\r\n          let startx1 = startx + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          let endx1 = endx - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          let startx2 = startx1 + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          let endx2 = endx1 - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          if (endx > (r + x)) endx = r + x;\r\n          if (startx1 < (lineData[lineData.length - 1][0])) startx1 = lineData[lineData.length - 1][0];\r\n          if (endx1 > (r + x)) endx1 = r + x;\r\n          if (startx2 < (lineData[lineData.length - 1][0])) startx2 = lineData[lineData.length - 1][0];\r\n          if (endx2 > (r + x)) endx2 = r + x;\r\n          lineData.push([startx, y1], [startx1, startyf1], [startx2, startyf], [midx, yz], [endx2, endyf], [endx1, endyf1], [endx, y])\r\n        }\r\n        lineData.push([x + r, y])\r\n        let curve_generator = d3.line()\r\n          .x((d) => d[0])\r\n          .y((d) => {\r\n            let h = Math.sqrt(Math.pow(r, 2) - Math.pow((d[0] - (x - r)), 2));\r\n            if ((y - d[1]) > (h + r * Math.sqrt(3) / 2))\r\n              return y - (h + r * Math.sqrt(3) / 2) + 2;\r\n            return d[1];\r\n          })\r\n          .curve(d3.curveBasis)\r\n        _this.drawTimeLine(svg, curve_generator(lineData), \"white\", 2, '0', 'sonLine ', 'sonLine ');\r\n\r\n\r\n        for (let p = 0; p < linePoint.length; p++) {\r\n          _this.drawCircle(svg, linePoint[p]['x'], linePoint[p]['y'], 5, \"red\", linePoint[p], 0, \"linePoint\", \"linePoint_\" + linePoint[p]['id']);\r\n        }\r\n\r\n        // \"1\": \"rgb(145, 204, 117)\",\r\n        //   \"2\": \"rgb(84, 112, 198)\",\r\n        //   \"3\": \"rgb(238, 102, 102)\",\r\n        let typeColor = {\r\n          \"1\": \"#ff9c9c\",\r\n          \"2\": \"#f4f4d0\",\r\n          \"3\": \"#6f8be0\",\r\n        };\r\n        let duration = tools.time2seconds(data['time'][0]) - tools.time2seconds(data['time'][1]);\r\n        let typeData = data['attribute']['expressions'];\r\n        let sonList = data['son'];\r\n        let typeArcScale_linear = d3.scaleLinear([0, duration], [0, Math.PI * 2]);\r\n\r\n        var typeStartR = 0//Math.PI/4;\r\n\r\n        var typeStepR = Math.PI / 1;\r\n\r\n        if (sonList.length > 0) {\r\n          for (let i in typeData) {\r\n            let color = typeColor[i];\r\n            let typeDurition = typeData[i];\r\n            let totalTypeSeconds = 0;\r\n            for (let d in typeDurition) {\r\n              totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n            let typeStepR = typeArcScale_linear(totalTypeSeconds)//Math.PI/2;\r\n\r\n            let endAnglet = typeStartR + 1 * typeStepR\r\n            var dataset = { startAngle: typeStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n            typeStartR = endAnglet;\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 10)\r\n              .outerRadius(r + 25);\r\n            var pathArc = arcPath(dataset);\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, color, color, 'type f' + data['id'] + \" t\" + i);\r\n          }\r\n          let sonTotal = 0;\r\n          let sonNum = 0\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n            sonTotal += sonDur;\r\n            sonNum += 1;\r\n          }\r\n          let skipArc = Math.PI / (sonNum + 2);\r\n          let timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI * 2 - skipArc * sonNum]);\r\n          let timeSonHeighLinear = d3.scaleLinear([0, sonTotal], [40, 40]);\r\n\r\n          let timeSonColor_linear = d3.scaleLinear().domain([0, sonTotal]).range([0, 1]);\r\n          let timeSonCompute_color = d3.interpolate(\"white\", circleColor);\r\n          var sonStartR = 0;//-Math.PI/2;\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n\r\n            let sonStepR = timeSonLinear(sonDur)//Math.PI/2;\r\n\r\n            let endAnglet = sonStartR + sonStepR;\r\n            var dataset = { startAngle: sonStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n            sonStartR = endAnglet;\r\n            let color = 'blue';\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 28)\r\n              .outerRadius(r + timeSonHeighLinear(sonDur));\r\n            var arcMidPath = d3.arc()\r\n              .innerRadius(0)\r\n              .outerRadius(r + 32);\r\n            var pathArc = arcPath(dataset);\r\n\r\n            endAnglet = sonStartR + skipArc;\r\n            var midDataset = { startAngle: sonStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n\r\n            let jiantouPath = d3.path();\r\n            jiantouPath.arc(x, y - r / 2, r + 32, sonStartR - Math.PI / 2, endAnglet - Math.PI / 2);\r\n\r\n            sonStartR += skipArc;\r\n            var pathMidArc = arcMidPath(midDataset);\r\n            let timeSonColor = compute_color(color_linear(sonData['attribute']['importance']));\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, timeSonColor, timeSonColor, 'son f' + data['id'] + \" s\" + sonList[s], '0');\r\n            if (s != sonList.length - 1) {\r\n              _this.drawTimeLine(svg, jiantouPath, \"rgb(200,200,200)\", 3, '9,5', 'midArc ', 'midArc ');\r\n            }\r\n          }\r\n\r\n        }\r\n\r\n\r\n      }\r\n      let txts = _this.nameinput.split(\" \")\r\n      _this.drawTxt(svg, x - r - 32, y + r + 50, r * 2 + 64, txts, \"grey\");\r\n    },\r\n    drawEntity(data) {\r\n      // d3.select(\"#editEnt\").remove()\r\n    },\r\n    // drawEntity(data) {\r\n    //   const _this = this;\r\n    //   let psvg = d3.select(\"#entG\");\r\n    //   let w = psvg.attr(\"width\");\r\n    //   let h = psvg.attr(\"height\");\r\n    //   psvg.remove();\r\n    //   let svg = d3.select(\"#editEnt\").append(\"g\").attr(\"id\", \"entG\").attr(\"width\", w).attr(\"height\", h);\r\n    //   let color_linear = _this.importanceColor_linear;\r\n    //   let compute_color = _this.importanceCompute_color;\r\n    //   let totalDurationValue = data['totalDuration'];\r\n    //   let rScale = _this.totalDurationScale_linear;\r\n    //   let r = rScale(totalDurationValue);\r\n    //   let oData = _this.data;\r\n    //   let x = svg.attr(\"width\") / 2;\r\n    //   let y = 120;\r\n    //   let importanceValue = data['attribute']['importance'];\r\n    //   let relevanceValue = data['attribute']['relevance'];\r\n    //   svg.selectAll().remove();\r\n\r\n    //   if (data['type'] == '1') {\r\n    //     let area = tools.calcTriangle(x, y, r);\r\n    //     _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n    //   }\r\n    //   else {\r\n\r\n    //     let cy = y;\r\n    //     let totalDuration = _this.totalDuration;\r\n    //     let timeLineScale_linear = d3.scaleLinear([0, totalDuration], [x - r * Math.sqrt(3) / 2, x + r * Math.sqrt(3) / 2])\r\n    //     let timeLineHighScale_linear = d3.scaleLinear([0, _this.maxDDuration], [0, r * (1 + Math.sqrt(3) / 2)])\r\n    //     let circleColor = compute_color(color_linear(importanceValue));\r\n    //     _this.drawCircle(svg, x, cy, r, circleColor, data, 1, \"entCircle\", \"entCircle_\" + data['id']);\r\n\r\n    //     r = r * Math.sqrt(3) / 2;\r\n    //     y += r / 2;\r\n    //     let path = d3.path();\r\n\r\n\r\n    //     path.moveTo(x - r, y);\r\n    //     let lineLi = [data];\r\n    //     let linePoint = [{ 'id': data['id'], 'time': data['time'], 'x': 0, 'y': 0 }];\r\n    //     let jgidL = [data['id']];\r\n    //     let similarityRelsli = [data[\"similarityRel\"]];\r\n    //     while(similarityRelsli.length>0){\r\n    //       let similarityRels = similarityRelsli[0];\r\n    //       similarityRelsli.splice(0,1);\r\n    //       let jg = 0;\r\n    //       for (let srel in similarityRels) {\r\n    //         let cdata = oData.find(function (d) { return d['id'] == similarityRels[srel] });\r\n    //         if(jgidL.indexOf(cdata['id'])==-1){\r\n    //           similarityRelsli.push(cdata[\"similarityRel\"])\r\n    //           jg=1;\r\n    //           lineLi.push(cdata)\r\n    //           jgidL.push(cdata['id'])\r\n    //           linePoint.push({ 'id': cdata['id'], 'time': cdata['time'], 'x': 0, 'y': 0 })\r\n    //         }\r\n    //       }\r\n    //       // if(jg==0){\r\n    //         // break;\r\n    //       // }\r\n    //     }\r\n        \r\n    //     const sortmt = (a, b) => {\r\n    //       return tools.time2seconds(a[0]) - tools.time2seconds(b[0]);\r\n    //     }\r\n    //     const sortlp = (a, b) => {\r\n    //       return tools.time2seconds(a['time'][0]) - tools.time2seconds(b['time'][0]);\r\n    //     }\r\n    //     console.log(lineLi);\r\n    //     lineLi = lineLi.sort(sortlp);\r\n    //     linePoint = linePoint.sort(sortlp);\r\n    //     let lineData = [[x - r * Math.sqrt(3)/2-4 , y]];\r\n    //     for (let t = 0; t < lineLi.length; t++) {\r\n    //       let startT = lineLi[t]['time'][0];\r\n    //       let duration =lineLi[t]['totalDuration']\r\n    //       // let endT = lineLi[t]['time'][1];\r\n    //       let startS = tools.time2seconds(startT);\r\n    //       let endS = startS +duration;\r\n    //       // let startx = timeLineScale_linear((startS - duration * 10));\r\n    //       // let endx = timeLineScale_linear((endS + duration * 10));\r\n    //       let limst = (x - r * Math.sqrt(3) / 2);\r\n    //       let limed = (x + r * Math.sqrt(3) / 2);\r\n    //       let startx = (limst<timeLineScale_linear((startS)))?(timeLineScale_linear((startS))):(limst);\r\n    //       let endx = (limed>timeLineScale_linear((endS)))?(timeLineScale_linear((endS))):(limed);\r\n    //       // let midx = timeLineScale_linear((endS + startS) / 2);\r\n    //       let midx = (startx+endx) / 2;\r\n    //       let ys = y;\r\n    //       let yz = y - timeLineHighScale_linear((duration));\r\n    //       linePoint[t]['x'] = midx;\r\n    //       linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n    //       // if (startx < (lineData[lineData.length - 1][0])) {\r\n    //         if (t > 0) {\r\n    //           lineData.splice(lineData.length - 1, 1);\r\n    //           midx+=t*5;\r\n    //           startx = midx-((midx-(lineData[lineData.length - 1][0] + midx) / 2))/2;\r\n    //           endx+=t*5;\r\n    //           ys = y+(y-lineData[lineData.length - 1][1])/3\r\n    //         }\r\n    //         console.log(ys)\r\n    //       // }\r\n    //       lineData.push([startx, ys],[midx, yz],[endx, y])}\r\n    //     lineData.push([x + r, y])\r\n    //     let curve_generator = d3.line()\r\n    //       .x((d) => d[0])\r\n    //       .y((d) => {\r\n    //         let h = Math.sqrt(Math.pow(r, 2) - Math.pow((d[0] - (x - r)), 2));\r\n    //         if ((y - d[1]) > (h + r * Math.sqrt(3) / 2))\r\n    //           return y - (h + r * Math.sqrt(3) / 2) + 2;\r\n    //         return d[1];\r\n    //       })\r\n    //       .curve(d3.curveBundle )\r\n    //       // .curve(d3.curveCatmullRom  )\r\n    //       // .curve(d3.curveBasis)\r\n    //     _this.drawTimeLine(svg, curve_generator(lineData), \"white\", 2, '0', 'sonLine ', 'sonLine ');\r\n\r\n\r\n    //     for (let p = 0; p < linePoint.length; p++) {\r\n    //       _this.drawCircle(svg, linePoint[p]['x'], linePoint[p]['y'], 5, \"red\", linePoint[p], 0, \"linePoint\", \"linePoint_\" + linePoint[p]['id']);\r\n    //     }\r\n\r\n    //     // \"1\": \"rgb(145, 204, 117)\",\r\n    //     //   \"2\": \"rgb(84, 112, 198)\",\r\n    //     //   \"3\": \"rgb(238, 102, 102)\",\r\n    //     let typeColor = {\r\n    //       \"1\": \"#ff9c9c\",\r\n    //       \"2\": \"#f4f4d0\",\r\n    //       \"3\": \"#6f8be0\",\r\n    //     };\r\n    //     let duration = tools.time2seconds(data['time'][0]) - tools.time2seconds(data['time'][1]);\r\n    //     let typeData = data['attribute']['expressions'];\r\n    //     let sonList = data['son'];\r\n    //     let sons = [sonList];\r\n    //     while (sons.length > 0) {\r\n    //       let curSonList = sons[0];\r\n    //       sons.splice(0, 1);\r\n    //       if (curSonList.length > 0) {\r\n    //         for (let s in curSonList) {\r\n    //           let sonData = oData.find(function (d) { return d['id'] == curSonList[s] });\r\n    //           let sonTypeData = sonData['attribute']['expressions'];\r\n\r\n    //           for (let t in sonTypeData) {\r\n    //             let typeDurition = sonTypeData[t];\r\n    //             for (let d in typeDurition) {\r\n    //                typeData[t].push(typeDurition[d])\r\n    //             }\r\n    //           }\r\n    //           sons.push(sonData['son']);\r\n    //         }\r\n    //       }\r\n    //     }\r\n    //     var typeStartR = 0//Math.PI/4;\r\n\r\n    //     var typeStepR = Math.PI / 1;\r\n\r\n    //     if (sonList.length > 0) {\r\n    //       let typeTotalDur = 0;\r\n    //       for (let t in typeData) {\r\n    //         let typeDurition = typeData[t];\r\n    //         for (let d in typeDurition) {\r\n    //           typeTotalDur += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n    //         }\r\n    //       }\r\n    //       let typeArcScale_linear = d3.scaleLinear([0, typeTotalDur], [0, Math.PI * 2]);\r\n    //       for (let i in typeData) {\r\n    //         let color = typeColor[i];\r\n    //         let typeDurition = typeData[i];\r\n    //         let totalTypeSeconds = 0;\r\n    //         for (let d in typeDurition) {\r\n    //           totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n    //         }\r\n    //         if(totalTypeSeconds>0)\r\n    //         {let typeStepR = typeArcScale_linear(totalTypeSeconds)//Math.PI/2;\r\n\r\n    //         let endAnglet = typeStartR + 1 * typeStepR\r\n    //         var dataset = { startAngle: typeStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n    //         typeStartR = endAnglet;\r\n    //         var arcPath = d3.arc()\r\n    //           .innerRadius(r + 10)\r\n    //           .outerRadius(r + 25);\r\n    //         var pathArc = arcPath(dataset);\r\n    //         _this.drawArc(svg, x, y - r / 2, pathArc, color, color, 'type f' + data['id'] + \" t\" + i);}\r\n    //       }\r\n\r\n    //       let sonTotal = 0;\r\n    //       let sonNum = 0\r\n    //       for (let s in sonList) {\r\n    //         let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n    //         let sonDur = sonData['totalDuration'];\r\n    //         sonTotal += sonDur;\r\n    //         sonNum += 1;\r\n    //       }\r\n    //       let skipArc = Math.PI / (sonNum + 2);\r\n    //       let timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI * 2 - skipArc * sonNum]);\r\n    //       let timeSonHeighLinear = d3.scaleLinear([0, sonTotal], [40, 40]);\r\n\r\n    //       let timeSonColor_linear = d3.scaleLinear().domain([0, sonTotal]).range([0, 1]);\r\n    //       let timeSonCompute_color = d3.interpolate(\"white\", circleColor);\r\n    //       var sonStartR = 0;//-Math.PI/2;\r\n    //       for (let s in sonList) {\r\n    //         let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n    //         let sonDur = sonData['totalDuration'];\r\n\r\n    //         let sonStepR = timeSonLinear(sonDur)//Math.PI/2;\r\n\r\n    //         let endAnglet = sonStartR + sonStepR;\r\n    //         var dataset = { startAngle: sonStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n    //         sonStartR = endAnglet;\r\n    //         let color = 'blue';\r\n    //         var arcPath = d3.arc()\r\n    //           .innerRadius(r + 28)\r\n    //           .outerRadius(r + timeSonHeighLinear(sonDur));\r\n    //         var arcMidPath = d3.arc()\r\n    //           .innerRadius(0)\r\n    //           .outerRadius(r + 32);\r\n    //         var pathArc = arcPath(dataset);\r\n\r\n    //         endAnglet = sonStartR + skipArc;\r\n    //         var midDataset = { startAngle: sonStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n\r\n    //         let jiantouPath = d3.path();\r\n    //         jiantouPath.arc(x, y - r / 2, r + 32, sonStartR - Math.PI / 2, endAnglet - Math.PI / 2);\r\n\r\n    //         sonStartR += skipArc;\r\n    //         var pathMidArc = arcMidPath(midDataset);\r\n    //         let timeSonColor = compute_color(color_linear(sonData['attribute']['importance']));\r\n    //         _this.drawArc(svg, x, y - r / 2, pathArc, timeSonColor, timeSonColor, 'son f' + data['id'] + \" s\" + sonList[s], '0');\r\n    //         if (s != sonList.length - 1) {\r\n    //           _this.drawTimeLine(svg, jiantouPath, \"rgb(200,200,200)\", 3, '9,5', 'midArc ', 'midArc ');\r\n    //         }\r\n    //       }\r\n\r\n    //     }\r\n\r\n\r\n    //   }\r\n    //   let txts = data['name'].split(\" \")\r\n    //   let tx = x - r - 30;\r\n    //   let ty = y + r +60;\r\n    //   let tw = r*2;\r\n    //   tx = x;\r\n    //   if(data['son'].length==0){\r\n    //     tx = x//-r-10;\r\n    //     ty = y+r*2;\r\n    //   }\r\n    //   if(data['id']==\"3\"){\r\n    //     tx = x-10;\r\n    //     ty = y+r*2;\r\n    //   }\r\n    //   if(data['id']==\"4\"){\r\n    //     tx = x+10;\r\n    //     ty = y+r*2;\r\n    //   }\r\n    //   // if(data['type']=='1'){\r\n    //   //   tx = x-r/2;\r\n    //   //   ty = y+r*2;\r\n    //   // }\r\n\r\n    //   _this.drawTxt(svg, tx, ty,tw , txts, \"grey\",22, `text_${data['id']}`);\r\n    //   // let txts = _this.nameinput.split(\" \")\r\n    //   // _this.drawTxt(svg, x - r - 32, y + r + 50, r * 2 + 64, txts, \"grey\");\r\n    // },\r\n    drawTxt(svg, x, y, width, txts, fill, fontsize = 12, idN) {\r\n      let tx = x;\r\n      let ty = y;\r\n      let preWidth = 0;\r\n      let preIdN = 0;\r\n      let pretext = ''\r\n      for (let t = 0; t < txts.length; t++) {\r\n        pretext +=\" \"+ txts[t];\r\n        let txt = svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"id\", `${idN}_${t}`)\r\n          .attr(\"fill\", fill)\r\n          .attr(\"font-size\", fontsize)\r\n          .style(\"text-anchor\", \"middle\")\r\n          .text(pretext)\r\n        let textWidth = document.getElementById(`${idN}_${t}`).getBBox().width;\r\n        if((textWidth>width)||(t==txts.length -1)){\r\n          pretext = '';\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n        else{\r\n          txt.remove()\r\n        }\r\n        preWidth += textWidth;\r\n      }\r\n    },\r\n    drawTxtOri1(svg, x, y, width, txts, fill,fontsize=12) {\r\n      let tx = x;\r\n      let ty = y;\r\n      for (let t = 0; t < txts.length; t++) {\r\n\r\n      let txt =   svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"fill\", fill)\r\n          .attr(\"font-size\",fontsize)\r\n          .style(\"text-anchor\", \"middle\")\r\n          .text(txts[t])\r\n        tx += txts[t].length * 14;\r\n        if (tx - x > width) {\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n      }\r\n    },\r\n    drawTxtOri(svg, x, y, width, txts, fill) {\r\n      let tx = x;\r\n      let ty = y;\r\n      for (let t = 0; t < txts.length; t++) {\r\n\r\n        svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"fill\", fill)\r\n          .text(txts[t])\r\n        tx += txts[t].length * 10;\r\n        if (tx - x > width) {\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n      }\r\n    },\r\n    drawTriangle(svg, color, points, stroke, opacity = 1) {\r\n      svg.append(\"polygon\")\r\n        .attr(\"points\", points)\r\n        .attr(\"fill\", color)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", \"15px\");\r\n    },\r\n    drawCircle(svg, x, y, r, fill, data, opacity, className = 'entCircle', idName) {\r\n      const _this = this;\r\n      const oData = _this.data\r\n      svg.append(\"circle\")\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"cx\", x)\r\n        .attr(\"cy\", y)\r\n        .attr(\"r\", r)\r\n        .attr(\"fill\", fill)\r\n        .on(\"mouseover\", function (d) {\r\n          d3.select(this).attr(\"r\", r * 1.1)\r\n          let classN = d3.select(this).attr(\"class\");\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 1).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1.1)\"\r\n              })\r\n\r\n            d3.selectAll(\".basicRel\")\r\n              .attr(\"class\", function (d) {\r\n                let classN = d3.select(this).attr(\"class\");\r\n                let classNList = classN.split(\" \");\r\n                let jg = 0;\r\n                for (let i = 0; i < classNList.length - 1; i++) {\r\n                  console.log('source' + data['id'], classNList[i])\r\n                  if ('source' + data['id'] == classNList[i]) { jg = 1; }\r\n                  if ('target' + data['id'] == classNList[i]) { jg = 1; }\r\n                }\r\n                if (jg == 1) {\r\n                  classN += \" activeS\";\r\n                }\r\n                return classN;\r\n              })\r\n          }\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(this).attr(\"r\", r)\r\n          let classN = d3.select(this).attr(\"class\");\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 0).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1)\"\r\n              })\r\n            d3.selectAll(\"path\")\r\n              .attr(\"class\", function (d) {\r\n                let thisSelect = d3.select(this)\r\n                let classN = thisSelect.attr(\"class\");\r\n                let classNList = classN.split(\" \")\r\n                if (classNList[classNList.length - 1] == \"activeS\") {\r\n                  classN = \"\";\r\n                  for (let i = 0; i < classNList.length - 1; i++) {\r\n                    classN += classNList[i] + \" \";\r\n                  }\r\n                }\r\n                return classN\r\n              })\r\n          }\r\n        })\r\n        .on(\"mousedown\", function (d) {\r\n          d3.select(this).attr(\"r\", r);\r\n          d3.selectAll(\".f\" + data['id'])\r\n            .attr(\"transform\", function (d) {\r\n              let transformd = d3.select(this).attr(\"transform\")\r\n              return transformd.split(\" \")[0] + \" scale(1)\"\r\n            })\r\n          let thisId = this.id.split(\"_\")[1];\r\n          let thisData = oData.find(function (a) { return a['id'] == thisId })\r\n          let thisTime = thisData['time'];\r\n          _this.click_Ent(thisTime);\r\n          // console.log(thisTime,thisId,thisData)\r\n        })\r\n      // .on(\"\")\r\n    },\r\n    drawTimeLine(svg, path, stroke, width, stroke_dasharray = \"0\", idName, className) {\r\n      svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .attr('fill', 'none')\r\n        .on('mouseover', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let idN = thisSelect.attr(\"id\");\r\n          if (classN.split(\" \")[0] == \"basicRel\") {\r\n            d3.select(this).attr(\"class\", classN + \" activeS\");\r\n          }\r\n        })\r\n        .on('mouseleave', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let classNList = classN.split(\" \")\r\n          if (classNList[classNList.length - 1] == \"activeS\") {\r\n            classN = \"\";\r\n            for (let i = 0; i < classNList.length - 1; i++) {\r\n              classN += classNList[i] + \" \";\r\n            }\r\n            d3.select(this).attr(\"class\", classN);\r\n          }\r\n        })\r\n    },\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3) {\r\n      svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n    },\r\n    updata() {\r\n      \r\n    const _this = this;\r\n      let data = _this.data;\r\n      let maxDImportance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let minDImportance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let maxDRelevance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let minDRelevance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let maxDDuration = Math.max.apply(Math, data.map(function (d) { return tools.time2seconds(d['time'][1]) - tools.time2seconds(d['time'][0]); }))\r\n      let maxTotalDuration = Math.max.apply(Math, data.map(function (d) { return d['totalDuration']; }))\r\n\r\n      _this.minDImportance = minDImportance;\r\n      _this.maxDImportance = maxDImportance;\r\n      _this.minDRelevance = minDRelevance;\r\n      _this.maxDRelevance = maxDRelevance;\r\n      _this.maxDDuration = maxDDuration;\r\n      _this.maxTotalDuration = maxTotalDuration;\r\n\r\n      let currentMaxColor = _this.importanceMaxColor;\r\n      let currentMinColor = _this.importanceMinColor;\r\n      _this.importanceColor_linear = d3.scaleLinear().domain([minDImportance, maxDImportance]).range([0, 1]);\r\n      _this.importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n      _this.relevanceScale_linear = d3.scaleLinear([minDRelevance, maxDRelevance], [20, 50])\r\n      _this.totalDurationScale_linear = d3.scaleLinear().domain([0, maxTotalDuration]).range([20, 60]);\r\n\r\n\r\n\r\n\r\n      _this.$bus.$emit(\"graphData\", _this.data);\r\n      _this.$bus.$emit(\"relData\", _this.relData);\r\n      // _this.drawtopicLine();\r\n      // _this.drawrootTree();\r\n      _this.draweditData();\r\n    },\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n  },\r\n  created() {\r\n    const _this = this;\r\n    this.$nextTick(() => {\r\n      _this.getTreeData();\r\n      _this.updata();\r\n\r\n    this.$bus.$on('selectE', (val) => {\r\n     console.log(111,val);\r\n     _this.curEntId = val;\r\n    });\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this\r\n    _this.tableData.find(function (d) { return d['key'] == 'name' })['value'] = 'Computer Network';\r\n    console.log(23213)\r\n    \r\n    this.$bus.$on('importanceLinear', (val) => {\r\n      console.log(val)\r\n      _this.importanceLinear = val;\r\n    });\r\n\r\n    \r\n    // disabled in the online demo\r\n    // this.$bus.$on('entData', (val) => {\r\n    //   _this.data = val;\r\n    // });\r\n    // this.$bus.$on('relData', (val) => {\r\n    //   _this.relData = val;\r\n    // });\r\n  },\r\n  // beforeDestroy() {\r\n  //   clearInterval(this.moveTimer);\r\n  // },\r\n} \r\n</script>\r\n\r\n<style>\r\n@import './index.css';\r\n</style>\r\n"]}]}