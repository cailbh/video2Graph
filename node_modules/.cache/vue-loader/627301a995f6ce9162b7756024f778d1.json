{"remainingRequest":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\Graph\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\Graph\\index.vue","mtime":1689658765838},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\babel-loader\\lib\\index.js","mtime":1688115046651},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js","mtime":1688115046800}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBmaWxlbmFtZXMgZnJvbSAiQC91dGlscy9maWxlTmFtZSI7DQppbXBvcnQgZG9tdG9pbWFnZSBmcm9tICdkb20tdG8taW1hZ2UnOw0KaW1wb3J0IFRlc3RKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTFfZmluLmpzb24iOw0KaW1wb3J0IFRlc3RSZWxKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTFfZmluX3JlbC5qc29uIjsNCmltcG9ydCB0b29scyBmcm9tICJAL3V0aWxzL3Rvb2xzLmpzIjsNCiANCmxldCB3b3JrZXIgPSB0b29scy5jcmVhdGVXb3JrZXJzKCk7DQpleHBvcnQgZGVmYXVsdCB7DQogIHByb3BzOiBbInZpZGVvVGltZSJdLA0KICBkYXRhKCkgew0KICAgIHJldHVybiB7DQogICAgICB3b3JrZXI6bnVsbCwNCiAgICAgIGRhdGE6IFRlc3RKc29uLA0KICAgICAgZ0RhdGE6ICJUZXN0SnNvbiIsDQogICAgICByZWxEYXRhOiBUZXN0UmVsSnNvbiwNCiAgICAgIGFzc2lzdEdUcmFuc2Zvcm1YOiAxMCwNCiAgICAgIGFzc2lzdEdUcmFuc2Zvcm1ZOiAxMDAsDQogICAgICBkcmF3RW50aXR5TG9jYXRpb246IFtdLA0KICAgICAgVmlkZW9FZGl0UGFuZWxTaG93OmZhbHNlLA0KICAgICAgc2hvd0VudGl0eUxpc3Q6IFtdLA0KICAgICAgc3dpdGNoTDogW10sDQogICAgICBvdmVyRW50aXR5SWQ6ICcnLA0KICAgICAgb3ZlclRhcmdldEVudGl0eUlkOiAnJywNCiAgICAgIHNob3dFbnRpdHlSZWxJZExpc3Q6IFtdLA0KICAgICAgc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlOiAnJywNCiAgICAgIHJvb3RFbnRpdHlMaXN0OiBbXSwNCiAgICAgIHJvb3RTdmc6IG51bGwsDQogICAgICBUaW1lQXhpc1N2ZzogbnVsbCwNCiAgICAgIGdyb3Vwc1N2ZzogbnVsbCwNCiAgICAgIGFyY0c6IG51bGwsDQogICAgICBjdXJFbnRJZDogJycsDQogICAgICBpbnNlcnRFbnRJZDogJycsDQogICAgICBlZGl0RGl2U2hvdzogZmFsc2UsDQogICAgICBtaW5ESW1wb3J0YW5jZTogMCwNCiAgICAgIG1heERJbXBvcnRhbmNlOiAwLA0KICAgICAgbWluRFJlbGV2YW5jZTogMCwNCiAgICAgIG1heERSZWxldmFuY2U6IDAsDQogICAgICBtYXhERHVyYXRpb246IDAsDQogICAgICB0aW1lQXhpc1g6IDAsDQogICAgICB0aW1lQXhpc1c6IDIwMCwNCiAgICAgIHRpbWVBeGlzRHJvcEZsYWc6IDAsDQogICAgICB0aW1lQXhpc0Rvd25YOiAwLA0KICAgICAgdGltZUF4aXNEb3duVzogNjAsDQogICAgICBtYXhUb3RhbER1cmF0aW9uOiAwLA0KICAgICAgdmlkZW9EdXJhdGlvbjogNjcyLA0KICAgICAgdG90YWxEdXJhdGlvbjogMTAwMCwNCiAgICAgIGltcG9ydGFuY2VDb2xvcl9saW5lYXI6IG51bGwsDQogICAgICBpbXBvcnRhbmNlQ29tcHV0ZV9jb2xvcjogbnVsbCwNCiAgICAgIHJlbGV2YW5jZVNjYWxlX2xpbmVhcjogbnVsbCwNCiAgICAgIHRvdGFsRHVyYXRpb25TY2FsZV9saW5lYXI6IG51bGwsDQogICAgICBzdW1Ub3RhbER1cmF0aW9uOiAwLA0KICAgICAgLy8gaW1wb3J0YW5jZU1pbkNvbG9yOiAicmdiKDEsIDE2NCwgMTgzKSIsDQogICAgICAvLyBpbXBvcnRhbmNlTWF4Q29sb3I6ICJyZ2IoMTA2LCA1MiwgMTI3KSIsDQogICAgICB6b29tSW5Vcmw6IHJlcXVpcmUoIkAvYXNzZXRzL2ltZy96b29tSW4ucG5nIiksDQogICAgICB6b29tT3V0VXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvem9vbU91dC5wbmciKSwNCiAgICAgIGVkaXRUb29sVXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvZWRpdC5wbmciKSwNCiAgICAgIGVkaXRBZGRVcmw6IHJlcXVpcmUoIkAvYXNzZXRzL2ltZy9lZGl0X0FkZC5wbmciKSwNCiAgICAgIGVkaXRBZGROVXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvZWRpdF9BZGROLnBuZyIpLA0KICAgICAgZWRpdERlbFVybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL2VkaXRfRGVsZXRlLnBuZyIpLA0KICAgICAgbGF5b3V0U2hvdzogMiwNCiAgICAgIGdyYXBoR1RyYW5zZm9ybUs6IDEsDQogICAgICBncmFwaEdUcmFuc2Zvcm1YOiAxMCwNCiAgICAgIGdyYXBoR1RyYW5zZm9ybVk6IDEwMCwNCiAgICAgIGdyYXBoR01vdmVYOiAxMCwNCiAgICAgIGdyYXBoU3ZnU2NhbGU6IDEsDQogICAgICBtb3ZlVGltZXI6IG51bGwsDQogICAgICBtb3ZlRmxhZzogZmFsc2UsDQogICAgICBpbXBvcnRhbmNlTWluQ29sb3I6ICJyZ2IoMjAzLCAyMzAsIDIwOSkiLA0KICAgICAgaW1wb3J0YW5jZU1heENvbG9yOiAicmdiKDIyLCAxNDQsIDIwNykiLA0KICAgICAgc3RlcFg6IDE1MCwNCiAgICAgIHN0ZXBZOiAxMDAsDQogICAgICBidG5SZWw6IGZhbHNlLA0KICAgICAgYnRuU2ltOiBmYWxzZSwNCiAgICAgIGJ0bkFzbzogZmFsc2UsDQogICAgICBidG5FZGk6IGZhbHNlLA0KICAgICAgY2lyY2xlSW50ZXJ2YWw6IDU1LA0KICAgICAgd2lkdGg6IDAsDQogICAgICBoZWlnaHQ6IDAsDQogICAgICBjdXJUb29sU3RhdGU6ICd1bkVkaXQnLA0KICAgICAgbWFyZ2luOiB7IHRvcDogODAsIHJpZ2h0OiAyMCwgYm90dG9tOiAwLCBsZWZ0OiAyMCB9LA0KICAgICAgY29sb3I6IFsNCiAgICAgICAgInJnYigyNTUsNjAsNjApIiwNCiAgICAgICAgInJnYigwLCAxNzgsIDE3MSkiLA0KICAgICAgICAvLyAicmdiKDI1NSw4MywyNTUpIiwNCiAgICAgICAgInJnYigyMzUsMTM1LDE2MikiLA0KICAgICAgICAicmdiKDI1NSwxNzgsMTAxKSIsDQogICAgICAgICJyZ2IoNjMsMTUxLDEzNCkiLA0KICAgICAgICAicmdiKDgzLDI1NSwyNTUpIiwNCiAgICAgICAgInJnYigwLDEyMiwyNDQpIiwNCiAgICAgICAgInJnYigxNjgsMTY4LDI1NSkiLA0KICAgICAgICAicmdiKDIwMCwyMDAsMjAwKSIsDQogICAgICBdLA0KICAgICAgbWNvbG9yOiBbDQogICAgICAgICJyZ2IoMTI1LCA2NiwgMjA2KSIsDQogICAgICAgICJyZ2IoMjQ4LCAxMzQsIDEyNCkiLA0KICAgICAgICAicmdiKDUwLCAxOTgsIDE5MSkiLA0KICAgICAgICAicmdiKDEzNSwgMTI2LCAyNTMpIiwNCiAgICAgICAgInJnYigxOTgsIDEyMSwgMTIzKSIsDQogICAgICAgICJyZ2IoMjUyLCAxNzcsIDQ5KSIsDQogICAgICAgICJyZ2IoMTEyLCAyMDIsIDIyOSkiLA0KICAgICAgXSwNCiAgICAgIC8vIG1jb2xvcjogWw0KICAgICAgLy8gICAicmdiKDkxLCAxMDcsIDI1NSkiLA0KICAgICAgLy8gICAicmdiKDAsIDE3OCwgMTcxKSIsDQogICAgICAvLyAgIC8vICJyZ2IoNiwgMjE0LCAxNjApIiwNCiAgICAgIC8vICAgInJnYigyNTUsIDEyMCwgOTApIiwNCiAgICAgIC8vICAgInJnYigxMjUsIDk4LCAyMTEpIiwNCiAgICAgIC8vICAgInJnYigyNTUsIDExMywgMjEyKSIsDQogICAgICAvLyAgICJyZ2IoMTEyLCAyMTQsIDI1NSkiLA0KICAgICAgLy8gICAicmdiKDI1NSwgMTU5LCAyOCkiLA0KICAgICAgLy8gICAicmdiKDI1NSwgNzcsIDEwOSkiLA0KICAgICAgLy8gXSwNCiAgICAgIG1EYXJrY29sb3I6IFsNCiAgICAgICAgInJnYig5NSwgMzksIDE3OSkiLA0KICAgICAgICAicmdiKDIyMSwgODMsIDcyKSIsDQogICAgICAgICJyZ2IoMCwgMTU4LCAxNDgpIiwNCiAgICAgICAgInJnYig5MywgODgsIDIwMikiLA0KICAgICAgICAicmdiKDE4MCwgNzIsIDc5KSIsDQogICAgICAgICJyZ2IoMjAyLCAxMzQsIDMyKSIsDQogICAgICAgICJyZ2IoNDYsIDE3NCwgMjAyKSIsDQogICAgICBdLA0KICAgICAgbUxpZ250Y29sb3I6IFsNCiAgICAgICAgIiNmZjljOWMiLA0KICAgICAgICAiI2NjODhiMCIsDQogICAgICAgICIjZmZhOGZmIiwNCiAgICAgICAgIiNlM2IwOTciLA0KICAgICAgICAiI2Y0YzNkMCIsDQogICAgICAgICIjZjRmNGQwIiwNCiAgICAgICAgIiNmZmQ4YjEiLA0KICAgICAgICAiIzllY2FjMiIsDQogICAgICAgICIjYThjY2ZmIiwNCiAgICAgICAgIiM5N2UzYmEiLA0KICAgICAgICAiIzZmOGJlMCIsDQogICAgICAgICJyZ2IoMCwxMjIsMjQ0KSIsDQogICAgICAgICIjYjZhMmY3IiwNCiAgICAgICAgInJnYigxNjgsMTY4LDI1NSkiLA0KICAgICAgICAicmdiKDIwMCwyMDAsMjAwKSIsDQogICAgICBdLA0KICAgICAgZWRpdFZpZGVvSmFnZTpmYWxzZSwNCiAgICAgIGVkaXRWaWRlb1NQOltdLA0KICAgICAgZWRpdFZpZGVvRVA6W10sDQogICAgfTsNCiAgfSwNCg0KICB3YXRjaDogew0KICAgIHR5cGUodmFsKSB7DQogICAgfSwNCiAgICBzd2l0Y2hMOiB7DQogICAgICBkZWVwOiB0cnVlLA0KICAgICAgaGFuZGxlcih2YWwpIHsNCiAgICAgICAgdGhpcy5idG5SZWwgPSB2YWxbMF07DQogICAgICAgIHRoaXMuYnRuU2ltID0gdmFsWzFdOw0KICAgICAgICB0aGlzLmJ0bkFzbyA9IHZhbFsyXTsNCiAgICAgICAgdGhpcy5idG5FZGkgPSB2YWxbM107DQogICAgICAgIHRoaXMudXBkYXRhUmVsKCkNCiAgICAgIH0NCiAgICB9LA0KICAgIHRpbWVBeGlzWCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLnVwZGF0YVRpbWVBeGlzRHVyKF90aGlzLlRpbWVBeGlzU3ZnLCBfdGhpcy50aW1lQXhpc1gsIF90aGlzLnRpbWVBeGlzVyk7DQogICAgfSwNCiAgICBjdXJFbnRJZCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLm92ZXJFbnRpdHlJZCA9IHZhbDsNCiAgICAgIF90aGlzLiRidXMuJGVtaXQoInNlbGVjdEVudCIsIHZhbCk7DQogICAgICBsZXQgZW50aXR5TG9jYXRpb25EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KDQogICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICBsZXQgc2hvd0phZ2VEYXRhID0gX3RoaXMuc2hvd0VudGl0eUxpc3Q7DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBiYXNpY1JlbC5sZW5ndGg7IHIrKykgew0KICAgICAgICBsZXQgc29yY2VJZCA9IGJhc2ljUmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyXVsxXTsNCiAgICAgICAgbGV0IHNvcmNlSmFnZSA9IHNob3dKYWdlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNvcmNlSWQgfSlbJ3Nob3cnXTsNCiAgICAgICAgbGV0IHRhcmdldEphZ2UgPSBzaG93SmFnZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSB0YXJnZXRJZCB9KVsnc2hvdyddOw0KICAgICAgICBpZiAoc29yY2VKYWdlICYmIHRhcmdldEphZ2UpIHsNCiAgICAgICAgICBsZXQgdHJuSWQgPSAnLTEnOw0KICAgICAgICAgIGlmIChzb3JjZUlkID09IHBhcnNlSW50KHZhbCkpIHsNCiAgICAgICAgICAgIHRybklkID0gdGFyZ2V0SWQ7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKHRhcmdldElkID09IHBhcnNlSW50KHZhbCkpIHsNCiAgICAgICAgICAgIHRybklkID0gc29yY2VJZDsNCiAgICAgICAgICB9DQogICAgICAgICAgaWYgKHRybklkICE9ICctMScpIHsNCiAgICAgICAgICAgIGxldCBjdXJFbnQgPSBlbnRpdHlMb2NhdGlvbkRhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcGFyc2VJbnQoZFsnaWQnXSkgPT0gdHJuSWQgfSk7DQogICAgICAgICAgICBfdGhpcy5hc3Npc3RHVHJhbnNmb3JtWCA9IHBhcnNlSW50KC1jdXJFbnRbJ3gnXSkgKyBwYXJzZUZsb2F0KGN1ckVudFsnciddKSArIDE1MDsNCiAgICAgICAgICAgIF90aGlzLmFzc2lzdEdUcmFuc2Zvcm1ZID0gcGFyc2VJbnQoLWN1ckVudFsneSddKSArIHBhcnNlRmxvYXQoY3VyRW50WydyJ10pICsgMzAwOw0KICAgICAgICAgICAgX3RoaXMudXBkYXRhQXNzaXN0R3JhcGhQYW5lbCgpOw0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KDQogICAgICB9Ow0KICAgICAgbGV0IHNpbWlsYXJpdHlSZWwgPSByZWxEYXRhWydzaW1pbGFyaXR5UmVsJ107DQogICAgICBmb3IgKGxldCByID0gMDsgciA8IHNpbWlsYXJpdHlSZWwubGVuZ3RoOyByKyspIHsNCiAgICAgICAgbGV0IHNvcmNlSWQgPSBzaW1pbGFyaXR5UmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzaW1pbGFyaXR5UmVsW3JdWzFdOw0KICAgICAgICBsZXQgc29yY2VKYWdlID0gc2hvd0phZ2VEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KVsnc2hvdyddOw0KICAgICAgICBsZXQgdGFyZ2V0SmFnZSA9IHNob3dKYWdlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pWydzaG93J107DQogICAgICAgIGlmIChzb3JjZUphZ2UgJiYgdGFyZ2V0SmFnZSkgew0KICAgICAgICAgIGxldCB0cm5JZCA9ICctMSc7DQogICAgICAgICAgaWYgKHNvcmNlSWQgPT0gcGFyc2VJbnQodmFsKSkgew0KICAgICAgICAgICAgdHJuSWQgPSB0YXJnZXRJZDsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAodGFyZ2V0SWQgPT0gcGFyc2VJbnQodmFsKSkgew0KICAgICAgICAgICAgdHJuSWQgPSBzb3JjZUlkOw0KICAgICAgICAgIH0NCiAgICAgICAgICBpZiAodHJuSWQgIT0gJy0xJykgew0KICAgICAgICAgICAgbGV0IGN1ckVudCA9IGVudGl0eUxvY2F0aW9uRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBwYXJzZUludChkWydpZCddKSA9PSB0cm5JZCB9KTsNCiAgICAgICAgICAgIF90aGlzLmFzc2lzdEdUcmFuc2Zvcm1YID0gcGFyc2VJbnQoLWN1ckVudFsneCddKSArIHBhcnNlRmxvYXQoY3VyRW50WydyJ10pICsgMTUwOw0KICAgICAgICAgICAgX3RoaXMuYXNzaXN0R1RyYW5zZm9ybVkgPSBwYXJzZUludCgtY3VyRW50Wyd5J10pICsgcGFyc2VGbG9hdChjdXJFbnRbJ3InXSkgKyAzMDA7DQogICAgICAgICAgICBfdGhpcy51cGRhdGFBc3Npc3RHcmFwaFBhbmVsKCk7DQogICAgICAgICAgfQ0KICAgICAgICB9DQoNCiAgICAgIH07DQoNCg0KICAgIH0sDQogICAgb3ZlckVudGl0eUlkKHZhbCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KDQogICAgICBfdGhpcy4kYnVzLiRlbWl0KCJvdmVyRW50aXR5SWQiLCB2YWwpOw0KICAgICAgbGV0IHJlbExpc3QgPSBbXTsNCiAgICAgIGxldCByZWxSb290TGlzdCA9IFtdOw0KICAgICAgbGV0IHJlbERhdGEgPSBfdGhpcy5yZWxEYXRhOw0KICAgICAgbGV0IG9EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgbGV0IGJhc2ljUmVsID0gcmVsRGF0YVsnYmFzaWNSZWwnXTsNCiAgICAgIGQzLnNlbGVjdEFsbCgnLnRpbWVUZXh0JykuYXR0cigib3BhY2l0eSIsIDApDQogICAgICBkMy5zZWxlY3RBbGwoJy50aW1lQXhpc0VudCcpLmF0dHIoInN0cm9rZS13aWR0aCIsIDApLmF0dHIoIm9wYWNpdHkiLCAwLjQpLmF0dHIoInN0cm9rZSIsIGZ1bmN0aW9uICgpIHsNCiAgICAgICAgbGV0IGNpZCA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV07DQogICAgICAgIGxldCBuZCA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gY2lkIH0pOw0KICAgICAgICByZXR1cm4gbmRbJ2NvbG9yRCddDQogICAgICB9KTsNCiAgICAgIGZvciAobGV0IHJlID0gMDsgcmUgPCBiYXNpY1JlbC5sZW5ndGg7IHJlKyspIHsNCg0KICAgICAgICBsZXQgc29yY2VJZCA9IGJhc2ljUmVsW3JlXVswXTsNCiAgICAgICAgbGV0IHRhcmdldElkID0gYmFzaWNSZWxbcmVdWzFdOw0KICAgICAgICBsZXQgY05vZGUgPSAnJzsNCiAgICAgICAgaWYgKHNvcmNlSWQgPT0gdmFsKSB7DQogICAgICAgICAgY05vZGUgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pOw0KICAgICAgICAgIHJlbExpc3QucHVzaCh0YXJnZXRJZCk7DQogICAgICAgICAgcmVsUm9vdExpc3QucHVzaChjTm9kZVsncm9vdEluZGV4J10pOw0KICAgICAgICB9DQoNCiAgICAgICAgaWYgKHRhcmdldElkID09IHZhbCkgew0KICAgICAgICAgIGNOb2RlID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb3JjZUlkIH0pOw0KICAgICAgICAgIHJlbExpc3QucHVzaChzb3JjZUlkKTsNCiAgICAgICAgICByZWxSb290TGlzdC5wdXNoKGNOb2RlWydyb290SW5kZXgnXSk7DQogICAgICAgIH0NCiAgICAgIH07DQogICAgICByZWxMaXN0LmZvckVhY2goKHNlbGYsIGluZHgsIGFycikgPT4gew0KDQogICAgICAgIGQzLnNlbGVjdChgI3RpbWVBeGlzRW50XyR7c2VsZn1gKS5hdHRyKCJzdHJva2UiLCAnd2hpdGUnKS5hdHRyKCJzdHJva2Utd2lkdGgiLCAyKS5hdHRyKCJvcGFjaXR5IiwgMSk7DQogICAgICAgIGQzLnNlbGVjdChgI3RpbWVUZXh0XyR7c2VsZn1fMGApLmF0dHIoIm9wYWNpdHkiLCAxKTsNCiAgICAgIH0pDQogICAgICBkMy5zZWxlY3QoYCN0aW1lQXhpc0VudF8ke3ZhbH1gKS5hdHRyKCJzdHJva2Utd2lkdGgiLCAyKS5hdHRyKCJvcGFjaXR5IiwgMSk7DQogICAgICBkMy5zZWxlY3QoYCN0aW1lVGV4dF8ke3ZhbH1fMGApLmF0dHIoIm9wYWNpdHkiLCAxKTsNCiAgICB9LA0KICAgIHNob3dFbnRpdHlSZWxJZExpc3QodmFsKSB7DQogICAgICB0aGlzLnVwZGF0YVJlbCgpOw0KICAgIH0sDQogICAgZ3JvdXBzU3ZnOiB7DQogICAgICBkZWVwOiB0cnVlLA0KICAgICAgaGFuZGxlcigpIHsNCiAgICAgICAgdGhpcy51cGRhdGFBc3Npc3RHcmFwaFBhbmVsKCk7DQogICAgICB9DQogICAgfSwNCiAgICBnRGF0YSh2YWwpIHsNCiAgICB9LA0KICAgIGxheW91dFNob3codmFsKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgc2hvd0VudGl0eUxpc3QgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuZGF0YSk7DQogICAgICBmb3IgKGxldCBlIGluIHNob3dFbnRpdHlMaXN0KSB7DQogICAgICAgIGlmIChwYXJzZUludChzaG93RW50aXR5TGlzdFtlXVsnbGF5b3V0J10pIDwgcGFyc2VJbnQodmFsKSkNCiAgICAgICAgICBzaG93RW50aXR5TGlzdFtlXVsnc2hvdyddID0gdHJ1ZTsNCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgc2hvd0VudGl0eUxpc3RbZV1bJ3Nob3cnXSA9IGZhbHNlOw0KICAgICAgICB9DQogICAgICB9DQogICAgICBfdGhpcy5zaG93RW50aXR5TGlzdCA9IHNob3dFbnRpdHlMaXN0Ow0KICAgICAgX3RoaXMudXBkYXRhR3JhcGgoKTsNCiAgICB9LA0KICAgIGRhdGEodmFsKSB7DQogICAgfSwNCiAgICB2aWRlb1RpbWUodmFsKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50aXR5TG9jYXRpb25EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBlbnRpdHlMb2NhdGlvbkRhdGEubGVuZ3RoOyBlKyspIHsNCiAgICAgICAgbGV0IGN1ckQgPSBlbnRpdHlMb2NhdGlvbkRhdGFbZV07DQogICAgICAgIGxldCB0aW1lU3RhcnQgPSB0b29scy50aW1lMnNlY29uZHMoZW50aXR5TG9jYXRpb25EYXRhW2VdWyd0aW1lJ11bMF0pOw0KICAgICAgICBsZXQgdGltZUVuZCA9IHRvb2xzLnRpbWUyc2Vjb25kcyhlbnRpdHlMb2NhdGlvbkRhdGFbZV1bJ3RpbWUnXVsxXSk7DQogICAgICAgIGlmICgodmFsID4gdGltZVN0YXJ0KSAmJiAodmFsIDwgdGltZUVuZCkpIHsNCiAgICAgICAgICBsZXQgZW50WCA9IGVudGl0eUxvY2F0aW9uRGF0YVtlXVsneCddOw0KICAgICAgICAgIGxldCBlbnRZID0gZW50aXR5TG9jYXRpb25EYXRhW2VdWyd5J107DQogICAgICAgICAgbGV0IGVudFIgPSBlbnRpdHlMb2NhdGlvbkRhdGFbZV1bJ3InXTsNCiAgICAgICAgICBsZXQgbW92ZUxpbmVhciA9IGQzLnNjYWxlTGluZWFyKFt0aW1lU3RhcnQsIHRpbWVFbmRdLCBbZW50WCAtIGVudFIsIGVudFggKyBlbnRSXSkNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YID0gLW1vdmVMaW5lYXIoKHZhbCkpOw0KICAgICAgICB9DQogICAgICB9DQogICAgfSwNCiAgICBncmFwaEdNb3ZlWCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBkYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgbGV0IHN0amcgPSAwOw0KICAgICAgbGV0IGVuamcgPSAwOw0KICAgICAgbGV0IHNub2RlID0gJyc7DQogICAgICBsZXQgZW5vZGUgPSAnJzsNCiAgICAgIGxldCB3aWR0aCA9IDE1OTANCiAgICAgIGRhdGEuZm9yRWFjaCgoc2VsZiwgaW5keCwgYXJyKSA9PiB7DQogICAgICAgIGxldCBlbnR4ID0gc2VsZlsneCddICogX3RoaXMuZ3JhcGhHVHJhbnNmb3JtSzsNCiAgICAgICAgbGV0IHRyYW5zZm9ybVggPSBlbnR4ICsgdmFsOw0KICAgICAgICBpZiAoKHRyYW5zZm9ybVggPiAwKSAmJiAodHJhbnNmb3JtWCA8IHdpZHRoKSkgew0KICAgICAgICAgIHN0amcrKzsNCiAgICAgICAgfQ0KICAgICAgICBlbHNlIHsNCiAgICAgICAgICBpZiAoKHN0amcgPiAwKSAmJiBlbmpnID09IDApIHsNCiAgICAgICAgICAgIGVub2RlID0gc2VsZjsNCiAgICAgICAgICAgIGVuamcgPSAxDQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIGlmIChzdGpnID09IDEpIHsNCiAgICAgICAgICBzbm9kZSA9IHNlbGYNCiAgICAgICAgfQ0KICAgICAgfSkNCiAgICAgIGxldCBldyA9IGVub2RlWyd0aW1lVyddOw0KICAgICAgaWYgKHNub2RlID09ICcnKSB7DQogICAgICAgIF90aGlzLnRpbWVBeGlzWCA9IDANCiAgICAgIH0NCiAgICAgIGVsc2UNCiAgICAgICAgX3RoaXMudGltZUF4aXNYID0gc25vZGVbJ3RpbWVYJ107DQogICAgICBfdGhpcy50aW1lQXhpc1cgPSBlbm9kZVsndGltZVgnXSAtIHNub2RlWyd0aW1lWCddICsgZW5vZGVbJ3RpbWVXJ10NCiAgICAgIGlmIChldyA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgX3RoaXMudGltZUF4aXNXID0gd2lkdGggLSBzbm9kZVsndGltZVgnXQ0KICAgICAgfQ0KICAgIH0sDQogICAgZ3JhcGhHVHJhbnNmb3JtWCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBncm91cHMgPSBfdGhpcy5ncm91cHNTdmc7DQogICAgICBfdGhpcy5ncmFwaEdNb3ZlWCA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVg7DQogICAgICBsZXQgZ3JhcGhHVHJhbnNmb3JtWCA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVg7DQogICAgICBsZXQgZ3JhcGhHVHJhbnNmb3JtWSA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVk7DQogICAgICBsZXQgZ3JhcGhHVHJhbnNmb3JtSyA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybUs7DQogICAgICBncm91cHMuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgZ3JhcGhHVHJhbnNmb3JtWCArICcsJyArIGdyYXBoR1RyYW5zZm9ybVkgKyAiKSBzY2FsZSgiICsgZ3JhcGhHVHJhbnNmb3JtSyArICIpIik7DQogICAgfQ0KICB9LA0KICBtZXRob2RzOiB7DQogICAgYWRkTm9kZSgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLlZpZGVvRWRpdFBhbmVsU2hvdyA9IHRydWUsDQogICAgICBfdGhpcy5lZGl0RGl2U2hvdyA9IGZhbHNlOw0KICAgICAgZDMuc2VsZWN0KCIjVmlkZW9FZGl0UGFuZWwiKS5zZWxlY3QoInN2ZyIpLnJlbW92ZSgpDQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjVmlkZW9FZGl0UGFuZWwiKS5hcHBlbmQoInN2ZyIpDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsICI5NDYiKQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgIjU1MyIpOw0KICAgICAgc3ZnLm9uKCJtb3VzZWRvd24iLGZ1bmN0aW9uKGQpew0KICAgICAgICBfdGhpcy5lZGl0VmlkZW9TUCA9IFtkLmxheWVyWCxkLmxheWVyWV07DQogICAgICAgIF90aGlzLmVkaXRWaWRlb0phZ2UgPSB0cnVlOw0KICAgICAgfSkub24oIm1vdXNlbW92ZSIsZnVuY3Rpb24oZCl7DQogICAgICAgIGlmKF90aGlzLmVkaXRWaWRlb0phZ2Upew0KICAgICAgICBsZXQgc1AgPSBfdGhpcy5lZGl0VmlkZW9TUDsNCiAgICAgICAgX3RoaXMuZWRpdFZpZGVvRVAgPSBbZC5sYXllclgsZC5sYXllclldOw0KICAgICAgICBsZXQgZVAgPSAgW2QubGF5ZXJYLGQubGF5ZXJZXTsNCiAgICAgICAgbGV0IGVYICA9IHNQWzBdPmVQWzBdP3NQWzBdOmVQWzBdOw0KICAgICAgICBsZXQgZVkgID0gc1BbMV0+ZVBbMV0/c1BbMV06ZVBbMV07DQogICAgICAgIGxldCBzWCAgPSBzUFswXTxlUFswXT9zUFswXTplUFswXTsNCiAgICAgICAgbGV0IHNZICA9IHNQWzFdPGVQWzFdP3NQWzFdOmVQWzFdOw0KICAgICAgICBfdGhpcy5kcmF3UmVjdChzdmcsc1ggLCBzWSwgTWF0aC5hYnMoZVgtc1gpLCBNYXRoLmFicyhlWSAtIHNZKSwgMCwwLCJyZ2JhKDAsMCwwLDApIiwxLCAicmVkIiwgYHZpZGVvUmVjdGApfQ0KICAgICAgfSkub24oIm1vdXNldXAiLGZ1bmN0aW9uKGQpew0KICAgICAgICBfdGhpcy5lZGl0VmlkZW9KYWdlID0gZmFsc2U7DQogICAgICAgIA0KICAgICAgICBsZXQgc1AgPSBfdGhpcy5lZGl0VmlkZW9TUDsNCiAgICAgICAgbGV0IGVQID0gX3RoaXMuZWRpdFZpZGVvRVA7DQoNCiAgICAgICAgbGV0IGVYICA9IHNQWzBdPmVQWzBdP3NQWzBdOmVQWzBdOw0KICAgICAgICBsZXQgZVkgID0gc1BbMV0+ZVBbMV0/c1BbMV06ZVBbMV07DQogICAgICAgIGxldCBzWCAgPSBzUFswXTxlUFswXT9zUFswXTplUFswXTsNCiAgICAgICAgbGV0IHNZICA9IHNQWzFdPGVQWzFdP3NQWzFdOmVQWzFdOw0KICAgICAgICANCiAgICAgICAgdmFyIHBsYXllciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJwbGF5VmlkZW8iKTsgICAvL+iOt+WPlnZpZGVv55qERG9t6IqC54K5DQogICAgICAgIHBsYXllci5zZXRBdHRyaWJ1dGUoImNyb3NzT3JpZ2luIiwgImFub255bW91cyIpOyAgLy/mt7vliqBzcm9zc09yaWdpbuWxnuaAp++8jOino+WGs+i3qOWfn+mXrumimA0KICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7DQogICAgICAgIA0KICAgICAgICBjYW52YXMud2lkdGggPSBwbGF5ZXIuY2xpZW50V2lkdGg7DQogICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwbGF5ZXIuY2xpZW50SGVpZ2h0Ow0KICAgICAgICAvLyBjYW52YXMgPSBjYW52YXMuZ2V0Q29udGV4dCgiMmQiKQ0KICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgiMmQiKS5kcmF3SW1hZ2UocGxheWVyICwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsvL+aIqg0KICAgICAgICBjb25zdCBkYXRhID0gY2FudmFzLmdldENvbnRleHQoIjJkIikuZ2V0SW1hZ2VEYXRhKHNYICwgc1ksIE1hdGguYWJzKGVYLXNYKSwgTWF0aC5hYnMoZVkgLSBzWSkpOw0KICAgICAgICB2YXIgY2FudmFzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpOw0KICAgICAgICBjYW52YXNzLmdldENvbnRleHQoIjJkIikucHV0SW1hZ2VEYXRhKGRhdGEsIDAsMCkNCiAgICAgICAgdmFyIGRhdGFVUkwgPSBjYW52YXNzLnRvRGF0YVVSTCgiaW1hZ2UvcG5nIik7ICAvL+WwhuWbvueJh+i9rOaIkGJhc2U2NOagvOW8jw0KICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7DQogICAgICAgIF90aGlzLnJlY29nbml6ZTAoKTsNCiAgICAgICAgLy8gaW1nLnNyYyA9IGRhdGFVUkwNCiAgICAgICAgLy8gY29uc3QgcmVzID0gX3RoaXMuc2NoZWR1bGVyLmFkZEpvYigncmVjb2duaXplJywgY2FudmFzcyk7DQogICAgICAgIC8vIGNvbnN0IGRhdGFzID0gX3RoaXMud29ya2VyLnJlY29nbml6ZShkYXRhKTsNCiAgICAgICAgLy8gY29uc29sZS5sb2cocmVzKQ0KICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiVmlkZW9FZGl0UGFuZWwiKS5hcHBlbmRDaGlsZChpbWcpOyAgIC8v5pi+56S65Zyo6aG16Z2i5LitDQogICAgICAgIC8vIHZhciBzdHJpbmcgPSBvY3JhZChkYXRhKTsNCiAgICAgICAgLy8gY29uc29sZS5sb2coc3RyaW5nKQ0KICAgICAgICAvLyBhbGVydChzdHJpbmcpOw0KICAgICAgfSkNCiAgICB9LA0KICAgIC8vIFZpZGVvRWRpdFBhbmVsU2hvdyh2YWwpIHsNCiAgICAvLyAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAvLyAgIGlmICh2YWwpIHsNCiAgICAvLyAgICAgbGV0IHdpZHRoID0gX3RoaXMuJHJlZnMuVmlkZW9FZGl0UGFuZWwub2Zmc2V0V2lkdGg7DQogICAgLy8gICAgIGxldCBoZWlnaHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiVmlkZW9FZGl0UGFuZWwiKS5jbGllbnRIZWlnaHQ7DQogICAgLy8gICAgIGQzLnNlbGVjdCgiI1ZpZGVvRWRpdFBhbmVsIikuc2VsZWN0KCJzdmciKS5yZW1vdmUoKQ0KICAgIC8vICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjVmlkZW9FZGl0UGFuZWwiKS5hcHBlbmQoInN2ZyIpDQogICAgLy8gICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgLy8gICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgLy8gICB9DQogICAgLy8gfSwNCiAgICBhZGROb2RlTigpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLmVkaXREaXZTaG93ID0gZmFsc2U7DQoNCiAgICB9LA0KICAgIGRlbE5vZGUoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBfdGhpcy5lZGl0RGl2U2hvdyA9IGZhbHNlOw0KICAgIH0sDQogICAgZWRpdFRvb2xDbGsoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBpZiAoX3RoaXMuY3VyVG9vbFN0YXRlID09ICdlZGl0JykgX3RoaXMuY3VyVG9vbFN0YXRlID0gJ3VuRWRpdCc7DQogICAgICBlbHNlIGlmIChfdGhpcy5jdXJUb29sU3RhdGUgIT0gJ2VkaXQnKSBfdGhpcy5jdXJUb29sU3RhdGUgPSAnZWRpdCc7DQogICAgICB0aGlzLiRlbWl0KCJ0b29sU3RhdGUiLCB0aGlzLmN1clRvb2xTdGF0ZSk7DQogICAgfSwNCiAgICB1cGRhdGFSZWwoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICBsZXQgb0RhdGEgPSBfdGhpcy5kcmF3RW50aXR5TG9jYXRpb247DQogICAgICBsZXQgc2hvd0phZ2VEYXRhID0gX3RoaXMuc2hvd0VudGl0eUxpc3Q7DQogICAgICBsZXQgc2hvd1JlbCA9IF90aGlzLnNob3dFbnRpdHlSZWxJZExpc3Q7DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KDQogICAgICBpZiAoX3RoaXMuYnRuUmVsKSB7DQogICAgICAgIGlmIChfdGhpcy5idG5TaW0pIHsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5zaW1pbGFyaXR5UmVsJykuYXR0cignb3BhY2l0eScsIDEpOw0KICAgICAgICB9DQogICAgICAgIGVsc2UgaWYgKCFfdGhpcy5idG5TaW0pIHsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5zaW1pbGFyaXR5UmVsJykuYXR0cignb3BhY2l0eScsIDApOw0KICAgICAgICB9DQogICAgICAgIGlmIChfdGhpcy5idG5Bc28pIHsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5iYXNpY1JlbCcpLmF0dHIoJ29wYWNpdHknLCAxKTsNCiAgICAgICAgfQ0KICAgICAgICBlbHNlIGlmICghX3RoaXMuYnRuQXNvKSB7DQogICAgICAgICAgZDMuc2VsZWN0QWxsKCcuYmFzaWNSZWwnKS5hdHRyKCdvcGFjaXR5JywgMCk7DQogICAgICAgIH0NCiAgICAgICAgLy8gZDMuc2VsZWN0QWxsKCcuc2ltaWxhcml0eVJlbCcpLmF0dHIoJ29wYWNpdHknLCAxKTsNCiAgICAgICAgLy8gZDMuc2VsZWN0QWxsKCcuYmFzaWNSZWwnKS5hdHRyKCdvcGFjaXR5JywgMSk7DQogICAgICB9DQogICAgICBlbHNlIGlmICghX3RoaXMuYnRuUmVsKSB7DQogICAgICAgIGQzLnNlbGVjdEFsbCgnLnNpbWlsYXJpdHlSZWwnKS5hdHRyKCdvcGFjaXR5JywgMCk7DQogICAgICAgIGQzLnNlbGVjdEFsbCgnLmJhc2ljUmVsJykuYXR0cignb3BhY2l0eScsIDApOw0KICAgICAgfQ0KICAgICAgaWYgKCFfdGhpcy5idG5SZWwgfHwgIV90aGlzLmJ0bkFzbykgew0KICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IGJhc2ljUmVsLmxlbmd0aDsgcisrKSB7DQogICAgICAgICAgbGV0IHNvcmNlSWQgPSBiYXNpY1JlbFtyXVswXTsNCiAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyXVsxXTsNCiAgICAgICAgICBsZXQgaWROID0gImJhc2ljUmVsIiArIHNvcmNlSWQgKyAiXyIgKyB0YXJnZXRJZDsNCiAgICAgICAgICBpZiAoX3RoaXMub3ZlclRhcmdldEVudGl0eUlkID09ICcnKSB7DQogICAgICAgICAgICBpZiAoKHNob3dSZWwuaW5jbHVkZXMoc29yY2VJZCkpIHx8IChzaG93UmVsLmluY2x1ZGVzKHRhcmdldElkKSkpIHsNCiAgICAgICAgICAgICAgZDMuc2VsZWN0KGAjJHtpZE59YCkuYXR0cignb3BhY2l0eScsIDEpLmF0dHIoJ3N0cm9rZScsICdkYXJrc2xhdGVibHVlJykNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICBkMy5zZWxlY3QoYCMke2lkTn1gKS5hdHRyKCdvcGFjaXR5JywgMCkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQoNCiAgICAgICAgICAgIGlmICgoc2hvd1JlbC5pbmNsdWRlcyhzb3JjZUlkICsgJycpKSB8fCAoc2hvd1JlbC5pbmNsdWRlcyh0YXJnZXRJZCArICcnKSkpIHsNCiAgICAgICAgICAgICAgZDMuc2VsZWN0KGAjJHtpZE59YCkuYXR0cignb3BhY2l0eScsIDEpLmF0dHIoJ3N0cm9rZScsICdncmV5JykNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICBkMy5zZWxlY3QoYCMke2lkTn1gKS5hdHRyKCdvcGFjaXR5JywgMCkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICgoc2hvd1JlbC5pbmNsdWRlcyhzb3JjZUlkICsgJycpKSAmJiAodGFyZ2V0SWQgPT0gX3RoaXMub3ZlclRhcmdldEVudGl0eUlkKSkgew0KICAgICAgICAgICAgICBkMy5zZWxlY3QoYCMke2lkTn1gKS5hdHRyKCdvcGFjaXR5JywgMSkuYXR0cignc3Ryb2tlJywgJ2RhcmtzbGF0ZWJsdWUnKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSBpZiAoKHNob3dSZWwuaW5jbHVkZXModGFyZ2V0SWQgKyAnJykpICYmIChzb3JjZUlkID09IF90aGlzLm92ZXJUYXJnZXRFbnRpdHlJZCkpIHsNCiAgICAgICAgICAgICAgZDMuc2VsZWN0KGAjJHtpZE59YCkuYXR0cignb3BhY2l0eScsIDEpLmF0dHIoJ3N0cm9rZScsICdkYXJrc2xhdGVibHVlJykNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgIH07DQogICAgICB9DQogICAgfSwNCiAgICBkcmF3UmVsYXRpb25zaGlwTGluZShzdmcpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCByZWxEYXRhID0gX3RoaXMucmVsRGF0YTsNCiAgICAgIGxldCBvRGF0YSA9IF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbjsNCiAgICAgIGxldCBzaG93SmFnZURhdGEgPSBfdGhpcy5zaG93RW50aXR5TGlzdDsNCiAgICAgIGxldCBtYXJnaW4gPSBfdGhpcy5tYXJnaW47DQogICAgICBsZXQgaGVpZ2h0ID0gc3ZnLmF0dHIoJ2hlaWdodCcpOw0KICAgICAgbGV0IGJhc2ljUmVsID0gcmVsRGF0YVsnYmFzaWNSZWwnXTsNCiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgYmFzaWNSZWwubGVuZ3RoOyByKyspIHsNCg0KICAgICAgICBsZXQgc29yY2VJZCA9IGJhc2ljUmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyXVsxXTsNCiAgICAgICAgbGV0IGlkTiA9ICJiYXNpY1JlbCIgKyBzb3JjZUlkICsgIl8iICsgdGFyZ2V0SWQ7DQogICAgICAgIGxldCBjbGFzc04gPSAiYmFzaWNSZWwgc291cmNlIiArIHNvcmNlSWQgKyAiIHRhcmdldCIgKyB0YXJnZXRJZDsNCiAgICAgICAgbGV0IHNvcmNlTm9kZSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KTsNCiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pOw0KICAgICAgICBsZXQgc29yY2VKYWdlID0gc2hvd0phZ2VEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KVsnc2hvdyddOw0KICAgICAgICBsZXQgdGFyZ2V0SmFnZSA9IHNob3dKYWdlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pWydzaG93J107DQogICAgICAgIGlmIChzb3JjZUphZ2UgJiYgdGFyZ2V0SmFnZSkgew0KICAgICAgICAgIGlmIChzb3JjZU5vZGVbJ3gnXSA+IHRhcmdldE5vZGVbJ3gnXSkgew0KICAgICAgICAgICAgbGV0IHRwID0gc29yY2VOb2RlOw0KICAgICAgICAgICAgc29yY2VOb2RlID0gdGFyZ2V0Tm9kZTsNCiAgICAgICAgICAgIHRhcmdldE5vZGUgPSB0cDsNCiAgICAgICAgICB9DQogICAgICAgICAgY29uc3QgcGF0aCA9IGQzLnBhdGgoKTsNCg0KICAgICAgICAgIGxldCBzdGFydFggPSBzb3JjZU5vZGVbJ3gnXTsNCiAgICAgICAgICBsZXQgZW5kWCA9IHRhcmdldE5vZGVbJ3gnXTsNCiAgICAgICAgICBsZXQgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7DQogICAgICAgICAgbGV0IGZsYWcgPSAoKHNvcmNlTm9kZVsnc29uRmxhZyddKSB8fCAodGFyZ2V0Tm9kZVsnc29uRmxhZyddKSk7DQogICAgICAgICAgLy8gaWYoKHRhcmdldE5vZGVbJ2lkJ10gPT0gIjQiKXx8KChzb3JjZU5vZGVbJ2lkJ109PSIxIikmJih0YXJnZXROb2RlWydpZCddPT0iNiIpKXx8KChzb3JjZU5vZGVbJ2lkJ109PSIyIikmJih0YXJnZXROb2RlWydpZCddPT0iNyIpKXx8KChzb3JjZU5vZGVbJ2lkJ109PSIzIikmJih0YXJnZXROb2RlWydpZCddPT0iOCIpKSl7DQogICAgICAgICAgLy8gICBmbGFnID0gdHJ1ZTsNCiAgICAgICAgICAvLyB9DQogICAgICAgICAgaWYgKHRhcmdldE5vZGVbJ2lkJ10gPT0gIjQiKSB7DQogICAgICAgICAgICBmbGFnID0gdHJ1ZTsNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gaWYodGFyZ2V0Tm9kZVsnaWQnXSA9PSAiMzAiKXsNCiAgICAgICAgICAvLyAgIGZsYWcgPSB0cnVlOw0KICAgICAgICAgIC8vIH0NCiAgICAgICAgICBsZXQgcnNvdXJjZWludCA9IChzb3JjZU5vZGVbJ3NvbkZsYWcnXSkgPyAoMjApIDogKDIpOw0KICAgICAgICAgIGxldCBydGFyZ2V0aW50ID0gKHRhcmdldE5vZGVbJ3NvbkZsYWcnXSkgPyAoMjApIDogKDIpOw0KICAgICAgICAgIGxldCBzdGFydFkgPSAoZmxhZykgPyAoc29yY2VOb2RlWyd5J10gLSBzb3JjZU5vZGVbJ3InXSAtIHJzb3VyY2VpbnQpIDogKHNvcmNlTm9kZVsneSddICsgc29yY2VOb2RlWydyJ10gKyByc291cmNlaW50KTsNCiAgICAgICAgICBsZXQgZW5kWSA9IChmbGFnKSA/ICh0YXJnZXROb2RlWyd5J10gLSB0YXJnZXROb2RlWydyJ10gLSBydGFyZ2V0aW50KSA6ICh0YXJnZXROb2RlWyd5J10gKyB0YXJnZXROb2RlWydyJ10gKyBydGFyZ2V0aW50KTsNCg0KICAgICAgICAgIGxldCBjbngxID0gc3RhcnRYIC0gNTA7DQogICAgICAgICAgbGV0IGNueDIgPSBlbmRYICsgNTA7DQogICAgICAgICAgbGV0IG1pZFkgPSAoc3RhcnRZICsgZW5kWSkgLyAyOw0KICAgICAgICAgIC8vIGlmKCgoc29yY2VOb2RlWydpZCddPT0iMSIpJiYodGFyZ2V0Tm9kZVsnaWQnXT09IjYiKSl8fCgoc29yY2VOb2RlWydpZCddPT0iMiIpJiYodGFyZ2V0Tm9kZVsnaWQnXT09IjciKSl8fCgoc29yY2VOb2RlWydpZCddPT0iMyIpJiYodGFyZ2V0Tm9kZVsnaWQnXT09IjgiKSkpew0KICAgICAgICAgIC8vICAgbWlkWS09MTQwDQogICAgICAgICAgLy8gfQ0KICAgICAgICAgIGxldCBoID0gKCgoZW5kWCAtIHN0YXJ0WCkgLyA1KSA+IChwYXJzZUludChoZWlnaHQpICsgMTAwKSkgPyAocGFyc2VJbnQoaGVpZ2h0KSArIDEwMCkgOiAoKGVuZFggLSBzdGFydFgpIC8gNSk7DQogICAgICAgICAgbGV0IGNueSA9IChmbGFnKSA/IChtaWRZIC0gaCkgOiAobWlkWSArIGgpOw0KDQogICAgICAgICAgbGV0IGNueTEgPSBjbnk7DQogICAgICAgICAgbGV0IGNueTIgPSBjbnk7DQoNCiAgICAgICAgICBpZiAoKChzb3JjZU5vZGVbJ2xheW91dCddID09IDIpICYmIChjbnkgPCAwKSkgfHwgKChzb3JjZU5vZGVbJ2xheW91dCddID09IDApICYmIChjbnkgPiAwKSkpIHsNCiAgICAgICAgICAgIGNueDEgLT0gMjUwOw0KICAgICAgICAgICAgY255MSA9IGNueSAqIDEuMzsNCiAgICAgICAgICB9DQogICAgICAgICAgaWYgKCgodGFyZ2V0Tm9kZVsnbGF5b3V0J10gPT0gMikgJiYgKGNueSA8IDApKSB8fCAoKHRhcmdldE5vZGVbJ2xheW91dCddID09IDApICYmIChjbnkgPiAwKSkpIHsNCiAgICAgICAgICAgIGNueDIgKz0gMjUwOw0KICAgICAgICAgICAgY255MiA9IGNueSAqIDEuMzsNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gbGV0IG1pZFAgPSBbKHN0YXJ0UFswXStlbmRQWzBdKS8yLChzdGFydFBbMV0pPihlbmRQWzFdKT8oc3RhcnRQWzFdLTEwMCk6KGVuZFBbMV0tMTAwKV07DQogICAgICAgICAgcGF0aC5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpOw0KICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhtaWRYLCBjbnksIG1pZFgsIGNueSwgZW5kWCwgZW5kWSk7DQogICAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgcGF0aCwgInJnYigyMDAsMjAwLDIwMCkiLCA1LCAiOSw5IiwgaWROLCBjbGFzc04pOw0KICAgICAgICB9DQoNCiAgICAgIH07DQogICAgICBsZXQgc2ltaWxhcml0eVJlbCA9IHJlbERhdGFbJ3NpbWlsYXJpdHlSZWwnXTsNCiAgICAgIC8vIGxldCBiYXNpY1JlbCA9IHJlbERhdGFbJ2Jhc2ljUmVsJ107DQogICAgICBmb3IgKGxldCByID0gMDsgciA8IHNpbWlsYXJpdHlSZWwubGVuZ3RoOyByKyspIHsNCg0KICAgICAgICBsZXQgc29yY2VJZCA9IHNpbWlsYXJpdHlSZWxbcl1bMF07DQogICAgICAgIGxldCB0YXJnZXRJZCA9IHNpbWlsYXJpdHlSZWxbcl1bMV07DQoNCiAgICAgICAgbGV0IGlkTiA9ICJzaW1pbGFyaXR5UmVsIiArIHNvcmNlSWQgKyAiXyIgKyB0YXJnZXRJZDsNCg0KICAgICAgICBsZXQgY2xhc3NOID0gInNpbWlsYXJpdHlSZWwgc291cmNlIiArIHNvcmNlSWQgKyAiIHRhcmdldCIgKyB0YXJnZXRJZDsNCiAgICAgICAgbGV0IHNvcmNlTm9kZSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KTsNCiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pOw0KICAgICAgICBsZXQgc29yY2VKYWdlID0gc2hvd0phZ2VEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KVsnc2hvdyddOw0KICAgICAgICBsZXQgdGFyZ2V0SmFnZSA9IHNob3dKYWdlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pWydzaG93J107DQogICAgICAgIGlmIChzb3JjZUphZ2UgJiYgdGFyZ2V0SmFnZSkgew0KDQogICAgICAgICAgaWYgKHNvcmNlTm9kZVsneCddID4gdGFyZ2V0Tm9kZVsneCddKSB7DQogICAgICAgICAgICBsZXQgdHAgPSBzb3JjZU5vZGU7DQogICAgICAgICAgICBzb3JjZU5vZGUgPSB0YXJnZXROb2RlOw0KICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRwOw0KICAgICAgICAgIH0NCiAgICAgICAgICBjb25zdCBwYXRoID0gZDMucGF0aCgpOw0KDQogICAgICAgICAgbGV0IHN0YXJ0WCA9IHNvcmNlTm9kZVsneCddICsgc29yY2VOb2RlWydyJ10gLyAyOw0KICAgICAgICAgIGxldCBlbmRYID0gdGFyZ2V0Tm9kZVsneCddIC0gdGFyZ2V0Tm9kZVsnciddIC8gMjsNCiAgICAgICAgICBsZXQgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7DQogICAgICAgICAgbGV0IGZsYWcgPSAoKHNvcmNlTm9kZVsnc29uRmxhZyddKSB8fCAodGFyZ2V0Tm9kZVsnc29uRmxhZyddKSk7DQogICAgICAgICAgbGV0IHJzb3VyY2VpbnQgPSAoc29yY2VOb2RlWydzb25GbGFnJ10pID8gKDIwKSA6ICgyKTsNCiAgICAgICAgICBsZXQgcnRhcmdldGludCA9ICh0YXJnZXROb2RlWydzb25GbGFnJ10pID8gKDIwKSA6ICgyKTsNCiAgICAgICAgICBsZXQgc3RhcnRZID0gKGZsYWcpID8gKHNvcmNlTm9kZVsneSddIC0gc29yY2VOb2RlWydyJ10gLSByc291cmNlaW50KSA6IChzb3JjZU5vZGVbJ3knXSArIHNvcmNlTm9kZVsnciddICsgcnNvdXJjZWludCk7DQogICAgICAgICAgbGV0IGVuZFkgPSAoZmxhZykgPyAodGFyZ2V0Tm9kZVsneSddIC0gdGFyZ2V0Tm9kZVsnciddIC0gcnRhcmdldGludCkgOiAodGFyZ2V0Tm9kZVsneSddICsgdGFyZ2V0Tm9kZVsnciddICsgcnRhcmdldGludCk7DQoNCiAgICAgICAgICBsZXQgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7DQoNCiAgICAgICAgICAvLyBsZXQgaDFTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgX3RoaXMud2lkdGhdLCBbKHNvcmNlTm9kZVsneSddPnRhcmdldE5vZGVbJ3knXSk/KHNvcmNlTm9kZVsneSddKjIpOih0YXJnZXROb2RlWyd5J10qMikscGFyc2VJbnQoaGVpZ2h0KV0pDQogICAgICAgICAgbGV0IGggPSAoKChlbmRYIC0gc3RhcnRYKSAvIDE0KSA+IChwYXJzZUludChoZWlnaHQpIC0gMTApKSA/IChwYXJzZUludChoZWlnaHQpIC0gMTApIDogKChlbmRYIC0gc3RhcnRYKSAvIDE0KTsNCiAgICAgICAgICBsZXQgaFNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBfdGhpcy53aWR0aCAvIDJdLCBbMCwgaCAvIDMgKiAyXSkNCiAgICAgICAgICBsZXQgY255ID0gKGZsYWcpID8gKG1pZFkgLSBoU2NhbGVfbGluZWFyKGVuZFgpKSA6IChtaWRZICsgaFNjYWxlX2xpbmVhcihlbmRYKSk7DQogICAgICAgICAgaWYgKHNvcmNlTm9kZVsnaWQnXSA9PSAnNycpIHsgY255IC09IDIwIH0NCiAgICAgICAgICBpZiAoY255IDwgLTE1MCkgew0KICAgICAgICAgICAgc3RhcnRZID0gc29yY2VOb2RlWyd5J10gKyBzb3JjZU5vZGVbJ3InXSArIHJzb3VyY2VpbnQNCiAgICAgICAgICAgIGVuZFkgPSB0YXJnZXROb2RlWyd5J10gKyB0YXJnZXROb2RlWydyJ10gKyBydGFyZ2V0aW50DQogICAgICAgICAgICBjbnkgPSBoZWlnaHQgLSBjbnkgLSAzMDA7DQogICAgICAgICAgfQ0KDQogICAgICAgICAgcGF0aC5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpOw0KICAgICAgICAgIHBhdGgubGluZVRvKHN0YXJ0WCwgY255KTsNCiAgICAgICAgICBwYXRoLmxpbmVUbyhlbmRYLCBjbnkpOw0KICAgICAgICAgIHBhdGgubGluZVRvKGVuZFgsIGVuZFkpOw0KICAgICAgICAgIF90aGlzLmRyYXdUaW1lTGluZShzdmcsIHBhdGgsICJyZ2IoMjAwLDIwMCwyMDApIiwgNSwgIjAiLCBpZE4sIGNsYXNzTik7DQogICAgICAgIH0NCg0KDQogICAgICB9Ow0KICAgICAgX3RoaXMudXBkYXRhUmVsKCkNCiAgICB9LA0KICAgIGRyYXdNYWluKHN2Zykgew0KICAgICAgbGV0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBkYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCBtYXJnaW4gPSBfdGhpcy5tYXJnaW47DQoNCiAgICAgIGxldCB3aWR0aCA9IF90aGlzLndpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7DQogICAgICBsZXQgaGVpZ2h0ID0gX3RoaXMuaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207DQoNCiAgICAgIGxldCBncmFwaEdUcmFuc2Zvcm1YID0gX3RoaXMuZ3JhcGhHVHJhbnNmb3JtWDsNCiAgICAgIGxldCBncmFwaEdUcmFuc2Zvcm1ZID0gX3RoaXMuZ3JhcGhHVHJhbnNmb3JtWTsNCiAgICAgIGxldCBncmFwaEdUcmFuc2Zvcm1LID0gX3RoaXMuZ3JhcGhHVHJhbnNmb3JtSzsNCiAgICAgIGxldCBheGlzR3JvdXBzID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImF4aXNHcm91cHMiKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpDQogICAgICAvLyAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgZ3JhcGhHVHJhbnNmb3JtWCArICcsJyArIGdyYXBoR1RyYW5zZm9ybVkgKyAiKSBzY2FsZSgiICsgZ3JhcGhHVHJhbnNmb3JtSyArICIpIik7DQogICAgICBsZXQgZ3JvdXBzID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImdyb3VwcyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCkNCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoIiArIGdyYXBoR1RyYW5zZm9ybVggKyAnLCcgKyBncmFwaEdUcmFuc2Zvcm1ZICsgIikgc2NhbGUoIiArIGdyYXBoR1RyYW5zZm9ybUsgKyAiKSIpOw0KICAgICAgdGhpcy5ncm91cHNTdmcgPSBncm91cHM7DQoNCiAgICAgIGxldCBiYWNrRyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJiYWNrRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBsZXQgYXJjRyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJhcmNHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCB0aW1lTGluZUcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAidGltZUxpbmVHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBjaXJjbGVHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImNpcmNsZUciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KDQogICAgICBfdGhpcy5hcmNHID0gYXJjRzsNCiAgICAgIGxldCBzdGVwWCA9IF90aGlzLnN0ZXBYOw0KICAgICAgbGV0IHN0ZXBZID0gX3RoaXMuc3RlcFk7DQogICAgICBsZXQgaW50ZXJ2YWwgPSBfdGhpcy5jaXJjbGVJbnRlcnZhbDsNCg0KDQogICAgICBsZXQgc2NhbGVQcmUgPSBfdGhpcy5ncmFwaFN2Z1NjYWxlOw0KICAgICAgbGV0IHN0eCA9IDA7DQogICAgICBsZXQgc3R5ID0gMDsNCiAgICAgIGxldCBzdGsgPSAxOw0KICAgICAgdmFyIGdyYXBoWm9vbSA9IGQzLnpvb20oKQ0KICAgICAgICAuc2NhbGVFeHRlbnQoWzAsIDEwXSkNCiAgICAgICAgLm9uKCJzdGFydCIsIChlKSA9PiB7DQogICAgICAgICAgc3R5ID0gZS50cmFuc2Zvcm0ueTsNCiAgICAgICAgICBzdHggPSBlLnRyYW5zZm9ybS54Ow0KICAgICAgICAgIHN0ayA9IGUudHJhbnNmb3JtLms7DQogICAgICAgIH0pDQogICAgICAgIC5vbignem9vbScsIChlKSA9PiB7DQogICAgICAgICAgZ3JhcGhHVHJhbnNmb3JtWCA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVggKyBlLnRyYW5zZm9ybS54IC0gc3R4Ow0KICAgICAgICAgIGdyYXBoR1RyYW5zZm9ybVkgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZICsgZS50cmFuc2Zvcm0ueSAtIHN0eTsNCiAgICAgICAgICBncmFwaEdUcmFuc2Zvcm1LID0gX3RoaXMuZ3JhcGhHVHJhbnNmb3JtSyArIGUudHJhbnNmb3JtLmsgLSBzdGs7DQogICAgICAgICAgX3RoaXMuZ3JhcGhHTW92ZVggPSBncmFwaEdUcmFuc2Zvcm1YOw0KDQogICAgICAgICAgZ3JvdXBzLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChncmFwaEdUcmFuc2Zvcm1YKSArICcsJyArIChncmFwaEdUcmFuc2Zvcm1ZKSArICcpIHNjYWxlKCcgKyAoZ3JhcGhHVHJhbnNmb3JtSykgKyAnKScpDQogICAgICAgIH0pDQogICAgICAgIC5vbignZW5kJywgKGUpID0+IHsNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YID0gZ3JhcGhHVHJhbnNmb3JtWDsNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZID0gZ3JhcGhHVHJhbnNmb3JtWTsNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LID0gZ3JhcGhHVHJhbnNmb3JtSzsNCiAgICAgICAgICBncm91cHMuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKGdyYXBoR1RyYW5zZm9ybVgpICsgJywnICsgKGdyYXBoR1RyYW5zZm9ybVkpICsgJykgc2NhbGUoJyArIChncmFwaEdUcmFuc2Zvcm1LKSArICcpJykNCiAgICAgICAgfSk7DQoNCg0KICAgICAgc3ZnLmNhbGwoZ3JhcGhab29tKQ0KICAgICAgLy8gLmNhbGwoZ3JhcGhab29tLnRyYW5zZm9ybSwgZDMuem9vbUlkZW50aXR5LnNjYWxlKDEpKQ0KICAgICAgY29uc3QgcGF0aCA9IGQzLnBhdGgoKQ0KICAgICAgcGF0aC5tb3ZlVG8obWFyZ2luLmxlZnQsIG1hcmdpbi50b3ApDQogICAgICBsZXQgeCA9IG1hcmdpbi5sZWZ0Ow0KICAgICAgbGV0IHByZXggPSBtYXJnaW4ubGVmdDsNCiAgICAgIGxldCBwcmV5ID0gbWFyZ2luLnRvcDsNCiAgICAgIGxldCBwcmVyID0gMDsNCiAgICAgIGxldCBwcmVTb25MZW4gPSAwOw0KICAgICAgbGV0IGxheW91dFNob3cgPSBfdGhpcy5sYXlvdXRTaG93Ow0KICAgICAgbGV0IHN1bVRvdGFsRHVyYXRpb24gPSAwOw0KICAgICAgbGV0IHJvb3RJbmRleCA9IC0xOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBsYXkgPSBwYXJzZUludChkYXRhW2ldWydsYXlvdXQnXSk7DQoNCiAgICAgICAgbGV0IGNvbG9ycyA9IF90aGlzLm1jb2xvcjsNCiAgICAgICAgbGV0IGNvbG9yc0QgPSBfdGhpcy5tRGFya2NvbG9yOw0KICAgICAgICBsZXQgZW50aXR5TG9jYXRpb25EYXRhID0gdG9vbHMuZGVlcENsb25lKGRhdGFbaV0pOw0KICAgICAgICBpZiAobGF5ID09IDApIHsNCiAgICAgICAgICByb290SW5kZXgrKzsNCiAgICAgICAgfQ0KICAgICAgICBlbnRpdHlMb2NhdGlvbkRhdGFbJ3Jvb3RJbmRleCddID0gcm9vdEluZGV4Ow0KICAgICAgICBlbnRpdHlMb2NhdGlvbkRhdGFbJ2NvbG9yJ10gPSBjb2xvcnNbcm9vdEluZGV4ICUgY29sb3JzLmxlbmd0aF07DQogICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsnY29sb3JEJ10gPSBjb2xvcnNEW3Jvb3RJbmRleCAlIGNvbG9yc0QubGVuZ3RoXTsNCiAgICAgICAgbGV0IHRpbWVMaXN0ID0gZGF0YVtpXVsndGltZSddOw0KICAgICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHRpbWVMaXN0WzBdKTsNCiAgICAgICAgc3VtVG90YWxEdXJhdGlvbiArPSBkdXJhdGlvbjsNCiAgICAgICAgbGV0IHNob3dFbnRpdHkgPSBfdGhpcy5zaG93RW50aXR5TGlzdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGRhdGFbaV1bJ2lkJ10gfSk7DQogICAgICAgIGlmICgoc2hvd0VudGl0eVsnc2hvdyddID09IHRydWUpKSB7DQogICAgICAgICAgbGV0IHkgPSBtYXJnaW4udG9wICsgbGF5ICogc3RlcFkNCiAgICAgICAgICBsZXQgcmVsZXZhbmNlVmFsdWUgPSBkYXRhW2ldWydhdHRyaWJ1dGUnXVsncmVsZXZhbmNlJ107DQogICAgICAgICAgbGV0IHRvdGFsRHVyYXRpb25WYWx1ZSA9IGRhdGFbaV1bJ3RvdGFsRHVyYXRpb24nXTsNCiAgICAgICAgICBsZXQgclNjYWxlID0gX3RoaXMudG90YWxEdXJhdGlvblNjYWxlX2xpbmVhcjsNCg0KDQogICAgICAgICAgbGV0IHIgPSByU2NhbGUodG90YWxEdXJhdGlvblZhbHVlKTsNCiAgICAgICAgICBsZXQgc3RlcEwgPSByICsgc3RlcFggLyAyICsgaW50ZXJ2YWwgLyAxMDsNCiAgICAgICAgICBsZXQgY29udHJvbFAxeCA9IHByZXggKyBpbnRlcnZhbCAvIDE7DQogICAgICAgICAgbGV0IGNvbnRyb2xQMnggPSB4IC0gaW50ZXJ2YWwgLyAxOw0KICAgICAgICAgIGxldCBjdXJMaW5leCA9IHggLSByIC0gaW50ZXJ2YWw7DQoNCiAgICAgICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICAgICAgbGV0IG9EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgICAgIGxldCBiYXNpY1JlbCA9IHJlbERhdGFbJ2Jhc2ljUmVsJ107DQogICAgICAgICAgbGV0IGRhSWQgPSBkYXRhWyhpKV1bJ2lkJ107DQogICAgICAgICAgbGV0IGpnID0gMDsNCiAgICAgICAgICBmb3IgKGxldCByZSA9IDA7IHJlIDwgYmFzaWNSZWwubGVuZ3RoOyByZSsrKSB7DQoNCiAgICAgICAgICAgIGxldCBzb3JjZUlkID0gYmFzaWNSZWxbcmVdWzBdOw0KICAgICAgICAgICAgbGV0IHRhcmdldElkID0gYmFzaWNSZWxbcmVdWzFdOw0KICAgICAgICAgICAgbGV0IGNOb2RlID0gJyc7DQogICAgICAgICAgICBpZiAoKHNvcmNlSWQgPT0gZGFJZCkgfHwgKHRhcmdldElkID09IGRhSWQpKSB7DQogICAgICAgICAgICAgIGpnID0gMTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9Ow0KICAgICAgICAgIGxldCBzb25GbGFnID0gMTsNCiAgICAgICAgICBpZiAoKChpID4gMCkgJiYgKHByZVNvbkxlbiA9PSAwKSkgJiYgKGRhdGFbKGkpXVsnc29uJ10ubGVuZ3RoID09IDApKSB7DQogICAgICAgICAgICBzb25GbGFnID0gMDsNCiAgICAgICAgICAgIHN0ZXBMID0gciArIHN0ZXBYIC8gMS4yICsgaW50ZXJ2YWwgLyAxMDsNCiAgICAgICAgICAgIHggKz0gc3RlcEw7DQogICAgICAgICAgICBjb250cm9sUDF4ID0gcHJleCArIGludGVydmFsIC8gMTsNCiAgICAgICAgICAgIGNvbnRyb2xQMnggPSB4IC0gciAtIGludGVydmFsIC8gMiAtIGludGVydmFsIC8gMTsNCiAgICAgICAgICAgIGN1ckxpbmV4ID0gciArIGludGVydmFsIC8gMTA7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKCgoaSA+IDApICYmIChwcmVTb25MZW4gIT0gMCkpICYmIChkYXRhWyhpKV1bJ3NvbiddLmxlbmd0aCA9PSAwKSkgew0KICAgICAgICAgICAgc29uRmxhZyA9IDA7DQogICAgICAgICAgICBzdGVwTCA9IHIgKyBzdGVwWCArIGludGVydmFsICsgMzA7DQogICAgICAgICAgICB4ICs9IHN0ZXBMOw0KICAgICAgICAgICAgY29udHJvbFAxeCA9IHByZXggKyBpbnRlcnZhbCAvIDE7DQogICAgICAgICAgICBjb250cm9sUDJ4ID0geCAtIHIgLSBpbnRlcnZhbCAvIDEgLSBpbnRlcnZhbCAvIDE7DQogICAgICAgICAgICBjdXJMaW5leCA9IHIgKyBpbnRlcnZhbCAvIDEwOw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgIHN0ZXBMID0gciArIHN0ZXBYICsgaW50ZXJ2YWwgKyAxMDsNCiAgICAgICAgICAgIHggKz0gc3RlcEw7DQogICAgICAgICAgICBjb250cm9sUDF4ID0gcHJleCArIGludGVydmFsIC8gMTsNCiAgICAgICAgICAgIGNvbnRyb2xQMnggPSB4IC0gciAtIGludGVydmFsIC0gaW50ZXJ2YWwgLyAxOw0KICAgICAgICAgICAgY3VyTGluZXggPSByICsgaW50ZXJ2YWw7DQogICAgICAgICAgfQ0KDQogICAgICAgICAgaWYgKChqZyA9PSAxKSAmJiAoZGF0YVtpXVsndHlwZSddID09IDApICYmIChkYXRhWyhpKV1bJ3NvbiddLmxlbmd0aCA9PSAwKSkgew0KICAgICAgICAgICAgY3VyTGluZXggKz0gciAqIDEuNQ0KICAgICAgICAgIH0NCiAgICAgICAgICBfdGhpcy5kcmF3RW50aXR5KGNpcmNsZUcsIHgsIHksIHIsIGRhdGFbaV0pDQogICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKGNvbnRyb2xQMXgsIHByZXksIGNvbnRyb2xQMngsIHksIHggLSBjdXJMaW5leCwgeSkNCiAgICAgICAgICAvLyBwYXRoLmxpbmVUbyhjb250cm9sUDF4LCBwcmV5KQ0KICAgICAgICAgIC8vIHBhdGgubGluZVRvKGNvbnRyb2xQMngsIHkpDQogICAgICAgICAgLy8gcGF0aC5saW5lVG8oeCAtIGN1ckxpbmV4LCB5KQ0KICAgICAgICAgIHBhdGgubW92ZVRvKHggKyBjdXJMaW5leCwgeSk7DQogICAgICAgICAgcHJleCA9IHggKyBjdXJMaW5leDsNCiAgICAgICAgICBwcmV5ID0geTsNCiAgICAgICAgICBwcmVyID0gcjsNCiAgICAgICAgICBwcmVTb25MZW4gPSBkYXRhWyhpKV1bJ3NvbiddLmxlbmd0aDsNCiAgICAgICAgICBlbnRpdHlMb2NhdGlvbkRhdGFbJ3gnXSA9IHg7DQogICAgICAgICAgZW50aXR5TG9jYXRpb25EYXRhWyd5J10gPSB5Ow0KICAgICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsnciddID0gcjsNCiAgICAgICAgfQ0KICAgICAgICBlbHNlIHsNCiAgICAgICAgICBlbnRpdHlMb2NhdGlvbkRhdGFbJ3gnXSA9IHByZXg7DQogICAgICAgICAgZW50aXR5TG9jYXRpb25EYXRhWyd5J10gPSBwcmV5Ow0KICAgICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsnciddID0gcHJlcjsNCiAgICAgICAgfQ0KICAgICAgICBlbnRpdHlMb2NhdGlvbkRhdGFbJ3NvbkZsYWcnXSA9IChlbnRpdHlMb2NhdGlvbkRhdGFbJ3NvbiddLmxlbmd0aCA+IDApID8gKDEpIDogKDApOw0KICAgICAgICAvLyBlbnRpdHlMb2NhdGlvbkRhdGFbJ3Nob3dSZWwnXSA9IGZhbHNlOw0KICAgICAgICBfdGhpcy5kcmF3RW50aXR5TG9jYXRpb24ucHVzaChlbnRpdHlMb2NhdGlvbkRhdGEpOw0KICAgICAgfQ0KICAgICAgbGV0IGVudGl0eUxvY2F0aW9uRGF0YSA9IF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbjsNCiAgICAgIGxldCBjb2xvcnMgPSBfdGhpcy5tY29sb3I7DQogICAgICBsZXQgY29sb3JJbmRleCA9IDA7DQogICAgICBsZXQgY29sb3Jyb290SW5kZXggPSAwOw0KDQogICAgICBfdGhpcy5zdW1Ub3RhbER1cmF0aW9uID0gc3VtVG90YWxEdXJhdGlvbjsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50aXR5TG9jYXRpb25EYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCB4ID0gZW50aXR5TG9jYXRpb25EYXRhW2ldWyd4J107DQogICAgICAgIGxldCB5ID0gZW50aXR5TG9jYXRpb25EYXRhW2ldWyd5J107DQogICAgICAgIGxldCByID0gZW50aXR5TG9jYXRpb25EYXRhW2ldWydyJ107DQoNCiAgICAgICAgbGV0IHNob3dFbnRpdHkgPSBfdGhpcy5zaG93RW50aXR5TGlzdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnaWQnXSB9KTsNCiAgICAgICAgaWYgKGVudGl0eUxvY2F0aW9uRGF0YVtpXVsndHlwZSddID09IDAgJiYgKHNob3dFbnRpdHlbJ3Nob3cnXSA9PSB0cnVlKSkgew0KICAgICAgICAgIF90aGlzLmRyYXdFbnRpdHlUaW1lQXhpcyhjaXJjbGVHLCBlbnRpdHlMb2NhdGlvbkRhdGFbaV0pOw0KICAgICAgICB9DQogICAgICAgIGlmICgoZW50aXR5TG9jYXRpb25EYXRhW2ldWydsYXlvdXQnXSA9PSAnMCcgJiYgKGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnbmFtZSddICE9ICdUZXN0JykpKSB7DQogICAgICAgICAgY29sb3JJbmRleCA9IGNvbG9ycm9vdEluZGV4Ow0KICAgICAgICAgIGNvbG9ycm9vdEluZGV4Kys7DQoNCiAgICAgICAgfQ0KICAgICAgICBpZiAoKGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnc29uJ10ubGVuZ3RoICE9IDApICYmIChfdGhpcy5zaG93RW50aXR5TGlzdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnc29uJ11bMF0gfSlbJ3Nob3cnXSkpIHsNCiAgICAgICAgICBsZXQgbWF4eHMgPSBlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ3gnXSAtIGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnciddIC0gNDA7DQogICAgICAgICAgbGV0IG1heHlzID0gZW50aXR5TG9jYXRpb25EYXRhW2ldWyd5J10gLSBlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ3InXSAtIDQwOw0KICAgICAgICAgIGxldCBtaW54cyA9IHRvb2xzLmRlZXBDbG9uZShtYXh4cyk7DQogICAgICAgICAgbGV0IG1pbnlzID0gdG9vbHMuZGVlcENsb25lKG1heHlzKTsNCiAgICAgICAgICBsZXQgcmVjdFBvaW50cyA9IFtbbWF4eHMsIG1heHlzXV07DQogICAgICAgICAgbGV0IHNvbnMgPSB0b29scy5kZWVwQ2xvbmUoZGF0YVtpXVsnc29uJ10pOw0KICAgICAgICAgIHdoaWxlICgoc29ucy5sZW5ndGggPiAwKSkgew0KICAgICAgICAgICAgbGV0IHMgPSBzb25zWzBdOw0KICAgICAgICAgICAgc29ucy5zcGxpY2UoMCwgMSk7DQogICAgICAgICAgICBsZXQgY3Vyc29uID0gZW50aXR5TG9jYXRpb25EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gczsgfSk7DQogICAgICAgICAgICBsZXQgY3VyZ3NvbiA9IGN1cnNvblsnc29uJ107DQogICAgICAgICAgICBsZXQgY3VyeCA9IGN1cnNvblsneCddICsgY3Vyc29uWydyJ10gKiAyOw0KICAgICAgICAgICAgbGV0IGN1cnkgPSBjdXJzb25bJ3knXSArIGN1cnNvblsnciddICogMjsNCiAgICAgICAgICAgIGlmIChjdXJ4ID4gbWF4eHMpIHsgbWF4eHMgPSBjdXJ4OyB9DQogICAgICAgICAgICAvLyBpZihjdXJzb25bJ3knXTxtYXh5cyltYXh5cyA9IGN1cnNvblsneSddOw0KICAgICAgICAgICAgaWYgKGN1cnkgPCBtaW55cykgbWlueXMgPSBjdXJ5Ow0KICAgICAgICAgICAgaWYgKGN1cnkgPiBtYXh5cykgbWF4eXMgPSBjdXJ5Ow0KICAgICAgICAgICAgZm9yIChsZXQgZ3MgPSAwOyBncyA8IGN1cmdzb24ubGVuZ3RoOyBncysrKSB7DQogICAgICAgICAgICAgIHNvbnMucHVzaChjdXJnc29uW2dzXSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIHJlY3RQb2ludHMgPSBbW21pbnhzLCBtaW55c10sIFttaW54cywgbWF4eXNdLCBbbWF4eHMsIG1heHlzXSwgW21heHhzLCBtaW55c11dOw0KICAgICAgICAgIC8vIF90aGlzLmRyYXdwb2x5Z29uKGJhY2tHLCBjb2xvcnNbY29sb3JJbmRleF0sIHJlY3RQb2ludHMsICJyZ2IoMjU1LDI1NSwyNTUpIiwwLjMpOw0KICAgICAgICAgIF90aGlzLmRyYXdSZWN0KGJhY2tHLCBtaW54cywgbWlueXMsIE1hdGguYWJzKG1heHhzIC0gbWlueHMpLCBNYXRoLmFicyhtYXh5cyAtIG1pbnlzKSwgMjAsIDIwLCBjb2xvcnNbY29sb3JJbmRleF0sIDAuMSwgIndoaXRlIiwgYGJhY2tSZWN0JHtpfWApDQoNCiAgICAgICAgICBjb2xvckluZGV4Kys7DQogICAgICAgICAgY29sb3JJbmRleCAlPSBjb2xvcnMubGVuZ3RoDQogICAgICAgIH0NCiAgICAgICAgLy8gZW50aXR5TG9jYXRpb25EYXRhW2ldWydjb2xvciddID0gY29sb3JzW2NvbG9ySW5kZXggLSAxXTsNCiAgICAgICAgLy8gaWYgKChlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ2xheW91dCddID09ICcwJykgJiYgKChlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ25hbWUnXSA9PSAnVGVzdCcpIHx8IChlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ25hbWUnXSA9PSAnRXhhbXBsZScpKSkgew0KICAgICAgICAvLyAgIGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnY29sb3InXSA9IGNvbG9yc1tjb2xvckluZGV4XQ0KICAgICAgICAvLyB9DQogICAgICB9DQogICAgICBfdGhpcy5kcmF3VGltZUxpbmUodGltZUxpbmVHLCBwYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDUsICcwJywgJ3RpbWVMaW5lICcsICd0aW1lTGluZSAnKTsNCiAgICAgIF90aGlzLmRyYXdSZWxhdGlvbnNoaXBMaW5lKHRpbWVMaW5lRyk7DQogICAgICBfdGhpcy5kcmF3VGltZUF4aXMoX3RoaXMuVGltZUF4aXNTdmcpOw0KICAgICAgX3RoaXMuZHJhd1R5cGVSaXZlcihfdGhpcy5UaW1lQXhpc1N2Zyk7DQogICAgICBfdGhpcy51cGRhdGFUaW1lQXhpc0R1cihfdGhpcy5UaW1lQXhpc1N2ZywgX3RoaXMudGltZUF4aXNYLCBfdGhpcy50aW1lQXhpc1cpOw0KICAgIH0sDQogICAgdXBkYXRhVGltZUF4aXNEdXIoc3ZnLCB4LCB3aWR0aCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGxldCB0b3RhbFdpZHRoID0gX3RoaXMud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCB5ID0gMDsNCiAgICAgIGxldCBoID0gMTkwOw0KICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCAwLCB5LCB4LCBoLCAzLCAzLCAnd2hpdGUnLCAwLjMsICcnLCAidGltZUF4aXNSZWN0MSIpDQogICAgICBsZXQgY3VyUmVjdCA9IF90aGlzLmRyYXdSZWN0KHN2ZywgeCwgeSAtIDAsIHdpZHRoLCBoIC0gNSwgMywgMywgJ3JnYmEoMCwwLDAsMCknLCAxLCAncmdiKDE0NSwgMTgwLCAxODkpJywgJ3dpblJlY3QnLCAyKTsNCiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQogICAgICAvLyBjdXJSZWN0Lm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkgew0KICAgICAgLy8gICBkMy5zZWxlY3QodGhpcykuYXR0cigiY3Vyc29yIiwgJ3BvaW50ZXInKTsNCiAgICAgIC8vICAgaWYgKF90aGlzLnRpbWVBeGlzRHJvcEZsYWcgPT0gMSkgew0KICAgICAgLy8gICAgIGxldCBteCA9IGUuY2xpZW50WCAtIF90aGlzLnRpbWVBeGlzRG93blg7DQogICAgICAvLyAgICAgX3RoaXMudGltZUF4aXNYID0gZS5sYXllclggLSA0NTAgLSBfdGhpcy50aW1lQXhpc1cgLyAyOw0KICAgICAgLy8gICB9DQogICAgICAvLyB9KQ0KICAgICAgLy8gY3VyUmVjdC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHsNCiAgICAgIC8vICAgX3RoaXMudGltZUF4aXNEb3duWCA9IGUuY2xpZW50WDsNCiAgICAgIC8vICAgX3RoaXMudGltZUF4aXNEcm9wRmxhZyA9IDE7DQogICAgICAvLyB9KQ0KICAgICAgLy8gY3VyUmVjdC5vbignbW91c2V1cCcsIGZ1bmN0aW9uIChlKSB7DQogICAgICAvLyAgIF90aGlzLnRpbWVBeGlzRG93blggPSBlLmNsaWVudFg7DQogICAgICAvLyAgIF90aGlzLnRpbWVBeGlzRHJvcEZsYWcgPSAwOw0KICAgICAgLy8gfSkNCiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCg0KICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCB4ICsgd2lkdGgsIHksIHRvdGFsV2lkdGggLSB3aWR0aCwgaCwgMywgMywgJ3doaXRlJywgMC4zLCAnJywgInRpbWVBeGlzUmVjdDIiKQ0KICAgIH0sDQogICAgZHJhd1R5cGVSaXZlcihzdmcpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBvcmlEYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgIGxldCByZXNEYXRhID0gW107DQogICAgICBsZXQgdHJpTGkgPSBbXTsNCiAgICAgIGxldCBleGVMaSA9IFtdOw0KICAgICAgdmFyIGRlZnMgPSBzdmcuYXBwZW5kKCJkZWZzIik7DQoNCiAgICAgIHZhciBmaWx0ZXIgPSBkZWZzDQogICAgICAgIC5hcHBlbmQoImZpbHRlciIpDQogICAgICAgIC5hdHRyKCJpZCIsICJjb29sU2hhZG93IikNCiAgICAgICAgLmF0dHIoIngiLCAiLTEwMCUiKQ0KICAgICAgICAuYXR0cigieSIsICItMTAwJSIpIC8vDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsICIzMDAlIikNCiAgICAgICAgLmF0dHIoImhlaWdodCIsICIzMDAlIik7IC8vDQoNCiAgICAgIGZpbHRlcg0KICAgICAgICAuYXBwZW5kKCJmZU1vcnBob2xvZ3kiKQ0KICAgICAgICAuYXR0cigiaW4iLCAiU291cmNlR3JhcGhpYyIpDQogICAgICAgIC5hdHRyKCJyZXN1bHQiLCAidXBwZXJMYXllciIpDQogICAgICAgIC5hdHRyKCJvcGVyYXRvciIsICJkaWxhdGUiKQ0KICAgICAgICAuYXR0cigicmFkaXVzIiwgIjAuMiAwLjIiKTsNCg0KICAgICAgZmlsdGVyDQogICAgICAgIC5hcHBlbmQoImZlTW9ycGhvbG9neSIpDQogICAgICAgIC5hdHRyKCJpbiIsICJTb3VyY2VBbHBoYSIpDQogICAgICAgIC5hdHRyKCJyZXN1bHQiLCAiZW5sYXJnZWRBbHBoYSIpDQogICAgICAgIC5hdHRyKCJvcGVyYXRvciIsICJkaWxhdGUiKQ0KICAgICAgICAuYXR0cigicmFkaXVzIiwgIjAuMiAwLjIiKTsNCg0KICAgICAgZmlsdGVyDQogICAgICAgIC5hcHBlbmQoImZlR2F1c3NpYW5CbHVyIikNCiAgICAgICAgLmF0dHIoImluIiwgImVubGFyZ2VkQWxwaGEiKQ0KICAgICAgICAuYXR0cigicmVzdWx0IiwgImJsdXJlZEFscGhhIikNCiAgICAgICAgLmF0dHIoInN0ZERldmlhdGlvbiIsICIzIik7DQoNCiAgICAgIGZpbHRlcg0KICAgICAgICAuYXBwZW5kKCJmZU9mZnNldCIpDQogICAgICAgIC5hdHRyKCJpbiIsICJibHVyZWRBbHBoYSIpDQogICAgICAgIC5hdHRyKCJyZXN1bHQiLCAibG93ZXJMYXllciIpDQogICAgICAgIC5hdHRyKCJkeSIsICIxIik7IC8vDQoNCiAgICAgIHZhciBmZU1lcmdlID0gZmlsdGVyLmFwcGVuZCgiZmVNZXJnZSIpOw0KICAgICAgZmVNZXJnZS5hcHBlbmQoImZlTWVyZ2VOb2RlIikuYXR0cigiaW4iLCAibG93ZXJMYXllciIpOw0KICAgICAgZmVNZXJnZS5hcHBlbmQoImZlTWVyZ2VOb2RlIikuYXR0cigiaW4iLCAidXBwZXJMYXllciIpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlEYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIGxldCBjdXJFbnQgPSBvcmlEYXRhW2ldOw0KICAgICAgICBsZXQgdHAgPSB7fQ0KICAgICAgICB0cFsnb2QnXSA9IGk7DQogICAgICAgIGlmICgoY3VyRW50Wyd0eXBlJ10gPT0gIjEiKSkgew0KICAgICAgICAgIHRyaUxpLnB1c2godHApOw0KICAgICAgICB9DQogICAgICAgIGlmIChjdXJFbnRbJ3R5cGUnXSA9PSAiMiIpIHsNCiAgICAgICAgICBleGVMaS5wdXNoKHRwKTsNCiAgICAgICAgfQ0KICAgICAgICBsZXQgdHlwZURhdGEgPSBjdXJFbnRbImF0dHJpYnV0ZSJdWyJleHByZXNzaW9ucyJdOw0KICAgICAgICBsZXQgdG90YWxEdXIgPSAwOw0KDQogICAgICAgIGZvciAobGV0IHQgaW4gdHlwZURhdGEpIHsNCiAgICAgICAgICAvLyBsZXQgY29sb3IgPSB0eXBlQ29sb3JbaV07DQogICAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHR5cGVEYXRhW3RdOw0KICAgICAgICAgIGxldCB0b3RhbFR5cGVTZWNvbmRzID0gMDsNCiAgICAgICAgICBmb3IgKGxldCBkIGluIHR5cGVEdXJpdGlvbikgew0KICAgICAgICAgICAgdG90YWxUeXBlU2Vjb25kcyArPSAodG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzBdKSkNCiAgICAgICAgICB9DQogICAgICAgICAgdG90YWxEdXIgKz0gdG90YWxUeXBlU2Vjb25kczsNCiAgICAgICAgICB0cFt0XSA9IHRvdGFsVHlwZVNlY29uZHM7DQogICAgICAgIH0NCiAgICAgICAgZm9yIChsZXQgdCBpbiB0cCkgew0KICAgICAgICAgIGlmICh0ICE9ICdvZCcpIHsNCiAgICAgICAgICAgIHRwW3RdIC89IHRvdGFsRHVyOw0KICAgICAgICAgICAgaWYgKHRvdGFsRHVyID09IDApIHsNCiAgICAgICAgICAgICAgdHBbdF0gPSAwOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICByZXNEYXRhLnB1c2godHApDQogICAgICB9DQoNCiAgICAgIGxldCBkYXRhID0gcmVzRGF0YTsNCiAgICAgIHZhciBzdGFjayA9IGQzLnN0YWNrKCkNCiAgICAgICAgLmtleXMoWycxJywgJzInLCAnMyddKQ0KICAgICAgICAub3JkZXIoZDMuc3RhY2tPcmRlckluc2lkZU91dCkNCiAgICAgICAgLm9mZnNldChkMy5zdGFja09mZnNldFdpZ2dsZSk7DQoNCiAgICAgIGxldCB5UmFuZ2VXaWR0aCA9IDcwOw0KICAgICAgbGV0IHcgPSBwYXJzZUludChzdmcuYXR0cigid2lkdGgiKSkgKyA2MA0KICAgICAgbGV0IHhTdGVwID0gKHcpIC8gb3JpRGF0YS5sZW5ndGg7DQogICAgICBsZXQgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWy0xLCAxXSkucmFuZ2UoWzAsIDcwXSk7DQogICAgICB2YXIgYXJlYSA9IGQzLmFyZWEoKQ0KICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAgICAgLngoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4gZC5kYXRhLm9kICogeFN0ZXAgKyAxNTsNCiAgICAgICAgfSkNCiAgICAgICAgLnkwKGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgcmV0dXJuIDE0MyArIHlSYW5nZVdpZHRoIC0geVNjYWxlKGRbMF0pOw0KICAgICAgICB9KQ0KICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4gMTQzICsgeVJhbmdlV2lkdGggLSB5U2NhbGUoZFsxXSk7DQogICAgICAgIH0pOw0KICAgICAgbGV0IHN0YWNrRGF0YSA9IHN0YWNrKGRhdGEpDQogICAgICBsZXQgbGVuVGhyZXNob2xkID0gMC40Ow0KICAgICAgbGV0IGljb25MaSA9IHt9DQogICAgICBmb3IgKGxldCBzIGluIHN0YWNrRGF0YSkgew0KICAgICAgICBpY29uTGlbc10gPSBbXQ0KICAgICAgICBmb3IgKGxldCBpIGluIHN0YWNrRGF0YVtzXSkgew0KICAgICAgICAgIGxldCBsZW5BcmVhID0gc3RhY2tEYXRhW3NdW2ldDQogICAgICAgICAgaWYgKChsZW5BcmVhWzFdIC0gbGVuQXJlYVswXSkgPiAwLjQpIHsNCiAgICAgICAgICAgIGljb25MaVtzXS5wdXNoKFtpLCBsZW5BcmVhXSk7DQogICAgICAgICAgfQ0KICAgICAgICAgIGZvciAobGV0IGxpIGluIGljb25MaVtzXSkgew0KICAgICAgICAgICAgaWYgKGkgPCAoaWNvbkxpW3NdW2xpXVswXSArIDIpKSB7DQogICAgICAgICAgICAgIGxldCBzZWxlY3RBcmVhID0gaWNvbkxpW3NdW2xpXVsxXQ0KICAgICAgICAgICAgICBpZiAoKChzZWxlY3RBcmVhWzFdIC0gbGVuQXJlYVsxXSkgLSAoc2VsZWN0QXJlYVswXSAtIGxlbkFyZWFbMF0pKSA8IDAuMikgew0KICAgICAgICAgICAgICAgIGljb25MaVtzXS5zcGxpY2UocywgMSk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIC8vIGxldCBhcmVhRyA9IHN2Zy5hcHBlbmQoImciKQ0KICAgICAgbGV0IHR5cGVDb2xvciA9IHsNCiAgICAgICAgIjEiOiAiI2ZmOWM5YyIsDQogICAgICAgICIyIjogIiNmNGY0ZDAiLA0KICAgICAgICAiMyI6ICIjNmY4YmUwIiwNCiAgICAgIH07DQogICAgICBsZXQgY29sb3JMaSA9IF90aGlzLm1jb2xvcjsNCiAgICAgIHN2Zy5zZWxlY3RBbGwoInBhdGgiKQ0KICAgICAgICAuZGF0YShzdGFja0RhdGEpDQogICAgICAgIC5qb2luKCJwYXRoIikNCiAgICAgICAgLmF0dHIoImlkIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2V5IH0pDQogICAgICAgIC5hdHRyKCJjbGFzcyIsICJyaXZlciIpDQogICAgICAgIC5hdHRyKCJkIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4gYXJlYShkKQ0KICAgICAgICB9KQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZ1bmN0aW9uIChkLCBpKSB7DQogICAgICAgICAgcmV0dXJuIHR5cGVDb2xvcltkLmtleV0NCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCJtb3VzZW92ZXIiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLnJpdmVyIikuc3R5bGUoImZpbHRlciIsICJ1cmwoKSIpDQogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCJmaWx0ZXIiLCAidXJsKCNjb29sU2hhZG93KSIpDQogICAgICAgIH0pDQoNCiAgICAgIGZvciAobGV0IHQgaW4gdHJpTGkpIHsNCiAgICAgICAgbGV0IGFyZWEgPSB0b29scy5jYWxjVHJpYW5nbGUoKHRyaUxpW3RdWydvZCddKSAqIHhTdGVwLCAtMzAsIDE0KTsNCiAgICAgICAgX3RoaXMuZHJhd1RyaWFuZ2xlKHN2ZywgInJnYigyNTAsIDE5OSwgODgpIiwgYXJlYSwgInJnYigyNTAsIDE5OSwgODgpIik7DQogICAgICAgIF90aGlzLmRyYXdUeHQoc3ZnLCAodHJpTGlbdF1bJ29kJ10pICogeFN0ZXAsIC0yMywgIlQiLCAid2hpdGUiLCAwLCAibWlkZGxlIiwgMTgpDQogICAgICB9DQogICAgICBmb3IgKGxldCB0IGluIGV4ZUxpKSB7DQogICAgICAgIGxldCBhcmVhID0gdG9vbHMuY2FsY1RyaWFuZ2xlKChleGVMaVt0XVsnb2QnXSkgKiB4U3RlcCwgLTMwLCAxNCk7DQogICAgICAgIF90aGlzLmRyYXdUcmlhbmdsZShzdmcsICJyZ2IoMjUwLCAxOTksIDg4KSIsIGFyZWEsICJyZ2IoMjUwLCAxOTksIDg4KSIpOw0KICAgICAgICBfdGhpcy5kcmF3VHh0KHN2ZywgKGV4ZUxpW3RdWydvZCddKSAqIHhTdGVwLCAtMjMsICJFIiwgIndoaXRlIiwgMCwgIm1pZGRsZSIsIDE4KQ0KICAgICAgfQ0KICAgIH0sDQogICAgZHJhd1RpbWVBeGlzKHN2Zykgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHN1bVRvdGFsRHVyYXRpb24gPSBfdGhpcy5zdW1Ub3RhbER1cmF0aW9uOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kcmF3RW50aXR5TG9jYXRpb247DQogICAgICBsZXQgYWRkRGF0YSA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5kcmF3RW50aXR5TG9jYXRpb24pOw0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGxldCBwcmV4ID0gbWFyZ2luLmxlZnQ7DQogICAgICBsZXQgcHJleSA9IG1hcmdpbi50b3AgLyAyOw0KICAgICAgbGV0IHdpZHRoID0gc3ZnLmF0dHIoIndpZHRoIikvLyBfdGhpcy53aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0Ow0KICAgICAgbGV0IGhlaWdodCA9IF90aGlzLmhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tOw0KICAgICAgbGV0IHdpZHRoU2NhbGUgPSBkMy5zY2FsZUxpbmVhcihbMCwgc3VtVG90YWxEdXJhdGlvbl0sIFswLCB3aWR0aF0pOw0KICAgICAgZGF0YS5mb3JFYWNoKChzZWxmLCBpbmR4LCBhcnIpID0+IHsNCiAgICAgICAgbGV0IHRvdGFsRHVyYXRpb25WYWx1ZSA9IHNlbGZbJ3RvdGFsRHVyYXRpb24nXTsNCiAgICAgICAgbGV0IHRpbWVMaXN0ID0gc2VsZlsndGltZSddOw0KICAgICAgICBsZXQgaWQgPSBzZWxmWydpZCddDQogICAgICAgIGxldCBkdXJhdGlvbiA9IHRvb2xzLnRpbWUyc2Vjb25kcyh0aW1lTGlzdFsxXSkgLSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMF0pOw0KICAgICAgICAvLyBjb25zb2xlLmxvZyh0aW1lTGlzdCx0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMF0pKQ0KICAgICAgICBsZXQgZXZXaWR0aCA9IHdpZHRoU2NhbGUoZHVyYXRpb24pIC0gNDsNCg0KICAgICAgICBsZXQgZXZUV2lkdGggPSB3aWR0aFNjYWxlKHRvdGFsRHVyYXRpb25WYWx1ZSk7DQogICAgICAgIGxldCBsYXkgPSBwYXJzZUludChzZWxmWydsYXlvdXQnXSk7DQogICAgICAgIGxldCBldkhpZ2h0ID0gODAgLSAyMCAqIGxheTsNCiAgICAgICAgbGV0IHggPSBwcmV4Ow0KICAgICAgICBsZXQgeSA9IHByZXkgKyAyMCAqIGxheTsNCiAgICAgICAgcHJleCArPSBldldpZHRoICsgNDsNCiAgICAgICAgbGV0IGNyID0gMzsNCiAgICAgICAgLy8gaWYoc2VsZlsndHlwZSddPT0wKXsNCiAgICAgICAgaWYgKDEpIHsNCiAgICAgICAgICBpZiAobGF5ID09IDApIHsNCiAgICAgICAgICAgIF90aGlzLmRyYXdSZWN0KHN2ZywgeCAtIDIsIHkgLSAyMCwgZXZUV2lkdGgsIDEwMCwgNiwgNiwgc2VsZlsnY29sb3InXSwgMC4zLCAnd2hpdGUnLCBgdGltZUF4aXNFbnRCXyR7aW5keH1gLCAxLjUsICd0aW1lQXhpc0VudEInKQ0KICAgICAgICAgIH0NCiAgICAgICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIHgsIHksIGV2V2lkdGgsIGV2SGlnaHQsIDMsIDMsIHNlbGZbJ2NvbG9yJ10sIDAuNCwgc2VsZlsnY29sb3JEJ10sIGB0aW1lQXhpc0VudF8ke2lkfWAsIDEuNSwgJ3RpbWVBeGlzRW50JykNCiAgICAgICAgICBfdGhpcy5kcmF3VHh0KHN2ZywgeCArIGV2V2lkdGggLyAyLCB5ICsgZXZIaWdodCArIDIwLCAxMCwgW3NlbGZbJ25hbWUnXS5zcGxpdCgiICIpXSwgImdyZXkiLCAxNiwgYHRpbWVUZXh0XyR7aWR9YCwgJ3RpbWVUZXh0Jyk7DQogICAgICAgIH0NCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgaWYgKGxheSA9PSAwKSB7DQogICAgICAgICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIHggLSAyLCB5IC0gMjAsIGV2VFdpZHRoLCAxMDAsIDYsIDYsIHNlbGZbJ2NvbG9yJ10sIDAuMywgJ3doaXRlJywgYHRpbWVBeGlzRW50Ql8ke2lkfWAsIDEuNSwgJ3RpbWVBeGlzRW50JykNCiAgICAgICAgICB9DQogICAgICAgICAgbGV0IGFyZWEgPSBbW3ggKyBjciwgeSArIGV2SGlnaHQgLSBjcl0sIFt4IC0gY3IgKyBldldpZHRoLCB5ICsgZXZIaWdodCAtIGNyXSwgW3ggKyBldldpZHRoIC8gMiwgeV1dOw0KICAgICAgICAgIF90aGlzLmRyYXdUcmlhbmdsZShzdmcsIHNlbGZbJ2NvbG9yJ10sIGFyZWEsIHNlbGZbJ2NvbG9yJ10sIDEsIGNyICogMik7DQogICAgICAgIH0NCiAgICAgICAgYWRkRGF0YVtpbmR4XVsndGltZVgnXSA9IHg7DQogICAgICAgIGFkZERhdGFbaW5keF1bJ3RpbWVXJ10gPSBldldpZHRoDQogICAgICB9KQ0KDQogICAgICBkMy5zZWxlY3RBbGwoJy50aW1lVGV4dCcpLmF0dHIoIm9wYWNpdHkiLCAwKQ0KICAgICAgX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uID0gYWRkRGF0YTsNCiAgICB9LA0KICAgIGRyYXdUcmlhbmdsZShzdmcsIGNvbG9yLCBwb2ludHMsIHN0cm9rZSwgb3BhY2l0eSA9IDEsIHN0cm9rZVcgPSAxNSkgew0KICAgICAgc3ZnLmFwcGVuZCgicG9seWdvbiIpDQogICAgICAgIC5hdHRyKCJwb2ludHMiLCBwb2ludHMpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgY29sb3IpDQogICAgICAgIC5hdHRyKCJzdHJva2UtbGluZWpvaW4iLCAicm91bmQiKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCBzdHJva2VXKTsNCiAgICB9LA0KICAgIGRyYXdwb2x5Z29uKHN2ZywgY29sb3IsIGFyZWFzLCBzdHJva2UsIG9wYWNpdHkgPSAxKSB7DQogICAgICBzdmcuYXBwZW5kKCJwb2x5Z29uIikNCiAgICAgICAgLmF0dHIoInBvaW50cyIsIGFyZWFzKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGNvbG9yKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCAiMS41cHgiKTsNCiAgICB9LA0KICAgIGRyYXdFbnRpdHlUaW1lQXhpcyhzdmcsIGVudERhdGEpIHsNCg0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHggPSBlbnREYXRhWyd4J107DQogICAgICBsZXQgciA9IGVudERhdGFbJ3InXTsNCiAgICAgIGxldCB5ID0gZW50RGF0YVsneSddICsgciAvIDI7DQogICAgICBsZXQgZGFJZCA9IGVudERhdGFbJ2lkJ10NCiAgICAgIGxldCBlbnREYXRhTyA9IF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbjsNCiAgICAgIGxldCBzdW1Ub3RhbER1cmF0aW9uID0gX3RoaXMuc3VtVG90YWxEdXJhdGlvbjsNCiAgICAgIGxldCB3aWR0aFNjYWxlID0gZDMuc2NhbGVMaW5lYXIoWzAsIHN1bVRvdGFsRHVyYXRpb25dLCBbMCwgTWF0aC5QSV0pOw0KICAgICAgbGV0IHRpbWVTdGVwUiA9IDA7DQogICAgICBsZXQgdGltZVN0YXJ0UiA9IC1NYXRoLlBJIC8gMjsNCiAgICAgIGxldCBpbnRlciA9IDA7DQogICAgICBsZXQgc29ucyA9IHRvb2xzLmRlZXBDbG9uZShlbnREYXRhWydzb24nXSk7DQogICAgICBsZXQgcmVsTGlzdCA9IFtdOw0KICAgICAgbGV0IHJlbFJvb3RMaXN0ID0gW107DQogICAgICBsZXQgcHNOdW0gPSAwLjU7DQogICAgICBpZiAoKHNvbnMubGVuZ3RoID4gMCkpIHsNCiAgICAgICAgaW50ZXIgPSAxNA0KICAgICAgfQ0KDQogICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICBsZXQgb0RhdGEgPSBfdGhpcy5kcmF3RW50aXR5TG9jYXRpb247DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgcmUgPSAwOyByZSA8IGJhc2ljUmVsLmxlbmd0aDsgcmUrKykgew0KDQogICAgICAgIGxldCBzb3JjZUlkID0gYmFzaWNSZWxbcmVdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyZV1bMV07DQogICAgICAgIGxldCBjTm9kZSA9ICcnOw0KICAgICAgICBpZiAoc29yY2VJZCA9PSBkYUlkKSB7DQogICAgICAgICAgY05vZGUgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pOw0KICAgICAgICAgIHJlbExpc3QucHVzaCh0YXJnZXRJZCk7DQogICAgICAgICAgcmVsUm9vdExpc3QucHVzaChjTm9kZVsncm9vdEluZGV4J10pOw0KICAgICAgICB9DQoNCiAgICAgICAgaWYgKHRhcmdldElkID09IGRhSWQpIHsNCiAgICAgICAgICBjTm9kZSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KTsNCiAgICAgICAgICByZWxMaXN0LnB1c2goc29yY2VJZCk7DQogICAgICAgICAgcmVsUm9vdExpc3QucHVzaChjTm9kZVsncm9vdEluZGV4J10pOw0KICAgICAgICB9DQogICAgICB9Ow0KICAgICAgLy8gaWYoZW50RGF0YVtdKSANCiAgICAgIGxldCB3bGluZSA9IDA7DQogICAgICBsZXQgc3VtVG90YWxEdXJhdGlvbkYgPSAwOw0KICAgICAgZW50RGF0YU8uZm9yRWFjaCgoc2VsZiwgaW5keCwgYXJyKSA9PiB7DQogICAgICAgIGxldCB0b3RhbER1cmF0aW9uVmFsdWUgPSBzZWxmWyd0b3RhbER1cmF0aW9uJ107DQogICAgICAgIGxldCB0aW1lTGlzdCA9IHNlbGZbJ3RpbWUnXTsNCiAgICAgICAgbGV0IGxheW91dCA9IHNlbGZbJ2xheW91dCddOw0KICAgICAgICBsZXQgcm9vdEluZGV4ID0gc2VsZlsncm9vdEluZGV4J107DQogICAgICAgIGxldCBkdXJhdGlvbiA9IHRvb2xzLnRpbWUyc2Vjb25kcyh0aW1lTGlzdFsxXSkgLSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMF0pOw0KICAgICAgICB0aW1lU3RlcFIgPSB3aWR0aFNjYWxlKGR1cmF0aW9uKTsNCiAgICAgICAgaWYgKCFyZWxSb290TGlzdC5pbmNsdWRlcyhyb290SW5kZXgpKSB7DQogICAgICAgICAgd2xpbmUgKz0gdGltZVN0ZXBSICogcHNOdW07DQogICAgICAgICAgc3VtVG90YWxEdXJhdGlvbkYgKz0gZHVyYXRpb247DQogICAgICAgIH0NCiAgICAgIH0pDQogICAgICBsZXQgd2lkdGhTY2FsZUEgPSBkMy5zY2FsZUxpbmVhcihbMCwgc3VtVG90YWxEdXJhdGlvbiAtIHN1bVRvdGFsRHVyYXRpb25GXSwgWzAsIE1hdGguUEkgLSB3bGluZV0pOw0KICAgICAgLy8gaWYocm9vdEVudGl0eUxpc3QubGVuZ3RoPT0wKXsNCiAgICAgIC8vICAgd2lkdGhTY2FsZUEgPSB3aWR0aFNjYWxlDQogICAgICAvLyB9DQogICAgICAvLyBsZXQgd2xpbmUgPSAwOw0KICAgICAgZW50RGF0YU8uZm9yRWFjaCgoc2VsZiwgaW5keCwgYXJyKSA9PiB7DQogICAgICAgIGxldCB0b3RhbER1cmF0aW9uVmFsdWUgPSBzZWxmWyd0b3RhbER1cmF0aW9uJ107DQogICAgICAgIGxldCB0aW1lTGlzdCA9IHNlbGZbJ3RpbWUnXTsNCiAgICAgICAgbGV0IGxheW91dCA9IHNlbGZbJ2xheW91dCddOw0KICAgICAgICBsZXQgcm9vdEluZGV4ID0gc2VsZlsncm9vdEluZGV4J107DQogICAgICAgIGxldCBjSWQgPSBzZWxmWydpZCddOw0KICAgICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHRpbWVMaXN0WzBdKTsNCiAgICAgICAgdGltZVN0ZXBSID0gd2lkdGhTY2FsZShkdXJhdGlvbik7DQogICAgICAgIGlmICghcmVsUm9vdExpc3QuaW5jbHVkZXMocm9vdEluZGV4KSkgew0KICAgICAgICAgIGlmIChyZWxSb290TGlzdC5sZW5ndGggIT0gMCkgew0KICAgICAgICAgICAgdGltZVN0ZXBSID0gcHNOdW0gKiB3aWR0aFNjYWxlKGR1cmF0aW9uKTsNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgdGltZVN0ZXBSID0gd2lkdGhTY2FsZUEoZHVyYXRpb24pDQogICAgICAgIH0NCiAgICAgICAgbGV0IGVuZEFuZ2xldCA9IHRpbWVTdGFydFIgKyB0aW1lU3RlcFI7DQogICAgICAgIHZhciBkYXRhc2V0ID0geyBzdGFydEFuZ2xlOiB0aW1lU3RhcnRSLCBlbmRBbmdsZTogZW5kQW5nbGV0IH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQogICAgICAgIHRpbWVTdGFydFIgPSBlbmRBbmdsZXQ7DQogICAgICAgIGxldCBjb2xvciA9ICdibHVlJzsNCiAgICAgICAgbGV0IHJoID0gMzA7DQogICAgICAgIGxldCBoID0gcmg7DQogICAgICAgIGxldCBuaCA9IDA7DQogICAgICAgIGlmIChyZWxSb290TGlzdC5sZW5ndGggIT0gMCkgew0KICAgICAgICAgIGggPSByaCAqIDAuMzIgKyByaCAqIDAuNiAtIDMgKiBsYXlvdXQ7DQogICAgICAgICAgbmggPSByaCAqIDAuMzsNCiAgICAgICAgfQ0KICAgICAgICBpZiAoIXJlbFJvb3RMaXN0LmluY2x1ZGVzKHNlbGZbJ3Jvb3RJbmRleCddKSkgew0KICAgICAgICAgIGggPSByaCAqIDAuNzsNCiAgICAgICAgICBuaCA9IGggKiAwICsgaCAqIDAuNjsNCiAgICAgICAgfQ0KICAgICAgICBlbHNlIHsNCiAgICAgICAgICBkYXRhc2V0LnN0YXJ0QW5nbGUgKz0gMC4wMDM7DQogICAgICAgICAgZGF0YXNldC5lbmRBbmdsZSAtPSAwLjAwMzsNCg0KICAgICAgICB9DQogICAgICAgIHZhciBhcmNQYXRoID0gZDMuYXJjKCkNCiAgICAgICAgICAuaW5uZXJSYWRpdXMociArIGludGVyICsgbmgpDQogICAgICAgICAgLm91dGVyUmFkaXVzKHIgKyBpbnRlciArIGgpOw0KICAgICAgICB2YXIgcGF0aEFyYyA9IGFyY1BhdGgoZGF0YXNldCk7DQogICAgICAgIGxldCBhcmM7DQogICAgICAgIGlmIChyZWxSb290TGlzdC5sZW5ndGggIT0gMCkgew0KICAgICAgICAgIGxldCBqaWFudG91UGF0aCA9IGQzLnBhdGgoKTsNCiAgICAgICAgICBqaWFudG91UGF0aC5hcmMoeCwgeSAtIHIgLyAyLCByICsgaCArIGludGVyLCAtIE1hdGguUEksIDApOw0KDQogICAgICAgICAgLy8gX3RoaXMuZHJhd1RpbWVMaW5lKF90aGlzLmFyY0csIGppYW50b3VQYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDEsICc5LDUnLCAndGltZUxheW91dCAnLCAndGltZUxheW91dCAnKTsNCg0KICAgICAgICAgIGlmIChyZWxSb290TGlzdC5pbmNsdWRlcyhzZWxmWydyb290SW5kZXgnXSkpIHsNCiAgICAgICAgICAgIGlmIChyZWxMaXN0LmluY2x1ZGVzKHBhcnNlSW50KHNlbGZbJ2lkJ10pKSkgew0KICAgICAgICAgICAgICBhcmMgPSBfdGhpcy5kcmF3QXJjKHN2ZywgeCwgeSAtIHIgLyAyLCBwYXRoQXJjLCBzZWxmWydjb2xvciddLCBzZWxmWydjb2xvciddLCBgdGltZUF4aXNGb3IgZiR7ZW50RGF0YVsnaWQnXX0gJHtzZWxmWydpZCddfWAsICcwJywgMCwgMSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgYXJjID0gX3RoaXMuZHJhd0FyYyhzdmcsIHgsIHkgLSByIC8gMiwgcGF0aEFyYywgIndoaXRlIiwgc2VsZlsnY29sb3InXSwgYHRpbWVBeGlzRm9yIGYke2VudERhdGFbJ2lkJ119ICR7c2VsZlsnaWQnXX1gLCAnMCcsIDAuMCwgMC40KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICBhcmMgPSBfdGhpcy5kcmF3QXJjKHN2ZywgeCwgeSAtIHIgLyAyLCBwYXRoQXJjLCBzZWxmWydjb2xvciddLCBzZWxmWydjb2xvciddLCBgdGltZUF4aXNGb3IgZiR7ZW50RGF0YVsnaWQnXX0gJHtzZWxmWydpZCddfWAsICcwJywgMCwgMC4yKTsNCg0KICAgICAgICAgIH0NCiAgICAgICAgICBhcmMub24oIm1vdXNlb3ZlciIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgICBsZXQgY2xhc3NOID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIik7DQogICAgICAgICAgICBsZXQgc0lkID0gKGNsYXNzTi5zcGxpdCgiICIpWzFdICsgIiIpLnNsaWNlKDEpOw0KICAgICAgICAgICAgbGV0IHRJZCA9IGNsYXNzTi5zcGxpdCgiICIpWzJdOw0KICAgICAgICAgICAgX3RoaXMuc2hvd0VudGl0eVJlbElkTGlzdCA9IFtzSWRdDQogICAgICAgICAgICBfdGhpcy5vdmVyRW50aXR5SWQgPSBzSWQ7DQogICAgICAgICAgICBfdGhpcy5vdmVyVGFyZ2V0RW50aXR5SWQgPSB0SWQ7DQogICAgICAgICAgfSkNCiAgICAgICAgICBhcmMub24oIm1vdXNlbGVhdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgbGV0IGNsYXNzTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgICAgbGV0IHNJZCA9IChjbGFzc04uc3BsaXQoIiAiKVsxXSArICIiKS5zbGljZSgxKTsNCiAgICAgICAgICAgIGxldCBzaG93UmVsID0gX3RoaXMuc2hvd0VudGl0eVJlbElkTGlzdDsNCiAgICAgICAgICAgIF90aGlzLm92ZXJUYXJnZXRFbnRpdHlJZCA9ICcnOw0KICAgICAgICAgICAgX3RoaXMub3ZlckVudGl0eUlkID0gX3RoaXMuY3VyRW50SWQ7DQogICAgICAgICAgICBpZiAoX3RoaXMuc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlID09IDEpIHsNCiAgICAgICAgICAgICAgc2hvd1JlbC5wdXNoKHBhcnNlSW50KHNJZCkpDQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgc2hvd1JlbC5zcGxpY2Uoc2hvd1JlbC5pbmRleE9mKHBhcnNlSW50KHNJZCkpLCAxKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0pDQogICAgICAgIH0NCiAgICAgIH0pDQogICAgfSwNCiAgICBkcmF3RW50aXR5KHN2ZywgeCwgeSwgciwgZGF0YSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGNvbG9yX2xpbmVhciA9IF90aGlzLmltcG9ydGFuY2VDb2xvcl9saW5lYXI7DQogICAgICBsZXQgY29tcHV0ZV9jb2xvciA9IF90aGlzLmltcG9ydGFuY2VDb21wdXRlX2NvbG9yOw0KICAgICAgbGV0IHJTY2FsZSA9IF90aGlzLnJlbGV2YW5jZVNjYWxlX2xpbmVhcjsNCiAgICAgIGxldCBvRGF0YSA9IF90aGlzLmRhdGE7DQogICAgICBsZXQgaW1wb3J0YW5jZVZhbHVlID0gZGF0YVsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXTsNCiAgICAgIGxldCByZWxldmFuY2VWYWx1ZSA9IGRhdGFbJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsNCiAgICAgIC8vIGxldCByID0gclNjYWxlKHJlbGV2YW5jZVZhbHVlKQ0KICAgICAgLy8geyAnaWQnOiBkYXRhW2ldWydpZCddLCAieCI6IHgsICJyIjogciwgImxheW91dCI6IGxheSwgInkiOiB5LCAic29uRmxhZyI6IHNvbkZsYWcgfQ0KDQoNCiAgICAgIGlmIChkYXRhWyd0eXBlJ10gPT0gJzEnKSB7DQogICAgICAgIGxldCBhcmVhID0gdG9vbHMuY2FsY1RyaWFuZ2xlKHgsIHksIHIpOw0KICAgICAgICBfdGhpcy5kcmF3VHJpYW5nbGUoc3ZnLCAicmdiKDI1MCwgMTk5LCA4OCkiLCBhcmVhLCAicmdiKDI1MCwgMTk5LCA4OCkiKTsNCg0KICAgICAgICBfdGhpcy5kcmF3VHh0KHN2ZywgeCwgeSArIDgsIDIwLCBbIlQiXSwgJ3doaXRlJywgMjgsICJUIikNCiAgICAgIH0NCiAgICAgIGVsc2UgaWYgKGRhdGFbJ3R5cGUnXSA9PSAnMicpIHsNCiAgICAgICAgbGV0IGFyZWEgPSB0b29scy5jYWxjVHJpYW5nbGUoeCwgeSwgcik7DQogICAgICAgIF90aGlzLmRyYXdUcmlhbmdsZShzdmcsICJyZ2IoMjUwLCAxOTksIDg4KSIsIGFyZWEsICJyZ2IoMjUwLCAxOTksIDg4KSIpOw0KDQogICAgICAgIF90aGlzLmRyYXdUeHQoc3ZnLCB4LCB5ICsgOCwgMjAsIFsiRSJdLCAnd2hpdGUnLCAyOCwgIkUiKQ0KICAgICAgfQ0KICAgICAgZWxzZSB7DQoNCiAgICAgICAgbGV0IGN5ID0geTsNCiAgICAgICAgbGV0IHRvdGFsRHVyYXRpb24gPSBfdGhpcy50b3RhbER1cmF0aW9uOw0KICAgICAgICBsZXQgdGltZUxpbmVTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgdG90YWxEdXJhdGlvbl0sIFt4IC0gciAqIE1hdGguc3FydCgzKSAvIDIsIHggKyByICogTWF0aC5zcXJ0KDMpIC8gMl0pDQogICAgICAgIGxldCB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgX3RoaXMubWF4VG90YWxEdXJhdGlvbiAtIDUwXSwgW3IgLyAyLCByICogKDEgKyBNYXRoLnNxcnQoMykgLyAzICogMildKQ0KICAgICAgICBsZXQgY2lyY2xlQ29sb3IgPSBjb21wdXRlX2NvbG9yKGNvbG9yX2xpbmVhcihpbXBvcnRhbmNlVmFsdWUpKTsNCiAgICAgICAgX3RoaXMuZHJhd0NpcmNsZShzdmcsIHgsIGN5LCByLCBjaXJjbGVDb2xvciwgZGF0YSwgMSwgImVudENpcmNsZSIsICJlbnRDaXJjbGVfIiArIGRhdGFbJ2lkJ10pOw0KDQogICAgICAgIHIgPSByICogTWF0aC5zcXJ0KDMpIC8gMjsNCiAgICAgICAgeSArPSByIC8gMjsNCiAgICAgICAgbGV0IHBhdGggPSBkMy5wYXRoKCk7DQoNCg0KICAgICAgICBwYXRoLm1vdmVUbyh4IC0gciwgeSk7DQogICAgICAgIGxldCBsaW5lTGkgPSBbZGF0YV07DQogICAgICAgIGxldCBsaW5lUG9pbnQgPSBbeyAnaWQnOiBkYXRhWydpZCddLCAndGltZSc6IGRhdGFbJ3RpbWUnXSwgJ3gnOiAwLCAneSc6IDAgfV07DQogICAgICAgIGxldCBqZ2lkTCA9IFtkYXRhWydpZCddXTsNCiAgICAgICAgbGV0IHNpbWlsYXJpdHlSZWxzbGkgPSBbZGF0YVsic2ltaWxhcml0eVJlbCJdXTsNCiAgICAgICAgd2hpbGUgKHNpbWlsYXJpdHlSZWxzbGkubGVuZ3RoID4gMCkgew0KICAgICAgICAgIGxldCBzaW1pbGFyaXR5UmVscyA9IHNpbWlsYXJpdHlSZWxzbGlbMF07DQogICAgICAgICAgc2ltaWxhcml0eVJlbHNsaS5zcGxpY2UoMCwgMSk7DQogICAgICAgICAgbGV0IGpnID0gMDsNCiAgICAgICAgICBmb3IgKGxldCBzcmVsIGluIHNpbWlsYXJpdHlSZWxzKSB7DQogICAgICAgICAgICBsZXQgY2RhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNpbWlsYXJpdHlSZWxzW3NyZWxdIH0pOw0KICAgICAgICAgICAgaWYgKGpnaWRMLmluZGV4T2YoY2RhdGFbJ2lkJ10pID09IC0xKSB7DQogICAgICAgICAgICAgIHNpbWlsYXJpdHlSZWxzbGkucHVzaChjZGF0YVsic2ltaWxhcml0eVJlbCJdKQ0KICAgICAgICAgICAgICBqZyA9IDE7DQogICAgICAgICAgICAgIGxpbmVMaS5wdXNoKGNkYXRhKQ0KICAgICAgICAgICAgICBqZ2lkTC5wdXNoKGNkYXRhWydpZCddKQ0KICAgICAgICAgICAgICBsaW5lUG9pbnQucHVzaCh7ICdpZCc6IGNkYXRhWydpZCddLCAndGltZSc6IGNkYXRhWyd0aW1lJ10sICd4JzogMCwgJ3knOiAwIH0pDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIC8vIGlmKGpnPT0wKXsNCiAgICAgICAgICAvLyBicmVhazsNCiAgICAgICAgICAvLyB9DQogICAgICAgIH0NCg0KICAgICAgICBjb25zdCBzb3J0bXQgPSAoYSwgYikgPT4gew0KICAgICAgICAgIHJldHVybiB0b29scy50aW1lMnNlY29uZHMoYVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlswXSk7DQogICAgICAgIH0NCiAgICAgICAgY29uc3Qgc29ydGxwID0gKGEsIGIpID0+IHsNCiAgICAgICAgICByZXR1cm4gdG9vbHMudGltZTJzZWNvbmRzKGFbJ3RpbWUnXVswXSkgLSB0b29scy50aW1lMnNlY29uZHMoYlsndGltZSddWzBdKTsNCiAgICAgICAgfQ0KDQogICAgICAgIGxpbmVMaSA9IGxpbmVMaS5zb3J0KHNvcnRscCk7DQogICAgICAgIGxpbmVQb2ludCA9IGxpbmVQb2ludC5zb3J0KHNvcnRscCk7DQogICAgICAgIGxldCBsaW5lRGF0YSA9IFtbeCAtIHIgKiBNYXRoLnNxcnQoMykgLyAyIC0gNCwgeV1dOw0KICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGxpbmVMaS5sZW5ndGg7IHQrKykgew0KICAgICAgICAgIGxldCBzdGFydFQgPSBsaW5lTGlbdF1bJ3RpbWUnXVswXTsNCiAgICAgICAgICBsZXQgZHVyYXRpb24gPSBsaW5lTGlbdF1bJ3RvdGFsRHVyYXRpb24nXQ0KICAgICAgICAgIC8vIGxldCBlbmRUID0gbGluZUxpW3RdWyd0aW1lJ11bMV07DQogICAgICAgICAgbGV0IHN0YXJ0UyA9IHRvb2xzLnRpbWUyc2Vjb25kcyhzdGFydFQpOw0KICAgICAgICAgIGxldCBlbmRTID0gc3RhcnRTICsgZHVyYXRpb247DQogICAgICAgICAgLy8gbGV0IHN0YXJ0eCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMgLSBkdXJhdGlvbiAqIDEwKSk7DQogICAgICAgICAgLy8gbGV0IGVuZHggPSB0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUyArIGR1cmF0aW9uICogMTApKTsNCiAgICAgICAgICBsZXQgbGltc3QgPSAoeCAtIHIgKiBNYXRoLnNxcnQoMykgLyAyKTsNCiAgICAgICAgICBsZXQgbGltZWQgPSAoeCArIHIgKiBNYXRoLnNxcnQoMykgLyAyKTsNCiAgICAgICAgICBsZXQgc3RhcnR4ID0gKGxpbXN0IDwgdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKSA/ICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTKSkpIDogKGxpbXN0KTsNCiAgICAgICAgICBsZXQgZW5keCA9IChsaW1lZCA+IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTKSkpID8gKHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTKSkpIDogKGxpbWVkKTsNCiAgICAgICAgICAvLyBsZXQgbWlkeCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTICsgc3RhcnRTKSAvIDIpOw0KICAgICAgICAgIGxldCBtaWR4ID0gKHN0YXJ0eCArIGVuZHgpIC8gMjsNCiAgICAgICAgICBsZXQgeXMgPSB5Ow0KICAgICAgICAgIGxldCB5eiA9IHkgLSB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSk7DQogICAgICAgICAgbGluZVBvaW50W3RdWyd4J10gPSBtaWR4Ow0KICAgICAgICAgIGxpbmVQb2ludFt0XVsneSddID0geSAtIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcihkdXJhdGlvbikgLyAxLjc7DQogICAgICAgICAgLy8gaWYgKHN0YXJ0eCA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHsNCiAgICAgICAgICBpZiAodCA+IDApIHsNCiAgICAgICAgICAgIGxpbmVEYXRhLnNwbGljZShsaW5lRGF0YS5sZW5ndGggLSAxLCAxKTsNCiAgICAgICAgICAgIG1pZHggKz0gdCAqIDU7DQogICAgICAgICAgICBzdGFydHggPSBtaWR4IC0gKChtaWR4IC0gKGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdICsgbWlkeCkgLyAyKSkgLyAyOw0KICAgICAgICAgICAgZW5keCArPSB0ICogNTsNCiAgICAgICAgICAgIHlzID0geSArICh5IC0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMV0pIC8gMw0KICAgICAgICAgIH0NCiAgICAgICAgICAvLyB9DQogICAgICAgICAgbGluZURhdGEucHVzaChbc3RhcnR4LCB5c10sIFttaWR4LCB5el0sIFtlbmR4LCB5XSkNCiAgICAgICAgICAvLyBsZXQgc3RhcnR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyAtIGR1cmF0aW9uICogMTApKTsNCiAgICAgICAgICAvLyBsZXQgZW5keCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTICsgZHVyYXRpb24gKiAxMCkpOw0KDQogICAgICAgICAgLy8gbGV0IHN0YXJ0eWYgPSB5ICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gODsNCiAgICAgICAgICAvLyBsZXQgc3RhcnR5ZjEgPSB5ICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gODsNCiAgICAgICAgICAvLyBsZXQgZW5keWYgPSB5ICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gODsNCiAgICAgICAgICAvLyBsZXQgZW5keWYxID0geSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDg7DQogICAgICAgICAgLy8gbGV0IHl6ID0geSAtIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKTsNCiAgICAgICAgICAvLyBsZXQgbWlkeCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChlbmRTICsgc3RhcnRTKSAvIDIpOw0KICAgICAgICAgIC8vIGxpbmVQb2ludFt0XVsneCddID0gbWlkeDsNCiAgICAgICAgICAvLyBsaW5lUG9pbnRbdF1bJ3knXSA9IHkgLSB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoZHVyYXRpb24pIC8gMS43Ow0KICAgICAgICAgIC8vIGxldCB5MSA9IHk7DQogICAgICAgICAgLy8gaWYgKHN0YXJ0eCA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHsNCiAgICAgICAgICAvLyAgIGlmICh0ID4gMCkgew0KICAgICAgICAgIC8vICAgICBsaW5lRGF0YS5zcGxpY2UobGluZURhdGEubGVuZ3RoIC0gMywgMyk7DQogICAgICAgICAgLy8gICAgIHN0YXJ0eCA9IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSArIG1pZHgpIC8gMjsNCiAgICAgICAgICAvLyAgICAgeTEgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVsxXSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDI7DQogICAgICAgICAgLy8gICAgIHN0YXJ0eWYgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVsxXSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDI7DQogICAgICAgICAgLy8gICAgIHN0YXJ0eWYxID0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMV0gKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyAyOw0KICAgICAgICAgIC8vICAgfQ0KICAgICAgICAgIC8vIH0NCiAgICAgICAgICAvLyBsZXQgc3RhcnR4MSA9IHN0YXJ0eCArICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTICsgZHVyYXRpb24pKSAtIHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSk7DQogICAgICAgICAgLy8gbGV0IGVuZHgxID0gZW5keCAtICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTICsgZHVyYXRpb24pKSAtIHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSk7DQogICAgICAgICAgLy8gbGV0IHN0YXJ0eDIgPSBzdGFydHgxICsgKHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMgKyBkdXJhdGlvbikpIC0gdGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKTsNCiAgICAgICAgICAvLyBsZXQgZW5keDIgPSBlbmR4MSAtICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTICsgZHVyYXRpb24pKSAtIHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSk7DQogICAgICAgICAgLy8gaWYgKGVuZHggPiAociArIHgpKSBlbmR4ID0gciArIHg7DQogICAgICAgICAgLy8gaWYgKHN0YXJ0eDEgPCAobGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF0pKSBzdGFydHgxID0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF07DQogICAgICAgICAgLy8gaWYgKGVuZHgxID4gKHIgKyB4KSkgZW5keDEgPSByICsgeDsNCiAgICAgICAgICAvLyBpZiAoc3RhcnR4MiA8IChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSkpIHN0YXJ0eDIgPSBsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXTsNCiAgICAgICAgICAvLyBpZiAoZW5keDIgPiAociArIHgpKSBlbmR4MiA9IHIgKyB4Ow0KICAgICAgICAgIC8vIGxpbmVEYXRhLnB1c2goW3N0YXJ0eCwgeTFdLCBbc3RhcnR4MSwgc3RhcnR5ZjFdLCBbc3RhcnR4Miwgc3RhcnR5Zl0sIFttaWR4LCB5el0sIFtlbmR4MiwgZW5keWZdLCBbZW5keDEsIGVuZHlmMV0sIFtlbmR4LCB5XSkNCiAgICAgICAgfQ0KICAgICAgICBsaW5lRGF0YS5wdXNoKFt4ICsgciwgeV0pDQogICAgICAgIGxldCBjdXJ2ZV9nZW5lcmF0b3IgPSBkMy5saW5lKCkNCiAgICAgICAgICAueCgoZCkgPT4gZFswXSkNCiAgICAgICAgICAueSgoZCkgPT4gew0KICAgICAgICAgICAgbGV0IGggPSBNYXRoLnNxcnQoTWF0aC5wb3cociwgMikgLSBNYXRoLnBvdygoZFswXSAtICh4IC0gcikpLCAyKSk7DQogICAgICAgICAgICBpZiAoKHkgLSBkWzFdKSA+IChoICsgciAqIE1hdGguc3FydCgzKSAvIDIpKQ0KICAgICAgICAgICAgICByZXR1cm4geSAtIChoICsgciAqIE1hdGguc3FydCgzKSAvIDIpICsgMjsNCiAgICAgICAgICAgIHJldHVybiBkWzFdOw0KICAgICAgICAgIH0pDQogICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQnVuZGxlKQ0KICAgICAgICAvLyAuY3VydmUoZDMuY3VydmVDYXRtdWxsUm9tICApDQogICAgICAgIC8vIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKQ0KICAgICAgICBfdGhpcy5kcmF3VGltZUxpbmUoc3ZnLCBjdXJ2ZV9nZW5lcmF0b3IobGluZURhdGEpLCAid2hpdGUiLCAyLCAnMCcsICdzb25MaW5lICcsICdzb25MaW5lICcpOw0KDQoNCiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBsaW5lUG9pbnQubGVuZ3RoOyBwKyspIHsNCiAgICAgICAgICBfdGhpcy5kcmF3Q2lyY2xlKHN2ZywgbGluZVBvaW50W3BdWyd4J10sIGxpbmVQb2ludFtwXVsneSddLCA1LCAicmVkIiwgbGluZVBvaW50W3BdLCAwLCAibGluZVBvaW50IiwgImxpbmVQb2ludF8iICsgbGluZVBvaW50W3BdWydpZCddKTsNCiAgICAgICAgfQ0KDQogICAgICAgIC8vICIxIjogInJnYigxNDUsIDIwNCwgMTE3KSIsDQogICAgICAgIC8vICAgIjIiOiAicmdiKDg0LCAxMTIsIDE5OCkiLA0KICAgICAgICAvLyAgICIzIjogInJnYigyMzgsIDEwMiwgMTAyKSIsDQogICAgICAgIGxldCB0eXBlQ29sb3IgPSB7DQogICAgICAgICAgIjEiOiAiI2ZmOWM5YyIsDQogICAgICAgICAgIjIiOiAiI2Y0ZjRkMCIsDQogICAgICAgICAgIjMiOiAiIzZmOGJlMCIsDQogICAgICAgIH07DQogICAgICAgIGxldCBkdXJhdGlvbiA9IHRvb2xzLnRpbWUyc2Vjb25kcyhkYXRhWyd0aW1lJ11bMF0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGRhdGFbJ3RpbWUnXVsxXSk7DQogICAgICAgIGxldCB0eXBlRGF0YSA9IGRhdGFbJ2F0dHJpYnV0ZSddWydleHByZXNzaW9ucyddOw0KICAgICAgICBsZXQgc29uTGlzdCA9IGRhdGFbJ3NvbiddOw0KICAgICAgICBsZXQgc29ucyA9IFtzb25MaXN0XTsNCiAgICAgICAgd2hpbGUgKHNvbnMubGVuZ3RoID4gMCkgew0KICAgICAgICAgIGxldCBjdXJTb25MaXN0ID0gc29uc1swXTsNCiAgICAgICAgICBzb25zLnNwbGljZSgwLCAxKTsNCiAgICAgICAgICBpZiAoY3VyU29uTGlzdC5sZW5ndGggPiAwKSB7DQogICAgICAgICAgICBmb3IgKGxldCBzIGluIGN1clNvbkxpc3QpIHsNCiAgICAgICAgICAgICAgbGV0IHNvbkRhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGN1clNvbkxpc3Rbc10gfSk7DQogICAgICAgICAgICAgIGxldCBzb25UeXBlRGF0YSA9IHNvbkRhdGFbJ2F0dHJpYnV0ZSddWydleHByZXNzaW9ucyddOw0KDQogICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gc29uVHlwZURhdGEpIHsNCiAgICAgICAgICAgICAgICBsZXQgdHlwZUR1cml0aW9uID0gc29uVHlwZURhdGFbdF07DQogICAgICAgICAgICAgICAgZm9yIChsZXQgZCBpbiB0eXBlRHVyaXRpb24pIHsNCiAgICAgICAgICAgICAgICAgIHR5cGVEYXRhW3RdLnB1c2godHlwZUR1cml0aW9uW2RdKQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBzb25zLnB1c2goc29uRGF0YVsnc29uJ10pOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICB2YXIgdHlwZVN0YXJ0UiA9IDAvL01hdGguUEkvNDsNCg0KICAgICAgICB2YXIgdHlwZVN0ZXBSID0gTWF0aC5QSSAvIDE7DQoNCiAgICAgICAgaWYgKHNvbkxpc3QubGVuZ3RoID4gMCkgew0KICAgICAgICAgIGxldCB0eXBlVG90YWxEdXIgPSAwOw0KICAgICAgICAgIGZvciAobGV0IHQgaW4gdHlwZURhdGEpIHsNCiAgICAgICAgICAgIGxldCB0eXBlRHVyaXRpb24gPSB0eXBlRGF0YVt0XTsNCiAgICAgICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgICAgIHR5cGVUb3RhbER1ciArPSAodG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzBdKSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgbGV0IHR5cGVBcmNTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgdHlwZVRvdGFsRHVyXSwgWzAsIE1hdGguUEkgKiAyXSk7DQogICAgICAgICAgZm9yIChsZXQgaSBpbiB0eXBlRGF0YSkgew0KICAgICAgICAgICAgbGV0IGNvbG9yID0gdHlwZUNvbG9yW2ldOw0KICAgICAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHR5cGVEYXRhW2ldOw0KICAgICAgICAgICAgbGV0IHRvdGFsVHlwZVNlY29uZHMgPSAwOw0KICAgICAgICAgICAgZm9yIChsZXQgZCBpbiB0eXBlRHVyaXRpb24pIHsNCiAgICAgICAgICAgICAgdG90YWxUeXBlU2Vjb25kcyArPSAodG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHModHlwZUR1cml0aW9uW2RdWzBdKSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICh0b3RhbFR5cGVTZWNvbmRzID4gMCkgew0KICAgICAgICAgICAgICBsZXQgdHlwZVN0ZXBSID0gdHlwZUFyY1NjYWxlX2xpbmVhcih0b3RhbFR5cGVTZWNvbmRzKS8vTWF0aC5QSS8yOw0KDQogICAgICAgICAgICAgIGxldCBlbmRBbmdsZXQgPSB0eXBlU3RhcnRSICsgMSAqIHR5cGVTdGVwUg0KICAgICAgICAgICAgICB2YXIgZGF0YXNldCA9IHsgc3RhcnRBbmdsZTogdHlwZVN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgICAgICAgICAgICB0eXBlU3RhcnRSID0gZW5kQW5nbGV0Ow0KICAgICAgICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKHIgKyAxMCkNCiAgICAgICAgICAgICAgICAub3V0ZXJSYWRpdXMociArIDI1KTsNCiAgICAgICAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KICAgICAgICAgICAgICBfdGhpcy5kcmF3QXJjKHN2ZywgeCwgeSAtIHIgLyAyLCBwYXRoQXJjLCBjb2xvciwgY29sb3IsICd0eXBlIGYnICsgZGF0YVsnaWQnXSArICIgdCIgKyBpKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgbGV0IHNvblRvdGFsID0gMDsNCiAgICAgICAgICBsZXQgc29uTnVtID0gMA0KICAgICAgICAgIGZvciAobGV0IHMgaW4gc29uTGlzdCkgew0KICAgICAgICAgICAgbGV0IHNvbkRhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNvbkxpc3Rbc10gfSk7DQogICAgICAgICAgICBsZXQgc29uRHVyID0gc29uRGF0YVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgICAgICAgc29uVG90YWwgKz0gc29uRHVyOw0KICAgICAgICAgICAgc29uTnVtICs9IDE7DQogICAgICAgICAgfQ0KICAgICAgICAgIGxldCBza2lwQXJjID0gTWF0aC5QSSAvIChzb25OdW0gKyAyKTsNCiAgICAgICAgICBsZXQgdGltZVNvbkxpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBzb25Ub3RhbF0sIFswLCBNYXRoLlBJIC0gc2tpcEFyYyAqIChzb25OdW0gLSAxKV0pOw0KICAgICAgICAgIGxldCB0aW1lU29uSGVpZ2hMaW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgc29uVG90YWxdLCBbNDAsIDQwXSk7DQoNCiAgICAgICAgICBsZXQgdGltZVNvbkNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBzb25Ub3RhbF0pLnJhbmdlKFswLCAxXSk7DQogICAgICAgICAgbGV0IHRpbWVTb25Db21wdXRlX2NvbG9yID0gZDMuaW50ZXJwb2xhdGUoIndoaXRlIiwgY2lyY2xlQ29sb3IpOw0KICAgICAgICAgIHZhciBzb25TdGFydFIgPSBNYXRoLlBJIC8gMjsNCg0KICAgICAgICAgIGxldCByZWxMaXN0ID0gW107DQogICAgICAgICAgbGV0IHJlbFJvb3RMaXN0ID0gW107DQogICAgICAgICAgbGV0IHBzTnVtID0gMC4xOw0KICAgICAgICAgIGxldCBkYUlkID0gZGF0YVsnaWQnXQ0KICAgICAgICAgIGxldCByZWxEYXRhID0gX3RoaXMucmVsRGF0YTsNCiAgICAgICAgICBsZXQgb2REYXRhID0gX3RoaXMuZGF0YTsNCiAgICAgICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgICAgIGZvciAobGV0IHJlID0gMDsgcmUgPCBiYXNpY1JlbC5sZW5ndGg7IHJlKyspIHsNCg0KICAgICAgICAgICAgbGV0IHNvcmNlSWQgPSBiYXNpY1JlbFtyZV1bMF07DQogICAgICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyZV1bMV07DQogICAgICAgICAgICBsZXQgY05vZGUgPSAnJzsNCiAgICAgICAgICAgIGlmIChzb3JjZUlkID09IGRhSWQpIHsNCiAgICAgICAgICAgICAgY05vZGUgPSBvZERhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcGFyc2VJbnQoZFsnaWQnXSkgPT0gcGFyc2VJbnQodGFyZ2V0SWQpIH0pOw0KICAgICAgICAgICAgICByZWxMaXN0LnB1c2godGFyZ2V0SWQpOw0KICAgICAgICAgICAgfQ0KDQogICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT0gZGFJZCkgew0KICAgICAgICAgICAgICBjTm9kZSA9IG9kRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBwYXJzZUludChkWydpZCddKSA9PSBwYXJzZUludChzb3JjZUlkKSB9KTsNCiAgICAgICAgICAgICAgcmVsTGlzdC5wdXNoKHNvcmNlSWQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH07DQogICAgICAgICAgaWYgKHJlbExpc3QubGVuZ3RoID09IDApIHsNCiAgICAgICAgICAgIHNvblN0YXJ0UiA9IDA7DQogICAgICAgICAgICB0aW1lU29uTGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHNvblRvdGFsXSwgWzAsIE1hdGguUEkgKiAyIC0gc2tpcEFyYyAqIChzb25OdW0pXSk7DQogICAgICAgICAgfQ0KDQogICAgICAgICAgZm9yIChsZXQgcyBpbiBzb25MaXN0KSB7DQogICAgICAgICAgICBsZXQgc29uRGF0YSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29uTGlzdFtzXSB9KTsNCiAgICAgICAgICAgIGxldCBzb25EdXIgPSBzb25EYXRhWyd0b3RhbER1cmF0aW9uJ107DQoNCiAgICAgICAgICAgIGxldCBzb25TdGVwUiA9IHRpbWVTb25MaW5lYXIoc29uRHVyKS8vTWF0aC5QSS8yOw0KDQogICAgICAgICAgICBsZXQgZW5kQW5nbGV0ID0gc29uU3RhcnRSICsgc29uU3RlcFI7DQogICAgICAgICAgICB2YXIgZGF0YXNldCA9IHsgc3RhcnRBbmdsZTogc29uU3RhcnRSLCBlbmRBbmdsZTogZW5kQW5nbGV0IH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQogICAgICAgICAgICBzb25TdGFydFIgPSBlbmRBbmdsZXQ7DQogICAgICAgICAgICBsZXQgY29sb3IgPSAnYmx1ZSc7DQogICAgICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgICAgIC5pbm5lclJhZGl1cyhyICsgMjgpDQogICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgdGltZVNvbkhlaWdoTGluZWFyKHNvbkR1cikpOw0KICAgICAgICAgICAgdmFyIGFyY01pZFBhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgICAgICAuaW5uZXJSYWRpdXMoMCkNCiAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKHIgKyAzMik7DQogICAgICAgICAgICB2YXIgcGF0aEFyYyA9IGFyY1BhdGgoZGF0YXNldCk7DQoNCiAgICAgICAgICAgIGVuZEFuZ2xldCA9IHNvblN0YXJ0UiArIHNraXBBcmM7DQogICAgICAgICAgICB2YXIgbWlkRGF0YXNldCA9IHsgc3RhcnRBbmdsZTogc29uU3RhcnRSLCBlbmRBbmdsZTogZW5kQW5nbGV0IH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQoNCiAgICAgICAgICAgIGxldCBqaWFudG91UGF0aCA9IGQzLnBhdGgoKTsNCiAgICAgICAgICAgIGppYW50b3VQYXRoLmFyYyh4LCB5IC0gciAvIDIsIHIgKyAzMiwgc29uU3RhcnRSIC0gTWF0aC5QSSAvIDIsIGVuZEFuZ2xldCAtIE1hdGguUEkgLyAyKTsNCg0KICAgICAgICAgICAgc29uU3RhcnRSICs9IHNraXBBcmM7DQogICAgICAgICAgICB2YXIgcGF0aE1pZEFyYyA9IGFyY01pZFBhdGgobWlkRGF0YXNldCk7DQogICAgICAgICAgICBsZXQgdGltZVNvbkNvbG9yID0gY29tcHV0ZV9jb2xvcihjb2xvcl9saW5lYXIoc29uRGF0YVsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXSkpOw0KICAgICAgICAgICAgX3RoaXMuZHJhd0FyYyhzdmcsIHgsIHkgLSByIC8gMiwgcGF0aEFyYywgdGltZVNvbkNvbG9yLCB0aW1lU29uQ29sb3IsICdzb24gZicgKyBkYXRhWydpZCddICsgIiBzIiArIHNvbkxpc3Rbc10sICcwJyk7DQogICAgICAgICAgICBpZiAocyAhPSBzb25MaXN0Lmxlbmd0aCAtIDEpIHsNCg0KICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZw0KICAgICAgICAgICAgICBfdGhpcy5kcmF3VGltZUxpbmUoX3RoaXMuYXJjRywgamlhbnRvdVBhdGgsICJyZ2IoMjAwLDIwMCwyMDApIiwgMywgJzksNScsICdtaWRBcmMgJywgJ21pZEFyYyAnKTsNCiAgICAgICAgICAgICAgLy8gX3RoaXMuZHJhd1RpbWVMaW5lKF90aGlzLmFyY0csIHBhdGgsICJ3aGl0ZSIsIDIsJzAnLCAnc29uTGluZSAnLCAnc29uTGluZSAnKTsNCiAgICAgICAgICAgICAgLy8gX3RoaXMuZHJhd0FyYyhfdGhpcy5hcmNHLCB4LCB5IC0gciAvIDIsIHBhdGhNaWRBcmMsICJyZ2IoMjAwLDIwMCwyMDApIiwgIndoaXRlIiwgJ3NvbiBmJyArIGRhdGFbJ2lkJ10sICI5LDUiLCAzKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQoNCiAgICAgICAgfTsNCiAgICAgIH0NCiAgICAgIGxldCB0eHRzID0gZGF0YVsnbmFtZSddLnNwbGl0KCIgIikNCiAgICAgIGxldCB0eCA9IHggLSByIC0gMzA7DQogICAgICBsZXQgdHkgPSB5ICsgciArIDYwOw0KICAgICAgbGV0IHR3ID0gciAqIDI7DQogICAgICB0eCA9IHg7DQogICAgICBpZiAoZGF0YVsnc29uJ10ubGVuZ3RoID09IDApIHsNCiAgICAgICAgdHggPSB4Ly8tci0xMDsNCiAgICAgICAgdHkgPSB5ICsgciAqIDI7DQogICAgICB9DQogICAgICBpZiAoZGF0YVsnaWQnXSA9PSAiMyIpIHsNCiAgICAgICAgdHggPSB4IC0gMTA7DQogICAgICAgIHR5ID0geSArIHIgKiAyOw0KICAgICAgfQ0KICAgICAgaWYgKGRhdGFbJ2lkJ10gPT0gIjQiKSB7DQogICAgICAgIHR4ID0geCArIDEwOw0KICAgICAgICB0eSA9IHkgKyByICogMjsNCiAgICAgIH0NCiAgICAgIC8vIGlmKGRhdGFbJ3R5cGUnXT09JzEnKXsNCiAgICAgIC8vICAgdHggPSB4LXIvMjsNCiAgICAgIC8vICAgdHkgPSB5K3IqMjsNCiAgICAgIC8vIH0NCg0KICAgICAgX3RoaXMuZHJhd1R4dChzdmcsIHR4LCB0eSwgdHcsIHR4dHMsICJncmV5IiwgMTYsIGB0ZXh0XyR7ZGF0YVsnaWQnXX1gKTsNCiAgICB9LA0KICAgIGRyYXdBcmMoc3ZnLCB4LCB5LCBhcmNQYXRoLCBzdHJva2UsIGZpbGwsIGNsYXNzTmFtZSwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgd2lkdGggPSAzLCBvcGFjaXR5ID0gMSkgew0KICAgICAgbGV0IGFyYyA9IHN2Zy5hcHBlbmQoInBhdGgiKQ0KICAgICAgICAuYXR0cigiZCIsIGFyY1BhdGgpDQogICAgICAgIC5hdHRyKCJjbGFzcyIsIGNsYXNzTmFtZSkNCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoIiArIHggKyAiLCIgKyB5ICsgIikiKQ0KICAgICAgICAuYXR0cigic3Ryb2tlIiwgc3Ryb2tlKQ0KICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgd2lkdGgpDQogICAgICAgIC5hdHRyKCJzdHJva2UtZGFzaGFycmF5Iiwgc3Ryb2tlX2Rhc2hhcnJheSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS1saW5lam9pbiIsICJyb3VuZCIpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBvcGFjaXR5KTsNCiAgICAgIHJldHVybiBhcmM7DQogICAgfSwNCiAgICBkcmF3Q2lyY2xlKHN2ZywgeCwgeSwgciwgZmlsbCwgZGF0YSwgb3BhY2l0eSwgY2xhc3NOYW1lLCBpZE5hbWUpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGNvbnN0IG9EYXRhID0gX3RoaXMuZGF0YQ0KICAgICAgc3ZnLmFwcGVuZCgiY2lyY2xlIikNCiAgICAgICAgLmF0dHIoImlkIiwgaWROYW1lKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoImN4IiwgeCkNCiAgICAgICAgLmF0dHIoImN5IiwgeSkNCiAgICAgICAgLmF0dHIoInIiLCByKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5vbigibW91c2VvdmVyIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiciIsIHIgKiAxLjEpDQogICAgICAgICAgbGV0IGNsYXNzTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBpZE4gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdDQogICAgICAgICAgX3RoaXMub3ZlckVudGl0eUlkID0gaWRODQogICAgICAgICAgbGV0IHNob3dSZWwgPSBfdGhpcy5zaG93RW50aXR5UmVsSWRMaXN0DQogICAgICAgICAgaWYgKCFzaG93UmVsLmluY2x1ZGVzKHBhcnNlSW50KGlkTikpKSB7DQogICAgICAgICAgICBzaG93UmVsLnB1c2gocGFyc2VJbnQoaWROKSkNCiAgICAgICAgICAgIF90aGlzLnNob3dFbnRpdHlSZWxJZE92ZXJTdGF0ZSA9IDA7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgX3RoaXMuc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlID0gMTsNCiAgICAgICAgICB9DQogICAgICAgICAgX3RoaXMuc2hvd0VudGl0eVJlbElkTGlzdCA9IHNob3dSZWw7DQogICAgICAgICAgaWYgKGNsYXNzTiA9PSAnbGluZVBvaW50Jykgew0KICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoIm9wYWNpdHkiLCAxKS5hdHRyKCJyIiwgNSkNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5mIiArIGRhdGFbJ2lkJ10pDQogICAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1kID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoInRyYW5zZm9ybSIpDQogICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWQuc3BsaXQoIiAiKVswXSArICIgc2NhbGUoMS4xKSINCiAgICAgICAgICAgICAgfSkNCg0KICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCIuYmFzaWNSZWwiKQ0KICAgICAgICAgICAgICAuYXR0cigiY2xhc3MiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgICAgIGxldCBjbGFzc04gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOTGlzdCA9IGNsYXNzTi5zcGxpdCgiICIpOw0KICAgICAgICAgICAgICAgIGxldCBqZyA9IDA7DQogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc05MaXN0Lmxlbmd0aCAtIDE7IGkrKykgew0KICAgICAgICAgICAgICAgICAgaWYgKCdzb3VyY2UnICsgZGF0YVsnaWQnXSA9PSBjbGFzc05MaXN0W2ldKSB7IGpnID0gMTsgfQ0KICAgICAgICAgICAgICAgICAgaWYgKCd0YXJnZXQnICsgZGF0YVsnaWQnXSA9PSBjbGFzc05MaXN0W2ldKSB7IGpnID0gMTsgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBpZiAoamcgPT0gMSkgew0KICAgICAgICAgICAgICAgICAgY2xhc3NOICs9ICIgYWN0aXZlUyI7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc047DQogICAgICAgICAgICAgIH0pDQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KICAgICAgICAub24oIm1vdXNlbGVhdmUiLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJyIiwgcikNCg0KICAgICAgICAgIF90aGlzLm92ZXJFbnRpdHlJZCA9IF90aGlzLmN1ckVudElkOw0KICAgICAgICAgIGxldCBjbGFzc04gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiKTsNCg0KICAgICAgICAgIGxldCBpZE4gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdDQogICAgICAgICAgbGV0IHNob3dSZWwgPSBfdGhpcy5zaG93RW50aXR5UmVsSWRMaXN0DQogICAgICAgICAgaWYgKF90aGlzLnNob3dFbnRpdHlSZWxJZE92ZXJTdGF0ZSA9PSAxKSB7DQogICAgICAgICAgICBzaG93UmVsLnB1c2gocGFyc2VJbnQoaWROKSkNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICBzaG93UmVsLnNwbGljZShzaG93UmVsLmluZGV4T2YocGFyc2VJbnQoaWROKSksIDEpDQogICAgICAgICAgfQ0KICAgICAgICAgIF90aGlzLnNob3dFbnRpdHlSZWxJZExpc3QgPSBzaG93UmVsOw0KDQogICAgICAgICAgaWYgKGNsYXNzTiA9PSAnbGluZVBvaW50Jykgew0KICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoIm9wYWNpdHkiLCAwKS5hdHRyKCJyIiwgNSkNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5mIiArIGRhdGFbJ2lkJ10pDQogICAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1kID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoInRyYW5zZm9ybSIpDQogICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWQuc3BsaXQoIiAiKVswXSArICIgc2NhbGUoMSkiDQogICAgICAgICAgICAgIH0pDQogICAgICAgICAgICBkMy5zZWxlY3QoIiNncmFwaFBhbmVsIikuc2VsZWN0QWxsKCJwYXRoIikNCiAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgICBsZXQgdGhpc1NlbGVjdCA9IGQzLnNlbGVjdCh0aGlzKQ0KICAgICAgICAgICAgICAgIGxldCBjbGFzc04gPSB0aGlzU2VsZWN0LmF0dHIoImNsYXNzIik7DQogICAgICAgICAgICAgICAgbGV0IGNsYXNzTkxpc3QgPSBjbGFzc04uc3BsaXQoIiAiKQ0KICAgICAgICAgICAgICAgIGlmIChjbGFzc05MaXN0W2NsYXNzTkxpc3QubGVuZ3RoIC0gMV0gPT0gImFjdGl2ZVMiKSB7DQogICAgICAgICAgICAgICAgICBjbGFzc04gPSAiIjsNCiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NOTGlzdC5sZW5ndGggLSAxOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgICAgY2xhc3NOICs9ICIgIiArIGNsYXNzTkxpc3RbaV07DQogICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc04NCiAgICAgICAgICAgICAgfSkNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbigiY2xpY2siLCBmdW5jdGlvbiAoZCkgew0KDQogICAgICAgICAgbGV0IGlkTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV0NCiAgICAgICAgICBsZXQgc2hvd1JlbCA9IF90aGlzLnNob3dFbnRpdHlSZWxJZExpc3Q7DQogICAgICAgICAgLy8gIC0gX3RoaXMuc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlOw0KICAgICAgICAgIGlmICghc2hvd1JlbC5pbmNsdWRlcyhwYXJzZUludChpZE4pKSkgew0KICAgICAgICAgICAgc2hvd1JlbCA9IFsocGFyc2VJbnQoaWROKSldDQogICAgICAgICAgICBfdGhpcy5zaG93RW50aXR5UmVsSWRPdmVyU3RhdGUgPSAxOw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIGlmIChzaG93UmVsLmluY2x1ZGVzKHBhcnNlSW50KGlkTikpKSB7DQogICAgICAgICAgICAvLyBzaG93UmVsLmZpbHRlcihpdGVtPT57cmV0dXJuIGl0ZW09PXBhcnNlSW50KGlkTil9KQ0KICAgICAgICAgICAgX3RoaXMuc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlID0gMDsNCiAgICAgICAgICAgIHNob3dSZWwuc3BsaWNlKHNob3dSZWwuaW5kZXhPZihwYXJzZUludChpZE4pKSwgMSkNCiAgICAgICAgICB9DQogICAgICAgICAgX3RoaXMuc2hvd0VudGl0eVJlbElkTGlzdCA9IHNob3dSZWw7DQoNCiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiciIsIHIpOw0KICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmYiICsgZGF0YVsnaWQnXSkNCiAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZCA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJ0cmFuc2Zvcm0iKQ0KICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZC5zcGxpdCgiICIpWzBdICsgIiBzY2FsZSgxKSINCiAgICAgICAgICAgIH0pDQogICAgICAgICAgbGV0IHRoaXNJZCA9IHRoaXMuaWQuc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgICBfdGhpcy5jdXJFbnRJZCA9IHRoaXNJZDsNCiAgICAgICAgICBsZXQgdGhpc0RhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWydpZCddID09IHRoaXNJZCB9KQ0KICAgICAgICAgIGxldCB0aGlzVGltZSA9IHRoaXNEYXRhWyd0aW1lJ107DQogICAgICAgICAgX3RoaXMuY2xpY2tfRW50KHRoaXNUaW1lKTsNCiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzVGltZSx0aGlzSWQsdGhpc0RhdGEpDQogICAgICAgIH0pDQogICAgICAgIC5vbigiY29udGV4dG1lbnUiLCBmdW5jdGlvbiAoZCwgaSkgew0KICAgICAgICAgIGQucHJldmVudERlZmF1bHQoKTsNCg0KICAgICAgICAgIGlmIChfdGhpcy5idG5FZGkpIHsNCiAgICAgICAgICAgIF90aGlzLmVkaXREaXZTaG93ID0gdHJ1ZTsNCiAgICAgICAgICAgIF90aGlzLiRyZWZzLmVkaXREaXYuc3R5bGUudG9wID0gYCR7ZC5jbGllbnRZfXB4YDsNCiAgICAgICAgICAgIF90aGlzLiRyZWZzLmVkaXREaXYuc3R5bGUubGVmdCA9IGAke2QuY2xpZW50WH1weGA7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgbGV0IHRoaXNJZCA9IHRoaXMuaWQuc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgICAgIGxldCB0aGlzU2hvd0VudGl0eURhdGEgPSBfdGhpcy5zaG93RW50aXR5TGlzdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRoaXNJZCB9KTsNCiAgICAgICAgICAgIGxldCB0aGlzU29ucyA9IHRoaXNTaG93RW50aXR5RGF0YVsnc29uJ107DQogICAgICAgICAgICBpZiAodGhpc1NvbnMubGVuZ3RoICE9IDApIHsNCiAgICAgICAgICAgICAgbGV0IHNvbnMgPSB0b29scy5kZWVwQ2xvbmUodGhpc1NvbnMpOw0KICAgICAgICAgICAgICBsZXQgc2hvd0phZ2UgPSBmYWxzZTsNCiAgICAgICAgICAgICAgbGV0IGkgPSAwDQogICAgICAgICAgICAgIHdoaWxlICgoc29ucy5sZW5ndGggPiAwKSkgew0KICAgICAgICAgICAgICAgIGxldCBzID0gc29uc1swXTsNCiAgICAgICAgICAgICAgICBzb25zLnNwbGljZSgwLCAxKTsNCiAgICAgICAgICAgICAgICBsZXQgY3Vyc29uID0gX3RoaXMuc2hvd0VudGl0eUxpc3QuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzICsgJycgfSkNCiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7DQogICAgICAgICAgICAgICAgICBpKys7DQogICAgICAgICAgICAgICAgICBzaG93SmFnZSA9ICFjdXJzb25bJ3Nob3cnXQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAvLyBbJ3Nob3cnXSA9ICFfdGhpcy5zaG93RW50aXR5TGlzdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRoaXNTb25zW3NdIH0pWydzaG93J10NCiAgICAgICAgICAgICAgICBjdXJzb25bJ3Nob3cnXSA9IHNob3dKYWdlOw0KICAgICAgICAgICAgICAgIGxldCBjdXJnc29uID0gY3Vyc29uWydzb24nXTsNCiAgICAgICAgICAgICAgICBpZiAoIXNob3dKYWdlKSB7DQogICAgICAgICAgICAgICAgICBmb3IgKGxldCBncyA9IDA7IGdzIDwgY3VyZ3Nvbi5sZW5ndGg7IGdzKyspIHsNCiAgICAgICAgICAgICAgICAgICAgc29ucy5wdXNoKGN1cmdzb25bZ3NdKTsNCiAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgX3RoaXMudXBkYXRhR3JhcGgoKQ0KICAgICAgICB9KTsNCiAgICAgIC8vIC5vbigiIikNCiAgICB9LA0KICAgIGRyYXdSZWN0KHN2ZywgeCwgeSwgdywgaCwgcngsIHJ5LCBmaWxsLCBvcGFjaXR5LCBzdHJva2UsIGlkID0gJ3JlY3QnLCBzdHJva2VXID0gMS41LCBjbGFzc04gPSAncmVjdCcpIHsNCiAgICAgIGQzLnNlbGVjdChgIyR7aWR9YCkucmVtb3ZlKCkNCiAgICAgIGxldCByZWN0ID0gc3ZnLmFwcGVuZCgicmVjdCIpDQogICAgICAgIC5hdHRyKCJpZCIsIGlkKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc04pDQogICAgICAgIC5hdHRyKCJ4IiwgeCkNCiAgICAgICAgLmF0dHIoInkiLCB5KQ0KICAgICAgICAuYXR0cigicngiLCByeCkNCiAgICAgICAgLmF0dHIoInJ5IiwgcnkpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3KSAvL+WImuaJjeiuvue9rueahOWdl+eahOWuveW6pg0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIGAke3N0cm9rZVd9cHhgKTsNCiAgICAgIHJldHVybiByZWN0Ow0KICAgIH0sDQogICAgZHJhd1R4dChzdmcsIHgsIHksIHdpZHRoLCB0eHRzLCBmaWxsLCBmb250c2l6ZSA9IDEyLCBpZE4sIGNsYXNzTiA9ICJ0ZXh0Iikgew0KICAgICAgbGV0IHR4ID0geDsNCiAgICAgIGxldCB0eSA9IHk7DQogICAgICBsZXQgcHJlV2lkdGggPSAwOw0KICAgICAgbGV0IHByZUlkTiA9IDA7DQogICAgICBsZXQgcHJldGV4dCA9ICcnDQogICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHR4dHMubGVuZ3RoOyB0KyspIHsNCiAgICAgICAgcHJldGV4dCArPSAiICIgKyB0eHRzW3RdOw0KICAgICAgICBsZXQgdHh0ID0gc3ZnLmFwcGVuZCgidGV4dCIpDQogICAgICAgICAgLmF0dHIoInkiLCB0eSkNCiAgICAgICAgICAuYXR0cigieCIsIHR4KQ0KICAgICAgICAgIC5hdHRyKCJpZCIsIGAke2lkTn1fJHt0fWApDQogICAgICAgICAgLmF0dHIoImNsYXNzIiwgYCR7Y2xhc3NOfWApDQogICAgICAgICAgLmF0dHIoImZpbGwiLCBmaWxsKQ0KICAgICAgICAgIC5hdHRyKCJmb250LXNpemUiLCBmb250c2l6ZSkNCiAgICAgICAgICAuc3R5bGUoInRleHQtYW5jaG9yIiwgIm1pZGRsZSIpDQogICAgICAgICAgLnRleHQocHJldGV4dCkNCiAgICAgICAgbGV0IHRleHRXaWR0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke2lkTn1fJHt0fWApLmdldEJCb3goKS53aWR0aDsNCiAgICAgICAgaWYgKCh0ZXh0V2lkdGggPiB3aWR0aCkgfHwgKHQgPT0gdHh0cy5sZW5ndGggLSAxKSkgew0KICAgICAgICAgIHByZXRleHQgPSAnJzsNCiAgICAgICAgICB0eCA9IHg7DQogICAgICAgICAgdHkgKz0gMjU7DQogICAgICAgIH0NCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgdHh0LnJlbW92ZSgpDQogICAgICAgIH0NCiAgICAgICAgcHJlV2lkdGggKz0gdGV4dFdpZHRoOw0KICAgICAgfQ0KICAgIH0sDQogICAgZHJhd1RpbWVMaW5lKHN2ZywgcGF0aCwgc3Ryb2tlLCB3aWR0aCwgc3Ryb2tlX2Rhc2hhcnJheSA9ICIwIiwgaWROYW1lLCBjbGFzc05hbWUpIHsNCiAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKQ0KICAgICAgICAuYXR0cignZCcsIHBhdGgudG9TdHJpbmcoKSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgY2xhc3NOYW1lKQ0KICAgICAgICAuYXR0cignaWQnLCBpZE5hbWUpDQogICAgICAgIC5hdHRyKCJzdHJva2UtZGFzaGFycmF5Iiwgc3Ryb2tlX2Rhc2hhcnJheSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cignZmlsbCcsICdub25lJykNCiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCB0aGlzU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMpDQogICAgICAgICAgbGV0IGNsYXNzTiA9IHRoaXNTZWxlY3QuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBsZXQgaWROID0gdGhpc1NlbGVjdC5hdHRyKCJpZCIpOw0KICAgICAgICAgIGlmIChjbGFzc04uc3BsaXQoIiAiKVswXSA9PSAiYmFzaWNSZWwiKSB7DQogICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiY2xhc3MiLCBjbGFzc04gKyAiIGFjdGl2ZVMiKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgbGV0IHRoaXNTZWxlY3QgPSBkMy5zZWxlY3QodGhpcykNCiAgICAgICAgICBsZXQgY2xhc3NOID0gdGhpc1NlbGVjdC5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBjbGFzc05MaXN0ID0gY2xhc3NOLnNwbGl0KCIgIikNCiAgICAgICAgICBpZiAoY2xhc3NOTGlzdFtjbGFzc05MaXN0Lmxlbmd0aCAtIDFdID09ICJhY3RpdmVTIikgew0KICAgICAgICAgICAgY2xhc3NOID0gIiI7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTkxpc3QubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgIGNsYXNzTiArPSBjbGFzc05MaXN0W2ldICsgIiAiOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIiwgY2xhc3NOKTsNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgfSwNCiAgICB0cmFuc2Zvcm1HcmFwaFN2ZyhmbGFnKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZ3JvdXBzID0gX3RoaXMuZ3JvdXBzU3ZnOw0KDQogICAgICBsZXQgc2NhbGVQcmUgPSBfdGhpcy5ncmFwaFN2Z1NjYWxlOw0KDQogICAgICBsZXQgbWFyZ2luID0gX3RoaXMubWFyZ2luOw0KICAgICAgaWYgKGZsYWcgPT0gJ2xlZnQnKSB7DQogICAgICAgIF90aGlzLmdyYXBoR1RyYW5zZm9ybVggKz0gMTA7DQogICAgICB9DQogICAgICBpZiAoZmxhZyA9PSAncmlnaHQnKSB7DQogICAgICAgIF90aGlzLmdyYXBoR1RyYW5zZm9ybVggLT0gMTA7DQogICAgICB9DQogICAgICAvLyBncm91cHMuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKF90aGlzLmdyYXBoR1RyYW5zZm9ybVgpICsgJywnICsgKG1hcmdpbi50b3ApICsgJykgc2NhbGUoJyArIChzY2FsZVByZSkgKyAnKScpDQogICAgfSwNCiAgICB1cGRhdGFBc3Npc3RHcmFwaFBhbmVsKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdyb3Vwc1N2Zy5odG1sKCk7DQogICAgICBsZXQgaGVpZ2h0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImFzc2lzdEdyYXBoUGFuZWwiKS5jbGllbnRIZWlnaHQ7DQogICAgICBsZXQgd2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiYXNzaXN0R3JhcGhQYW5lbCIpLmNsaWVudFdpZHRoOw0KICAgICAgZDMuc2VsZWN0KCcjYXNzaXN0R3JhcGhQYW5lbCcpLnNlbGVjdCgnc3ZnJykucmVtb3ZlKCk7DQogICAgICBsZXQgdHJhbnNYID0gX3RoaXMuYXNzaXN0R1RyYW5zZm9ybVg7DQogICAgICBsZXQgdHJhbnNZID0gX3RoaXMuYXNzaXN0R1RyYW5zZm9ybVk7DQogICAgICB2YXIgZGl2ID0gZDMuc2VsZWN0KCcjYXNzaXN0R3JhcGhQYW5lbCcpDQogICAgICAgIC5hcHBlbmQoJ3N2ZycpDQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIHdpZHRoKQ0KICAgICAgICAuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KQ0KICAgICAgICAuYXBwZW5kKCJnIikNCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIGB0cmFuc2xhdGUoJHt0cmFuc1h9LCR7dHJhbnNZfSlgKQ0KICAgICAgICAuaHRtbChjb250ZW50KTsNCiAgICB9LA0KICAgIG1vdmVHcmFwaExlZnQoZSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgX3RoaXMubW92ZUZsYWcgPT0gdHJ1ZTsNCiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlVGltZXIpLy8g5riF6Zmk5a6a5pe25ZmoDQogICAgICB0aGlzLm1vdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgX3RoaXMudHJhbnNmb3JtR3JhcGhTdmcoImxlZnQiKSB9LCAxMCkvL190aGlzLnRyYW5zZm9ybUdyYXBoU3ZnKCdsZWZ0JyksIDEwMCk7DQogICAgfSwNCiAgICBtb3ZlR3JhcGhSaWdodChlKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICAvLyBjb25zb2xlLmxvZygi4pqh8J+QsvCfq6finYTvuI/wn5GB77iPIixlKQ0KICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vdmVUaW1lcikvLyDmuIXpmaTlrprml7blmagNCiAgICAgIF90aGlzLm1vdmVGbGFnID09IHRydWU7DQogICAgICB0aGlzLm1vdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgX3RoaXMudHJhbnNmb3JtR3JhcGhTdmcoInJpZ2h0IikgfSwgMTApLy9fdGhpcy50cmFuc2Zvcm1HcmFwaFN2ZygnbGVmdCcpLCAxMDApOw0KICAgIH0sDQogICAgbGVhdmVHcmFwaE1vdmUoKSB7DQogICAgICAvLyB0aGlzLm1vdmVGbGFnID09IGZhbHNlOw0KICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vdmVUaW1lcikvLyDmuIXpmaTlrprml7blmagNCiAgICAgIC8vIHRoaXMuZ3JhcGhHVHJhbnNmb3JtWCA9IDA7DQogICAgfSwNCiAgICB1cGRhdGFHcmFwaCgpIHsNCiAgICAgIHZhciBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgbWFyZ2luID0gX3RoaXMubWFyZ2luDQogICAgICBsZXQgd2lkdGggPSBfdGhpcy4kcmVmcy5ncmFwaERpdi5vZmZzZXRXaWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0Ow0KICAgICAgbGV0IGhlaWdodCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJncmFwaFBhbmVsIikuY2xpZW50SGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207DQogICAgICBsZXQgaGVpZ2h0VGltZUF4aXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ3JhcGhUaW1lQXhpc1BhbmVsIikuY2xpZW50SGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207DQogICAgICBfdGhpcy53aWR0aCA9IHdpZHRoOw0KICAgICAgX3RoaXMuaGVpZ2h0ID0gaGVpZ2h0Ow0KICAgICAgZDMuc2VsZWN0KCIjZ3JhcGhQYW5lbCIpLnNlbGVjdCgic3ZnIikucmVtb3ZlKCkNCiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiNncmFwaFBhbmVsIikuYXBwZW5kKCJzdmciKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBfdGhpcy5yb290U3ZnID0gc3ZnOw0KICAgICAgZDMuc2VsZWN0KCIjZ3JhcGhUaW1lQXhpc1BhbmVsIikuc2VsZWN0KCJzdmciKS5yZW1vdmUoKQ0KICAgICAgdmFyIFRpbWVBeGlzU3ZnID0gZDMuc2VsZWN0KCIjZ3JhcGhUaW1lQXhpc1BhbmVsIikuYXBwZW5kKCJzdmciKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQogICAgICBfdGhpcy5UaW1lQXhpc1N2ZyA9IFRpbWVBeGlzU3ZnOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KDQogICAgICBsZXQgbWF4REltcG9ydGFuY2UgPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXTsgfSkpDQogICAgICBsZXQgbWluREltcG9ydGFuY2UgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnYXR0cmlidXRlJ11bJ2ltcG9ydGFuY2UnXTsgfSkpDQogICAgICBsZXQgbWF4RFJlbGV2YW5jZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydhdHRyaWJ1dGUnXVsncmVsZXZhbmNlJ107IH0pKQ0KICAgICAgbGV0IG1pbkRSZWxldmFuY2UgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnYXR0cmlidXRlJ11bJ3JlbGV2YW5jZSddOyB9KSkNCiAgICAgIGxldCBtYXhERHVyYXRpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gdG9vbHMudGltZTJzZWNvbmRzKGRbJ3RpbWUnXVsxXSkgLSB0b29scy50aW1lMnNlY29uZHMoZFsndGltZSddWzBdKTsgfSkpDQogICAgICBsZXQgbWF4VG90YWxEdXJhdGlvbiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWyd0b3RhbER1cmF0aW9uJ107IH0pKQ0KICAgICAgX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uID0gW107DQogICAgICBfdGhpcy5taW5ESW1wb3J0YW5jZSA9IG1pbkRJbXBvcnRhbmNlOw0KICAgICAgX3RoaXMubWF4REltcG9ydGFuY2UgPSBtYXhESW1wb3J0YW5jZTsNCiAgICAgIF90aGlzLm1pbkRSZWxldmFuY2UgPSBtaW5EUmVsZXZhbmNlOw0KICAgICAgX3RoaXMubWF4RFJlbGV2YW5jZSA9IG1heERSZWxldmFuY2U7DQogICAgICBfdGhpcy5tYXhERHVyYXRpb24gPSBtYXhERHVyYXRpb247DQogICAgICBfdGhpcy5tYXhUb3RhbER1cmF0aW9uID0gbWF4VG90YWxEdXJhdGlvbjsNCg0KICAgICAgbGV0IGN1cnJlbnRNYXhDb2xvciA9IF90aGlzLmltcG9ydGFuY2VNYXhDb2xvcjsNCiAgICAgIGxldCBjdXJyZW50TWluQ29sb3IgPSBfdGhpcy5pbXBvcnRhbmNlTWluQ29sb3I7DQogICAgICBfdGhpcy5pbXBvcnRhbmNlQ29sb3JfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW21pbkRJbXBvcnRhbmNlLCBtYXhESW1wb3J0YW5jZV0pLnJhbmdlKFswLCAxXSk7DQogICAgICBfdGhpcy5pbXBvcnRhbmNlQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKGN1cnJlbnRNaW5Db2xvciwgY3VycmVudE1heENvbG9yKTsNCiAgICAgIF90aGlzLnJlbGV2YW5jZVNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFttaW5EUmVsZXZhbmNlLCBtYXhEUmVsZXZhbmNlXSwgWzIwLCA1MF0pDQogICAgICBfdGhpcy50b3RhbER1cmF0aW9uU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIG1heFRvdGFsRHVyYXRpb25dKS5yYW5nZShbMjAsIDYwXSk7DQoNCiAgICAgIF90aGlzLmRyYXdNYWluKHN2Zyk7DQogICAgICAvLyB9KTsNCiAgICB9LA0KICAgIHpvb21JbkxheW91dENsaygpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLmxheW91dFNob3cgKz0gMTsNCiAgICAgIGlmIChfdGhpcy5sYXlvdXRTaG93ID4gMykgew0KICAgICAgICBfdGhpcy5sYXlvdXRTaG93ID0gMzsNCiAgICAgIH0NCiAgICAgIC8vIF90aGlzLnVwZGF0YUdyYXBoKCk7DQogICAgfSwNCiAgICByZWNvZ25pemUwOmFzeW5jKCk9PnsNCiAgICAgIC8vIGxldCB3b3JrZXIgPSBfdGhpcy53b3JrZXI7DQogICAgICBjb25zb2xlLmxvZyh3b3JrZXIpDQogICAgICBhd2FpdCB3b3JrZXIubG9hZExhbmd1YWdlKCdlbmdfc2ltJyk7DQogICAgICBhd2FpdCB3b3JrZXIuaW5pdGlhbGl6ZSgnZW5nX3NpbScsIE9FTS5MU1RNX09OTFkpOw0KICAgICAgYXdhaXQgd29ya2VyLnNldFBhcmFtZXRlcnMoew0KICAgICAgICB0ZXNzZWRpdF9wYWdlc2VnX21vZGU6IFBTTS5TSU5HTEVfQkxPQ0ssDQogICAgICB9KTsNCg0KICAgIH0sDQogICAgem9vbU91dExheW91dENsaygpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLmxheW91dFNob3cgLT0gMTsNCiAgICAgIGlmIChfdGhpcy5sYXlvdXRTaG93IDwgMCkgew0KICAgICAgICBfdGhpcy5sYXlvdXRTaG93ID0gMDsNCiAgICAgIH0NCiAgICAgIC8vIF90aGlzLnVwZGF0YUdyYXBoKCk7DQoNCiAgICB9LA0KICAgIGNsaWNrX0VudCh0aW1lKSB7DQogICAgICB0aGlzLiRlbWl0KCJ0aW1lRHVyIiwgdGltZSk7DQogICAgfSwNCiAgfSwNCiAgY3JlYXRlZCgpIHsNCiAgICB2YXIgX3RoaXMgPSB0aGlzOw0KICAgIGxldCBtYXJnaW4gPSBfdGhpcy5tYXJnaW4NCiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7DQogICAgICAvLyBfdGhpcy5zY2hlZHVsZXIgPSBjcmVhdGVTY2hlZHVsZXIoKTsNCiAgICAgIC8vICBzY2hlZHVsZXIuYWRkV29ya2VyKF90aGlzLndvcmtlcik7DQogICAgICBfdGhpcy51cGRhdGFHcmFwaCgpOw0KICAgICAgX3RoaXMudXBkYXRhQXNzaXN0R3JhcGhQYW5lbCgpOw0KICAgIH0pOw0KICB9LA0KICBtb3VudGVkKCkgew0KICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICBsZXQgd2lkdGggPSBfdGhpcy4kcmVmcy5ncmFwaERpdi5vZmZzZXRXaWR0aDsNCiAgICBsZXQgaGVpZ2h0ID0gX3RoaXMuaGVpZ2h0Ow0KICAgIGxldCBzaG93RW50aXR5TGlzdCA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5kYXRhKTsNCiAgICBmb3IgKGxldCBlIGluIHNob3dFbnRpdHlMaXN0KSB7DQogICAgICBzaG93RW50aXR5TGlzdFtlXVsnc2hvdyddID0gdHJ1ZTsNCiAgICB9DQogICAgICAvLyB3b3JrZXIgDQogICAgX3RoaXMuc2hvd0VudGl0eUxpc3QgPSBzaG93RW50aXR5TGlzdDsNCiAgICAvLyBsZXQgd2lkdGggPSBfdGhpcy53aWR0aDsNCiAgICB0aGlzLiRidXMuJG9uKCdncmFwaERhdGEnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5kYXRhID0gdmFsOw0KICAgICAgbGV0IHNob3dFbnRpdHlMaXN0ID0gdG9vbHMuZGVlcENsb25lKF90aGlzLmRhdGEpOw0KICAgICAgZm9yIChsZXQgZSBpbiBzaG93RW50aXR5TGlzdCkgew0KICAgICAgICBzaG93RW50aXR5TGlzdFtlXVsnc2hvdyddID0gdHJ1ZTsNCiAgICAgIH0NCiAgICAgIF90aGlzLnNob3dFbnRpdHlMaXN0ID0gc2hvd0VudGl0eUxpc3Q7DQogICAgICBfdGhpcy51cGRhdGFHcmFwaCgpOw0KICAgIH0pOw0KICAgIHRoaXMuJGJ1cy4kb24oJ3N3aXRjaEwnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5zd2l0Y2hMID0gdmFsOw0KICAgIH0pOw0KDQogICAgLy8gdGhpcy4kcmVmcy5tb3ZlR3JhcGhMZWZ0LmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlb3ZlciIsIF90aGlzLm1vdmVHcmFwaExlZnQpOyAvLyDnm5HlkKzngrnlh7vkuovku7YNCiAgICAvLyB0aGlzLiRyZWZzLm1vdmVHcmFwaFJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbW92ZSIsIF90aGlzLm1vdmVHcmFwaFJpZ2h0KTsgLy8g55uR5ZCs54K55Ye75LqL5Lu2DQogICAgLy8gdGhpcy4kcmVmcy5tb3ZlR3JhcGhMZWZ0LmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLCBfdGhpcy5sZWF2ZUdyYXBoTW92ZSk7IC8vIOebkeWQrOeCueWHu+S6i+S7tg0KICAgIC8vIHRoaXMuJHJlZnMubW92ZUdyYXBoUmlnaHQuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VsZWF2ZSIsIF90aGlzLmxlYXZlR3JhcGhNb3ZlKTsgLy8g55uR5ZCs54K55Ye75LqL5Lu2DQoNCiAgfSwNCiAgYmVmb3JlRGVzdHJveSgpIHsNCiAgICBjbGVhckludGVydmFsKHRoaXMubW92ZVRpbWVyKTsNCiAgfSwNCn0gDQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/Graph","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"graph\" ref=\"graphDiv\">\r\n    <!-- <div class=\"panelHead\">ConceptMap</div> -->\r\n    <div id=\"graphTimeAxisPanel\" class=\"\">\r\n    </div>\r\n    <div id=\"graphPanel\" class=\"panelBody\">\r\n    </div>\r\n    <!-- <div id=\"moveLeft\" ref=\"moveGraphLeft\"></div>\r\n                    <div id=\"moveRight\" ref=\"moveGraphRight\"></div> -->\r\n    <div id=\"assistGraphPanel\" class=\"panel\">\r\n      <div class=\"panelHead\"></div>\r\n    </div>\r\n\r\n    <div v-show=\"editDivShow\" ref=\"editDiv\" id=\"editDiv\" class=\"panel\">\r\n      <div id=\"editAdd\" @click=\"addNode\">\r\n        <img class=\"editIcons\" :src=\"editAddUrl\" @click=\"addNode\">\r\n        Add\r\n      </div>\r\n      <div id=\"editAddN\" @click=\"addNodeN\">\r\n        <img class=\"editIcons\" :src=\"editAddNUrl\" @click=\"addNodeN\">\r\n        Add in next level\r\n      </div>\r\n      <div id=\"editDel\" @click=\"delNode\">\r\n        <img class=\"editIcons editDelIcons\" :src=\"editDelUrl\" @click=\"delNode\">\r\n        Delete\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"zoomInDiv\" @click=\"zoomInLayoutClk\">\r\n    </div>\r\n    <div id=\"zoomOutDiv\" @click=\"zoomOutLayoutClk\">\r\n      <img class=\"icons\" :src=\"zoomOutUrl\">\r\n    </div>\r\n    <div id=\"editToolDiv\" @click=\"editToolClk\">\r\n      <img class=\"icons\" :src=\"editToolUrl\">\r\n    </div>\r\n    <div id=\"VideoEditPanel\" ref=\"VideoEditPanel\" class=\"\" v-show=\"VideoEditPanelShow\">\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport filenames from \"@/utils/fileName\";\r\nimport domtoimage from 'dom-to-image';\r\nimport TestJson from \"@/assets/json/case1_fin.json\";\r\nimport TestRelJson from \"@/assets/json/case1_fin_rel.json\";\r\nimport tools from \"@/utils/tools.js\";\r\n \r\nlet worker = tools.createWorkers();\r\nexport default {\r\n  props: [\"videoTime\"],\r\n  data() {\r\n    return {\r\n      worker:null,\r\n      data: TestJson,\r\n      gData: \"TestJson\",\r\n      relData: TestRelJson,\r\n      assistGTransformX: 10,\r\n      assistGTransformY: 100,\r\n      drawEntityLocation: [],\r\n      VideoEditPanelShow:false,\r\n      showEntityList: [],\r\n      switchL: [],\r\n      overEntityId: '',\r\n      overTargetEntityId: '',\r\n      showEntityRelIdList: [],\r\n      showEntityRelIdOverState: '',\r\n      rootEntityList: [],\r\n      rootSvg: null,\r\n      TimeAxisSvg: null,\r\n      groupsSvg: null,\r\n      arcG: null,\r\n      curEntId: '',\r\n      insertEntId: '',\r\n      editDivShow: false,\r\n      minDImportance: 0,\r\n      maxDImportance: 0,\r\n      minDRelevance: 0,\r\n      maxDRelevance: 0,\r\n      maxDDuration: 0,\r\n      timeAxisX: 0,\r\n      timeAxisW: 200,\r\n      timeAxisDropFlag: 0,\r\n      timeAxisDownX: 0,\r\n      timeAxisDownW: 60,\r\n      maxTotalDuration: 0,\r\n      videoDuration: 672,\r\n      totalDuration: 1000,\r\n      importanceColor_linear: null,\r\n      importanceCompute_color: null,\r\n      relevanceScale_linear: null,\r\n      totalDurationScale_linear: null,\r\n      sumTotalDuration: 0,\r\n      // importanceMinColor: \"rgb(1, 164, 183)\",\r\n      // importanceMaxColor: \"rgb(106, 52, 127)\",\r\n      zoomInUrl: require(\"@/assets/img/zoomIn.png\"),\r\n      zoomOutUrl: require(\"@/assets/img/zoomOut.png\"),\r\n      editToolUrl: require(\"@/assets/img/edit.png\"),\r\n      editAddUrl: require(\"@/assets/img/edit_Add.png\"),\r\n      editAddNUrl: require(\"@/assets/img/edit_AddN.png\"),\r\n      editDelUrl: require(\"@/assets/img/edit_Delete.png\"),\r\n      layoutShow: 2,\r\n      graphGTransformK: 1,\r\n      graphGTransformX: 10,\r\n      graphGTransformY: 100,\r\n      graphGMoveX: 10,\r\n      graphSvgScale: 1,\r\n      moveTimer: null,\r\n      moveFlag: false,\r\n      importanceMinColor: \"rgb(203, 230, 209)\",\r\n      importanceMaxColor: \"rgb(22, 144, 207)\",\r\n      stepX: 150,\r\n      stepY: 100,\r\n      btnRel: false,\r\n      btnSim: false,\r\n      btnAso: false,\r\n      btnEdi: false,\r\n      circleInterval: 55,\r\n      width: 0,\r\n      height: 0,\r\n      curToolState: 'unEdit',\r\n      margin: { top: 80, right: 20, bottom: 0, left: 20 },\r\n      color: [\r\n        \"rgb(255,60,60)\",\r\n        \"rgb(0, 178, 171)\",\r\n        // \"rgb(255,83,255)\",\r\n        \"rgb(235,135,162)\",\r\n        \"rgb(255,178,101)\",\r\n        \"rgb(63,151,134)\",\r\n        \"rgb(83,255,255)\",\r\n        \"rgb(0,122,244)\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n      mcolor: [\r\n        \"rgb(125, 66, 206)\",\r\n        \"rgb(248, 134, 124)\",\r\n        \"rgb(50, 198, 191)\",\r\n        \"rgb(135, 126, 253)\",\r\n        \"rgb(198, 121, 123)\",\r\n        \"rgb(252, 177, 49)\",\r\n        \"rgb(112, 202, 229)\",\r\n      ],\r\n      // mcolor: [\r\n      //   \"rgb(91, 107, 255)\",\r\n      //   \"rgb(0, 178, 171)\",\r\n      //   // \"rgb(6, 214, 160)\",\r\n      //   \"rgb(255, 120, 90)\",\r\n      //   \"rgb(125, 98, 211)\",\r\n      //   \"rgb(255, 113, 212)\",\r\n      //   \"rgb(112, 214, 255)\",\r\n      //   \"rgb(255, 159, 28)\",\r\n      //   \"rgb(255, 77, 109)\",\r\n      // ],\r\n      mDarkcolor: [\r\n        \"rgb(95, 39, 179)\",\r\n        \"rgb(221, 83, 72)\",\r\n        \"rgb(0, 158, 148)\",\r\n        \"rgb(93, 88, 202)\",\r\n        \"rgb(180, 72, 79)\",\r\n        \"rgb(202, 134, 32)\",\r\n        \"rgb(46, 174, 202)\",\r\n      ],\r\n      mLigntcolor: [\r\n        \"#ff9c9c\",\r\n        \"#cc88b0\",\r\n        \"#ffa8ff\",\r\n        \"#e3b097\",\r\n        \"#f4c3d0\",\r\n        \"#f4f4d0\",\r\n        \"#ffd8b1\",\r\n        \"#9ecac2\",\r\n        \"#a8ccff\",\r\n        \"#97e3ba\",\r\n        \"#6f8be0\",\r\n        \"rgb(0,122,244)\",\r\n        \"#b6a2f7\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n      editVideoJage:false,\r\n      editVideoSP:[],\r\n      editVideoEP:[],\r\n    };\r\n  },\r\n\r\n  watch: {\r\n    type(val) {\r\n    },\r\n    switchL: {\r\n      deep: true,\r\n      handler(val) {\r\n        this.btnRel = val[0];\r\n        this.btnSim = val[1];\r\n        this.btnAso = val[2];\r\n        this.btnEdi = val[3];\r\n        this.updataRel()\r\n      }\r\n    },\r\n    timeAxisX(val) {\r\n      const _this = this;\r\n      _this.updataTimeAxisDur(_this.TimeAxisSvg, _this.timeAxisX, _this.timeAxisW);\r\n    },\r\n    curEntId(val) {\r\n      const _this = this;\r\n      _this.overEntityId = val;\r\n      _this.$bus.$emit(\"selectEnt\", val);\r\n      let entityLocationData = _this.drawEntityLocation;\r\n\r\n      let relData = _this.relData;\r\n      let showJageData = _this.showEntityList;\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n        let sorceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n          let trnId = '-1';\r\n          if (sorceId == parseInt(val)) {\r\n            trnId = targetId;\r\n          }\r\n          else if (targetId == parseInt(val)) {\r\n            trnId = sorceId;\r\n          }\r\n          if (trnId != '-1') {\r\n            let curEnt = entityLocationData.find(function (d) { return parseInt(d['id']) == trnId });\r\n            _this.assistGTransformX = parseInt(-curEnt['x']) + parseFloat(curEnt['r']) + 150;\r\n            _this.assistGTransformY = parseInt(-curEnt['y']) + parseFloat(curEnt['r']) + 300;\r\n            _this.updataAssistGraphPanel();\r\n          }\r\n        }\r\n\r\n      };\r\n      let similarityRel = relData['similarityRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n        let sorceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n          let trnId = '-1';\r\n          if (sorceId == parseInt(val)) {\r\n            trnId = targetId;\r\n          }\r\n          else if (targetId == parseInt(val)) {\r\n            trnId = sorceId;\r\n          }\r\n          if (trnId != '-1') {\r\n            let curEnt = entityLocationData.find(function (d) { return parseInt(d['id']) == trnId });\r\n            _this.assistGTransformX = parseInt(-curEnt['x']) + parseFloat(curEnt['r']) + 150;\r\n            _this.assistGTransformY = parseInt(-curEnt['y']) + parseFloat(curEnt['r']) + 300;\r\n            _this.updataAssistGraphPanel();\r\n          }\r\n        }\r\n\r\n      };\r\n\r\n\r\n    },\r\n    overEntityId(val) {\r\n      const _this = this;\r\n\r\n      _this.$bus.$emit(\"overEntityId\", val);\r\n      let relList = [];\r\n      let relRootList = [];\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let basicRel = relData['basicRel'];\r\n      d3.selectAll('.timeText').attr(\"opacity\", 0)\r\n      d3.selectAll('.timeAxisEnt').attr(\"stroke-width\", 0).attr(\"opacity\", 0.4).attr(\"stroke\", function () {\r\n        let cid = d3.select(this).attr(\"id\").split(\"_\")[1];\r\n        let nd = oData.find(function (d) { return d['id'] == cid });\r\n        return nd['colorD']\r\n      });\r\n      for (let re = 0; re < basicRel.length; re++) {\r\n\r\n        let sorceId = basicRel[re][0];\r\n        let targetId = basicRel[re][1];\r\n        let cNode = '';\r\n        if (sorceId == val) {\r\n          cNode = oData.find(function (d) { return d['id'] == targetId });\r\n          relList.push(targetId);\r\n          relRootList.push(cNode['rootIndex']);\r\n        }\r\n\r\n        if (targetId == val) {\r\n          cNode = oData.find(function (d) { return d['id'] == sorceId });\r\n          relList.push(sorceId);\r\n          relRootList.push(cNode['rootIndex']);\r\n        }\r\n      };\r\n      relList.forEach((self, indx, arr) => {\r\n\r\n        d3.select(`#timeAxisEnt_${self}`).attr(\"stroke\", 'white').attr(\"stroke-width\", 2).attr(\"opacity\", 1);\r\n        d3.select(`#timeText_${self}_0`).attr(\"opacity\", 1);\r\n      })\r\n      d3.select(`#timeAxisEnt_${val}`).attr(\"stroke-width\", 2).attr(\"opacity\", 1);\r\n      d3.select(`#timeText_${val}_0`).attr(\"opacity\", 1);\r\n    },\r\n    showEntityRelIdList(val) {\r\n      this.updataRel();\r\n    },\r\n    groupsSvg: {\r\n      deep: true,\r\n      handler() {\r\n        this.updataAssistGraphPanel();\r\n      }\r\n    },\r\n    gData(val) {\r\n    },\r\n    layoutShow(val) {\r\n      const _this = this;\r\n      let showEntityList = tools.deepClone(_this.data);\r\n      for (let e in showEntityList) {\r\n        if (parseInt(showEntityList[e]['layout']) < parseInt(val))\r\n          showEntityList[e]['show'] = true;\r\n        else {\r\n          showEntityList[e]['show'] = false;\r\n        }\r\n      }\r\n      _this.showEntityList = showEntityList;\r\n      _this.updataGraph();\r\n    },\r\n    data(val) {\r\n    },\r\n    videoTime(val) {\r\n      const _this = this;\r\n      let entityLocationData = _this.drawEntityLocation;\r\n      for (let e = 0; e < entityLocationData.length; e++) {\r\n        let curD = entityLocationData[e];\r\n        let timeStart = tools.time2seconds(entityLocationData[e]['time'][0]);\r\n        let timeEnd = tools.time2seconds(entityLocationData[e]['time'][1]);\r\n        if ((val > timeStart) && (val < timeEnd)) {\r\n          let entX = entityLocationData[e]['x'];\r\n          let entY = entityLocationData[e]['y'];\r\n          let entR = entityLocationData[e]['r'];\r\n          let moveLinear = d3.scaleLinear([timeStart, timeEnd], [entX - entR, entX + entR])\r\n          _this.graphGTransformX = -moveLinear((val));\r\n        }\r\n      }\r\n    },\r\n    graphGMoveX(val) {\r\n      const _this = this;\r\n      let data = _this.drawEntityLocation;\r\n      let stjg = 0;\r\n      let enjg = 0;\r\n      let snode = '';\r\n      let enode = '';\r\n      let width = 1590\r\n      data.forEach((self, indx, arr) => {\r\n        let entx = self['x'] * _this.graphGTransformK;\r\n        let transformX = entx + val;\r\n        if ((transformX > 0) && (transformX < width)) {\r\n          stjg++;\r\n        }\r\n        else {\r\n          if ((stjg > 0) && enjg == 0) {\r\n            enode = self;\r\n            enjg = 1\r\n          }\r\n        }\r\n        if (stjg == 1) {\r\n          snode = self\r\n        }\r\n      })\r\n      let ew = enode['timeW'];\r\n      if (snode == '') {\r\n        _this.timeAxisX = 0\r\n      }\r\n      else\r\n        _this.timeAxisX = snode['timeX'];\r\n      _this.timeAxisW = enode['timeX'] - snode['timeX'] + enode['timeW']\r\n      if (ew == undefined) {\r\n        _this.timeAxisW = width - snode['timeX']\r\n      }\r\n    },\r\n    graphGTransformX(val) {\r\n      const _this = this;\r\n      let groups = _this.groupsSvg;\r\n      _this.graphGMoveX = _this.graphGTransformX;\r\n      let graphGTransformX = _this.graphGTransformX;\r\n      let graphGTransformY = _this.graphGTransformY;\r\n      let graphGTransformK = _this.graphGTransformK;\r\n      groups.attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n    }\r\n  },\r\n  methods: {\r\n    addNode() {\r\n      const _this = this;\r\n      _this.VideoEditPanelShow = true,\r\n      _this.editDivShow = false;\r\n      d3.select(\"#VideoEditPanel\").select(\"svg\").remove()\r\n      var svg = d3.select(\"#VideoEditPanel\").append(\"svg\")\r\n        .attr(\"width\", \"946\")\r\n        .attr(\"height\", \"553\");\r\n      svg.on(\"mousedown\",function(d){\r\n        _this.editVideoSP = [d.layerX,d.layerY];\r\n        _this.editVideoJage = true;\r\n      }).on(\"mousemove\",function(d){\r\n        if(_this.editVideoJage){\r\n        let sP = _this.editVideoSP;\r\n        _this.editVideoEP = [d.layerX,d.layerY];\r\n        let eP =  [d.layerX,d.layerY];\r\n        let eX  = sP[0]>eP[0]?sP[0]:eP[0];\r\n        let eY  = sP[1]>eP[1]?sP[1]:eP[1];\r\n        let sX  = sP[0]<eP[0]?sP[0]:eP[0];\r\n        let sY  = sP[1]<eP[1]?sP[1]:eP[1];\r\n        _this.drawRect(svg,sX , sY, Math.abs(eX-sX), Math.abs(eY - sY), 0,0,\"rgba(0,0,0,0)\",1, \"red\", `videoRect`)}\r\n      }).on(\"mouseup\",function(d){\r\n        _this.editVideoJage = false;\r\n        \r\n        let sP = _this.editVideoSP;\r\n        let eP = _this.editVideoEP;\r\n\r\n        let eX  = sP[0]>eP[0]?sP[0]:eP[0];\r\n        let eY  = sP[1]>eP[1]?sP[1]:eP[1];\r\n        let sX  = sP[0]<eP[0]?sP[0]:eP[0];\r\n        let sY  = sP[1]<eP[1]?sP[1]:eP[1];\r\n        \r\n        var player = document.getElementById(\"playVideo\");   //videoDom\r\n        player.setAttribute(\"crossOrigin\", \"anonymous\");  //srossOrigin\r\n        var canvas = document.createElement(\"canvas\");\r\n        \r\n        canvas.width = player.clientWidth;\r\n        canvas.height = player.clientHeight;\r\n        // canvas = canvas.getContext(\"2d\")\r\n        canvas.getContext(\"2d\").drawImage(player , 0, 0, canvas.width, canvas.height);//\r\n        const data = canvas.getContext(\"2d\").getImageData(sX , sY, Math.abs(eX-sX), Math.abs(eY - sY));\r\n        var canvass = document.createElement(\"canvas\");\r\n        canvass.getContext(\"2d\").putImageData(data, 0,0)\r\n        var dataURL = canvass.toDataURL(\"image/png\");  //base64\r\n        var img = document.createElement('img');\r\n        _this.recognize0();\r\n        // img.src = dataURL\r\n        // const res = _this.scheduler.addJob('recognize', canvass);\r\n        // const datas = _this.worker.recognize(data);\r\n        // console.log(res)\r\n        document.getElementById(\"VideoEditPanel\").appendChild(img);   //\r\n        // var string = ocrad(data);\r\n        // console.log(string)\r\n        // alert(string);\r\n      })\r\n    },\r\n    // VideoEditPanelShow(val) {\r\n    //   const _this = this;\r\n    //   if (val) {\r\n    //     let width = _this.$refs.VideoEditPanel.offsetWidth;\r\n    //     let height = document.getElementById(\"VideoEditPanel\").clientHeight;\r\n    //     d3.select(\"#VideoEditPanel\").select(\"svg\").remove()\r\n    //     var svg = d3.select(\"#VideoEditPanel\").append(\"svg\")\r\n    //       .attr(\"width\", width)\r\n    //       .attr(\"height\", height);\r\n    //   }\r\n    // },\r\n    addNodeN() {\r\n      const _this = this;\r\n      _this.editDivShow = false;\r\n\r\n    },\r\n    delNode() {\r\n      const _this = this;\r\n      _this.editDivShow = false;\r\n    },\r\n    editToolClk() {\r\n      const _this = this;\r\n      if (_this.curToolState == 'edit') _this.curToolState = 'unEdit';\r\n      else if (_this.curToolState != 'edit') _this.curToolState = 'edit';\r\n      this.$emit(\"toolState\", this.curToolState);\r\n    },\r\n    updataRel() {\r\n      const _this = this;\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let showJageData = _this.showEntityList;\r\n      let showRel = _this.showEntityRelIdList;\r\n      let basicRel = relData['basicRel'];\r\n\r\n      if (_this.btnRel) {\r\n        if (_this.btnSim) {\r\n          d3.selectAll('.similarityRel').attr('opacity', 1);\r\n        }\r\n        else if (!_this.btnSim) {\r\n          d3.selectAll('.similarityRel').attr('opacity', 0);\r\n        }\r\n        if (_this.btnAso) {\r\n          d3.selectAll('.basicRel').attr('opacity', 1);\r\n        }\r\n        else if (!_this.btnAso) {\r\n          d3.selectAll('.basicRel').attr('opacity', 0);\r\n        }\r\n        // d3.selectAll('.similarityRel').attr('opacity', 1);\r\n        // d3.selectAll('.basicRel').attr('opacity', 1);\r\n      }\r\n      else if (!_this.btnRel) {\r\n        d3.selectAll('.similarityRel').attr('opacity', 0);\r\n        d3.selectAll('.basicRel').attr('opacity', 0);\r\n      }\r\n      if (!_this.btnRel || !_this.btnAso) {\r\n        for (let r = 0; r < basicRel.length; r++) {\r\n          let sorceId = basicRel[r][0];\r\n          let targetId = basicRel[r][1];\r\n          let idN = \"basicRel\" + sorceId + \"_\" + targetId;\r\n          if (_this.overTargetEntityId == '') {\r\n            if ((showRel.includes(sorceId)) || (showRel.includes(targetId))) {\r\n              d3.select(`#${idN}`).attr('opacity', 1).attr('stroke', 'darkslateblue')\r\n            }\r\n            else {\r\n              d3.select(`#${idN}`).attr('opacity', 0)\r\n            }\r\n          }\r\n          else {\r\n\r\n            if ((showRel.includes(sorceId + '')) || (showRel.includes(targetId + ''))) {\r\n              d3.select(`#${idN}`).attr('opacity', 1).attr('stroke', 'grey')\r\n            }\r\n            else {\r\n              d3.select(`#${idN}`).attr('opacity', 0)\r\n            }\r\n            if ((showRel.includes(sorceId + '')) && (targetId == _this.overTargetEntityId)) {\r\n              d3.select(`#${idN}`).attr('opacity', 1).attr('stroke', 'darkslateblue')\r\n            }\r\n            else if ((showRel.includes(targetId + '')) && (sorceId == _this.overTargetEntityId)) {\r\n              d3.select(`#${idN}`).attr('opacity', 1).attr('stroke', 'darkslateblue')\r\n            }\r\n          }\r\n        };\r\n      }\r\n    },\r\n    drawRelationshipLine(svg) {\r\n      const _this = this;\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let showJageData = _this.showEntityList;\r\n      let margin = _this.margin;\r\n      let height = svg.attr('height');\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n\r\n        let sorceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        let idN = \"basicRel\" + sorceId + \"_\" + targetId;\r\n        let classN = \"basicRel source\" + sorceId + \" target\" + targetId;\r\n        let sorceNode = oData.find(function (d) { return d['id'] == sorceId });\r\n        let targetNode = oData.find(function (d) { return d['id'] == targetId });\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n          if (sorceNode['x'] > targetNode['x']) {\r\n            let tp = sorceNode;\r\n            sorceNode = targetNode;\r\n            targetNode = tp;\r\n          }\r\n          const path = d3.path();\r\n\r\n          let startX = sorceNode['x'];\r\n          let endX = targetNode['x'];\r\n          let midX = (startX + endX) / 2;\r\n          let flag = ((sorceNode['sonFlag']) || (targetNode['sonFlag']));\r\n          // if((targetNode['id'] == \"4\")||((sorceNode['id']==\"1\")&&(targetNode['id']==\"6\"))||((sorceNode['id']==\"2\")&&(targetNode['id']==\"7\"))||((sorceNode['id']==\"3\")&&(targetNode['id']==\"8\"))){\r\n          //   flag = true;\r\n          // }\r\n          if (targetNode['id'] == \"4\") {\r\n            flag = true;\r\n          }\r\n          // if(targetNode['id'] == \"30\"){\r\n          //   flag = true;\r\n          // }\r\n          let rsourceint = (sorceNode['sonFlag']) ? (20) : (2);\r\n          let rtargetint = (targetNode['sonFlag']) ? (20) : (2);\r\n          let startY = (flag) ? (sorceNode['y'] - sorceNode['r'] - rsourceint) : (sorceNode['y'] + sorceNode['r'] + rsourceint);\r\n          let endY = (flag) ? (targetNode['y'] - targetNode['r'] - rtargetint) : (targetNode['y'] + targetNode['r'] + rtargetint);\r\n\r\n          let cnx1 = startX - 50;\r\n          let cnx2 = endX + 50;\r\n          let midY = (startY + endY) / 2;\r\n          // if(((sorceNode['id']==\"1\")&&(targetNode['id']==\"6\"))||((sorceNode['id']==\"2\")&&(targetNode['id']==\"7\"))||((sorceNode['id']==\"3\")&&(targetNode['id']==\"8\"))){\r\n          //   midY-=140\r\n          // }\r\n          let h = (((endX - startX) / 5) > (parseInt(height) + 100)) ? (parseInt(height) + 100) : ((endX - startX) / 5);\r\n          let cny = (flag) ? (midY - h) : (midY + h);\r\n\r\n          let cny1 = cny;\r\n          let cny2 = cny;\r\n\r\n          if (((sorceNode['layout'] == 2) && (cny < 0)) || ((sorceNode['layout'] == 0) && (cny > 0))) {\r\n            cnx1 -= 250;\r\n            cny1 = cny * 1.3;\r\n          }\r\n          if (((targetNode['layout'] == 2) && (cny < 0)) || ((targetNode['layout'] == 0) && (cny > 0))) {\r\n            cnx2 += 250;\r\n            cny2 = cny * 1.3;\r\n          }\r\n          // let midP = [(startP[0]+endP[0])/2,(startP[1])>(endP[1])?(startP[1]-100):(endP[1]-100)];\r\n          path.moveTo(startX, startY);\r\n          path.bezierCurveTo(midX, cny, midX, cny, endX, endY);\r\n          _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"9,9\", idN, classN);\r\n        }\r\n\r\n      };\r\n      let similarityRel = relData['similarityRel'];\r\n      // let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n\r\n        let sorceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n\r\n        let idN = \"similarityRel\" + sorceId + \"_\" + targetId;\r\n\r\n        let classN = \"similarityRel source\" + sorceId + \" target\" + targetId;\r\n        let sorceNode = oData.find(function (d) { return d['id'] == sorceId });\r\n        let targetNode = oData.find(function (d) { return d['id'] == targetId });\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n\r\n          if (sorceNode['x'] > targetNode['x']) {\r\n            let tp = sorceNode;\r\n            sorceNode = targetNode;\r\n            targetNode = tp;\r\n          }\r\n          const path = d3.path();\r\n\r\n          let startX = sorceNode['x'] + sorceNode['r'] / 2;\r\n          let endX = targetNode['x'] - targetNode['r'] / 2;\r\n          let midX = (startX + endX) / 2;\r\n          let flag = ((sorceNode['sonFlag']) || (targetNode['sonFlag']));\r\n          let rsourceint = (sorceNode['sonFlag']) ? (20) : (2);\r\n          let rtargetint = (targetNode['sonFlag']) ? (20) : (2);\r\n          let startY = (flag) ? (sorceNode['y'] - sorceNode['r'] - rsourceint) : (sorceNode['y'] + sorceNode['r'] + rsourceint);\r\n          let endY = (flag) ? (targetNode['y'] - targetNode['r'] - rtargetint) : (targetNode['y'] + targetNode['r'] + rtargetint);\r\n\r\n          let midY = (startY + endY) / 2;\r\n\r\n          // let h1Scale_linear = d3.scaleLinear([0, _this.width], [(sorceNode['y']>targetNode['y'])?(sorceNode['y']*2):(targetNode['y']*2),parseInt(height)])\r\n          let h = (((endX - startX) / 14) > (parseInt(height) - 10)) ? (parseInt(height) - 10) : ((endX - startX) / 14);\r\n          let hScale_linear = d3.scaleLinear([0, _this.width / 2], [0, h / 3 * 2])\r\n          let cny = (flag) ? (midY - hScale_linear(endX)) : (midY + hScale_linear(endX));\r\n          if (sorceNode['id'] == '7') { cny -= 20 }\r\n          if (cny < -150) {\r\n            startY = sorceNode['y'] + sorceNode['r'] + rsourceint\r\n            endY = targetNode['y'] + targetNode['r'] + rtargetint\r\n            cny = height - cny - 300;\r\n          }\r\n\r\n          path.moveTo(startX, startY);\r\n          path.lineTo(startX, cny);\r\n          path.lineTo(endX, cny);\r\n          path.lineTo(endX, endY);\r\n          _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"0\", idN, classN);\r\n        }\r\n\r\n\r\n      };\r\n      _this.updataRel()\r\n    },\r\n    drawMain(svg) {\r\n      let _this = this;\r\n      let data = _this.data;\r\n      let margin = _this.margin;\r\n\r\n      let width = _this.width - margin.left - margin.right;\r\n      let height = _this.height - margin.top - margin.bottom;\r\n\r\n      let graphGTransformX = _this.graphGTransformX;\r\n      let graphGTransformY = _this.graphGTransformY;\r\n      let graphGTransformK = _this.graphGTransformK;\r\n      let axisGroups = svg.append(\"g\").attr(\"id\", \"axisGroups\").attr(\"width\", width).attr(\"height\", height)\r\n      // .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height)\r\n        .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      this.groupsSvg = groups;\r\n\r\n      let backG = groups.append(\"g\").attr(\"id\", \"backG\").attr(\"width\", width).attr(\"height\", height);\r\n      let arcG = groups.append(\"g\").attr(\"id\", \"arcG\").attr(\"width\", width).attr(\"height\", height);\r\n      let timeLineG = groups.append(\"g\").attr(\"id\", \"timeLineG\").attr(\"width\", width).attr(\"height\", height);\r\n      let circleG = groups.append(\"g\").attr(\"id\", \"circleG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      _this.arcG = arcG;\r\n      let stepX = _this.stepX;\r\n      let stepY = _this.stepY;\r\n      let interval = _this.circleInterval;\r\n\r\n\r\n      let scalePre = _this.graphSvgScale;\r\n      let stx = 0;\r\n      let sty = 0;\r\n      let stk = 1;\r\n      var graphZoom = d3.zoom()\r\n        .scaleExtent([0, 10])\r\n        .on(\"start\", (e) => {\r\n          sty = e.transform.y;\r\n          stx = e.transform.x;\r\n          stk = e.transform.k;\r\n        })\r\n        .on('zoom', (e) => {\r\n          graphGTransformX = _this.graphGTransformX + e.transform.x - stx;\r\n          graphGTransformY = _this.graphGTransformY + e.transform.y - sty;\r\n          graphGTransformK = _this.graphGTransformK + e.transform.k - stk;\r\n          _this.graphGMoveX = graphGTransformX;\r\n\r\n          groups.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        })\r\n        .on('end', (e) => {\r\n          _this.graphGTransformX = graphGTransformX;\r\n          _this.graphGTransformY = graphGTransformY;\r\n          _this.graphGTransformK = graphGTransformK;\r\n          groups.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        });\r\n\r\n\r\n      svg.call(graphZoom)\r\n      // .call(graphZoom.transform, d3.zoomIdentity.scale(1))\r\n      const path = d3.path()\r\n      path.moveTo(margin.left, margin.top)\r\n      let x = margin.left;\r\n      let prex = margin.left;\r\n      let prey = margin.top;\r\n      let prer = 0;\r\n      let preSonLen = 0;\r\n      let layoutShow = _this.layoutShow;\r\n      let sumTotalDuration = 0;\r\n      let rootIndex = -1;\r\n      for (let i = 0; i < data.length; i++) {\r\n        let lay = parseInt(data[i]['layout']);\r\n\r\n        let colors = _this.mcolor;\r\n        let colorsD = _this.mDarkcolor;\r\n        let entityLocationData = tools.deepClone(data[i]);\r\n        if (lay == 0) {\r\n          rootIndex++;\r\n        }\r\n        entityLocationData['rootIndex'] = rootIndex;\r\n        entityLocationData['color'] = colors[rootIndex % colors.length];\r\n        entityLocationData['colorD'] = colorsD[rootIndex % colorsD.length];\r\n        let timeList = data[i]['time'];\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        sumTotalDuration += duration;\r\n        let showEntity = _this.showEntityList.find(function (d) { return d['id'] == data[i]['id'] });\r\n        if ((showEntity['show'] == true)) {\r\n          let y = margin.top + lay * stepY\r\n          let relevanceValue = data[i]['attribute']['relevance'];\r\n          let totalDurationValue = data[i]['totalDuration'];\r\n          let rScale = _this.totalDurationScale_linear;\r\n\r\n\r\n          let r = rScale(totalDurationValue);\r\n          let stepL = r + stepX / 2 + interval / 10;\r\n          let controlP1x = prex + interval / 1;\r\n          let controlP2x = x - interval / 1;\r\n          let curLinex = x - r - interval;\r\n\r\n          let relData = _this.relData;\r\n          let oData = _this.drawEntityLocation;\r\n          let basicRel = relData['basicRel'];\r\n          let daId = data[(i)]['id'];\r\n          let jg = 0;\r\n          for (let re = 0; re < basicRel.length; re++) {\r\n\r\n            let sorceId = basicRel[re][0];\r\n            let targetId = basicRel[re][1];\r\n            let cNode = '';\r\n            if ((sorceId == daId) || (targetId == daId)) {\r\n              jg = 1;\r\n            }\r\n          };\r\n          let sonFlag = 1;\r\n          if (((i > 0) && (preSonLen == 0)) && (data[(i)]['son'].length == 0)) {\r\n            sonFlag = 0;\r\n            stepL = r + stepX / 1.2 + interval / 10;\r\n            x += stepL;\r\n            controlP1x = prex + interval / 1;\r\n            controlP2x = x - r - interval / 2 - interval / 1;\r\n            curLinex = r + interval / 10;\r\n          }\r\n          else if (((i > 0) && (preSonLen != 0)) && (data[(i)]['son'].length == 0)) {\r\n            sonFlag = 0;\r\n            stepL = r + stepX + interval + 30;\r\n            x += stepL;\r\n            controlP1x = prex + interval / 1;\r\n            controlP2x = x - r - interval / 1 - interval / 1;\r\n            curLinex = r + interval / 10;\r\n          }\r\n          else {\r\n            stepL = r + stepX + interval + 10;\r\n            x += stepL;\r\n            controlP1x = prex + interval / 1;\r\n            controlP2x = x - r - interval - interval / 1;\r\n            curLinex = r + interval;\r\n          }\r\n\r\n          if ((jg == 1) && (data[i]['type'] == 0) && (data[(i)]['son'].length == 0)) {\r\n            curLinex += r * 1.5\r\n          }\r\n          _this.drawEntity(circleG, x, y, r, data[i])\r\n          path.bezierCurveTo(controlP1x, prey, controlP2x, y, x - curLinex, y)\r\n          // path.lineTo(controlP1x, prey)\r\n          // path.lineTo(controlP2x, y)\r\n          // path.lineTo(x - curLinex, y)\r\n          path.moveTo(x + curLinex, y);\r\n          prex = x + curLinex;\r\n          prey = y;\r\n          prer = r;\r\n          preSonLen = data[(i)]['son'].length;\r\n          entityLocationData['x'] = x;\r\n          entityLocationData['y'] = y;\r\n          entityLocationData['r'] = r;\r\n        }\r\n        else {\r\n          entityLocationData['x'] = prex;\r\n          entityLocationData['y'] = prey;\r\n          entityLocationData['r'] = prer;\r\n        }\r\n        entityLocationData['sonFlag'] = (entityLocationData['son'].length > 0) ? (1) : (0);\r\n        // entityLocationData['showRel'] = false;\r\n        _this.drawEntityLocation.push(entityLocationData);\r\n      }\r\n      let entityLocationData = _this.drawEntityLocation;\r\n      let colors = _this.mcolor;\r\n      let colorIndex = 0;\r\n      let colorrootIndex = 0;\r\n\r\n      _this.sumTotalDuration = sumTotalDuration;\r\n      for (let i = 0; i < entityLocationData.length; i++) {\r\n        let x = entityLocationData[i]['x'];\r\n        let y = entityLocationData[i]['y'];\r\n        let r = entityLocationData[i]['r'];\r\n\r\n        let showEntity = _this.showEntityList.find(function (d) { return d['id'] == entityLocationData[i]['id'] });\r\n        if (entityLocationData[i]['type'] == 0 && (showEntity['show'] == true)) {\r\n          _this.drawEntityTimeAxis(circleG, entityLocationData[i]);\r\n        }\r\n        if ((entityLocationData[i]['layout'] == '0' && (entityLocationData[i]['name'] != 'Test'))) {\r\n          colorIndex = colorrootIndex;\r\n          colorrootIndex++;\r\n\r\n        }\r\n        if ((entityLocationData[i]['son'].length != 0) && (_this.showEntityList.find(function (d) { return d['id'] == entityLocationData[i]['son'][0] })['show'])) {\r\n          let maxxs = entityLocationData[i]['x'] - entityLocationData[i]['r'] - 40;\r\n          let maxys = entityLocationData[i]['y'] - entityLocationData[i]['r'] - 40;\r\n          let minxs = tools.deepClone(maxxs);\r\n          let minys = tools.deepClone(maxys);\r\n          let rectPoints = [[maxxs, maxys]];\r\n          let sons = tools.deepClone(data[i]['son']);\r\n          while ((sons.length > 0)) {\r\n            let s = sons[0];\r\n            sons.splice(0, 1);\r\n            let curson = entityLocationData.find(function (d) { return d['id'] == s; });\r\n            let curgson = curson['son'];\r\n            let curx = curson['x'] + curson['r'] * 2;\r\n            let cury = curson['y'] + curson['r'] * 2;\r\n            if (curx > maxxs) { maxxs = curx; }\r\n            // if(curson['y']<maxys)maxys = curson['y'];\r\n            if (cury < minys) minys = cury;\r\n            if (cury > maxys) maxys = cury;\r\n            for (let gs = 0; gs < curgson.length; gs++) {\r\n              sons.push(curgson[gs]);\r\n            }\r\n          }\r\n          rectPoints = [[minxs, minys], [minxs, maxys], [maxxs, maxys], [maxxs, minys]];\r\n          // _this.drawpolygon(backG, colors[colorIndex], rectPoints, \"rgb(255,255,255)\",0.3);\r\n          _this.drawRect(backG, minxs, minys, Math.abs(maxxs - minxs), Math.abs(maxys - minys), 20, 20, colors[colorIndex], 0.1, \"white\", `backRect${i}`)\r\n\r\n          colorIndex++;\r\n          colorIndex %= colors.length\r\n        }\r\n        // entityLocationData[i]['color'] = colors[colorIndex - 1];\r\n        // if ((entityLocationData[i]['layout'] == '0') && ((entityLocationData[i]['name'] == 'Test') || (entityLocationData[i]['name'] == 'Example'))) {\r\n        //   entityLocationData[i]['color'] = colors[colorIndex]\r\n        // }\r\n      }\r\n      _this.drawTimeLine(timeLineG, path, \"rgb(200,200,200)\", 5, '0', 'timeLine ', 'timeLine ');\r\n      _this.drawRelationshipLine(timeLineG);\r\n      _this.drawTimeAxis(_this.TimeAxisSvg);\r\n      _this.drawTypeRiver(_this.TimeAxisSvg);\r\n      _this.updataTimeAxisDur(_this.TimeAxisSvg, _this.timeAxisX, _this.timeAxisW);\r\n    },\r\n    updataTimeAxisDur(svg, x, width) {\r\n      const _this = this;\r\n      let margin = _this.margin;\r\n      let totalWidth = _this.width - margin.left - margin.right;\r\n      let y = 0;\r\n      let h = 190;\r\n      _this.drawRect(svg, 0, y, x, h, 3, 3, 'white', 0.3, '', \"timeAxisRect1\")\r\n      let curRect = _this.drawRect(svg, x, y - 0, width, h - 5, 3, 3, 'rgba(0,0,0,0)', 1, 'rgb(145, 180, 189)', 'winRect', 2);\r\n      // --------------------------------------\r\n      // curRect.on('mousemove', function (e) {\r\n      //   d3.select(this).attr(\"cursor\", 'pointer');\r\n      //   if (_this.timeAxisDropFlag == 1) {\r\n      //     let mx = e.clientX - _this.timeAxisDownX;\r\n      //     _this.timeAxisX = e.layerX - 450 - _this.timeAxisW / 2;\r\n      //   }\r\n      // })\r\n      // curRect.on('mousedown', function (e) {\r\n      //   _this.timeAxisDownX = e.clientX;\r\n      //   _this.timeAxisDropFlag = 1;\r\n      // })\r\n      // curRect.on('mouseup', function (e) {\r\n      //   _this.timeAxisDownX = e.clientX;\r\n      //   _this.timeAxisDropFlag = 0;\r\n      // })\r\n      // ----------------------------------------\r\n\r\n      _this.drawRect(svg, x + width, y, totalWidth - width, h, 3, 3, 'white', 0.3, '', \"timeAxisRect2\")\r\n    },\r\n    drawTypeRiver(svg) {\r\n      const _this = this;\r\n      let oriData = _this.data;\r\n      let resData = [];\r\n      let triLi = [];\r\n      let exeLi = [];\r\n      var defs = svg.append(\"defs\");\r\n\r\n      var filter = defs\r\n        .append(\"filter\")\r\n        .attr(\"id\", \"coolShadow\")\r\n        .attr(\"x\", \"-100%\")\r\n        .attr(\"y\", \"-100%\") //\r\n        .attr(\"width\", \"300%\")\r\n        .attr(\"height\", \"300%\"); //\r\n\r\n      filter\r\n        .append(\"feMorphology\")\r\n        .attr(\"in\", \"SourceGraphic\")\r\n        .attr(\"result\", \"upperLayer\")\r\n        .attr(\"operator\", \"dilate\")\r\n        .attr(\"radius\", \"0.2 0.2\");\r\n\r\n      filter\r\n        .append(\"feMorphology\")\r\n        .attr(\"in\", \"SourceAlpha\")\r\n        .attr(\"result\", \"enlargedAlpha\")\r\n        .attr(\"operator\", \"dilate\")\r\n        .attr(\"radius\", \"0.2 0.2\");\r\n\r\n      filter\r\n        .append(\"feGaussianBlur\")\r\n        .attr(\"in\", \"enlargedAlpha\")\r\n        .attr(\"result\", \"bluredAlpha\")\r\n        .attr(\"stdDeviation\", \"3\");\r\n\r\n      filter\r\n        .append(\"feOffset\")\r\n        .attr(\"in\", \"bluredAlpha\")\r\n        .attr(\"result\", \"lowerLayer\")\r\n        .attr(\"dy\", \"1\"); //\r\n\r\n      var feMerge = filter.append(\"feMerge\");\r\n      feMerge.append(\"feMergeNode\").attr(\"in\", \"lowerLayer\");\r\n      feMerge.append(\"feMergeNode\").attr(\"in\", \"upperLayer\");\r\n      for (let i = 0; i < oriData.length; i++) {\r\n        let curEnt = oriData[i];\r\n        let tp = {}\r\n        tp['od'] = i;\r\n        if ((curEnt['type'] == \"1\")) {\r\n          triLi.push(tp);\r\n        }\r\n        if (curEnt['type'] == \"2\") {\r\n          exeLi.push(tp);\r\n        }\r\n        let typeData = curEnt[\"attribute\"][\"expressions\"];\r\n        let totalDur = 0;\r\n\r\n        for (let t in typeData) {\r\n          // let color = typeColor[i];\r\n          let typeDurition = typeData[t];\r\n          let totalTypeSeconds = 0;\r\n          for (let d in typeDurition) {\r\n            totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n          }\r\n          totalDur += totalTypeSeconds;\r\n          tp[t] = totalTypeSeconds;\r\n        }\r\n        for (let t in tp) {\r\n          if (t != 'od') {\r\n            tp[t] /= totalDur;\r\n            if (totalDur == 0) {\r\n              tp[t] = 0;\r\n            }\r\n          }\r\n        }\r\n        resData.push(tp)\r\n      }\r\n\r\n      let data = resData;\r\n      var stack = d3.stack()\r\n        .keys(['1', '2', '3'])\r\n        .order(d3.stackOrderInsideOut)\r\n        .offset(d3.stackOffsetWiggle);\r\n\r\n      let yRangeWidth = 70;\r\n      let w = parseInt(svg.attr(\"width\")) + 60\r\n      let xStep = (w) / oriData.length;\r\n      let yScale = d3.scaleLinear().domain([-1, 1]).range([0, 70]);\r\n      var area = d3.area()\r\n        .curve(d3.curveBasis)\r\n        .x(function (d) {\r\n          return d.data.od * xStep + 15;\r\n        })\r\n        .y0(function (d) {\r\n          return 143 + yRangeWidth - yScale(d[0]);\r\n        })\r\n        .y1(function (d) {\r\n          return 143 + yRangeWidth - yScale(d[1]);\r\n        });\r\n      let stackData = stack(data)\r\n      let lenThreshold = 0.4;\r\n      let iconLi = {}\r\n      for (let s in stackData) {\r\n        iconLi[s] = []\r\n        for (let i in stackData[s]) {\r\n          let lenArea = stackData[s][i]\r\n          if ((lenArea[1] - lenArea[0]) > 0.4) {\r\n            iconLi[s].push([i, lenArea]);\r\n          }\r\n          for (let li in iconLi[s]) {\r\n            if (i < (iconLi[s][li][0] + 2)) {\r\n              let selectArea = iconLi[s][li][1]\r\n              if (((selectArea[1] - lenArea[1]) - (selectArea[0] - lenArea[0])) < 0.2) {\r\n                iconLi[s].splice(s, 1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // let areaG = svg.append(\"g\")\r\n      let typeColor = {\r\n        \"1\": \"#ff9c9c\",\r\n        \"2\": \"#f4f4d0\",\r\n        \"3\": \"#6f8be0\",\r\n      };\r\n      let colorLi = _this.mcolor;\r\n      svg.selectAll(\"path\")\r\n        .data(stackData)\r\n        .join(\"path\")\r\n        .attr(\"id\", function (d) { return d.key })\r\n        .attr(\"class\", \"river\")\r\n        .attr(\"d\", function (d) {\r\n          return area(d)\r\n        })\r\n        .attr(\"fill\", function (d, i) {\r\n          return typeColor[d.key]\r\n        })\r\n        .on(\"mouseover\", function (d) {\r\n          d3.selectAll(\".river\").style(\"filter\", \"url()\")\r\n          d3.select(this).style(\"filter\", \"url(#coolShadow)\")\r\n        })\r\n\r\n      for (let t in triLi) {\r\n        let area = tools.calcTriangle((triLi[t]['od']) * xStep, -30, 14);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n        _this.drawTxt(svg, (triLi[t]['od']) * xStep, -23, \"T\", \"white\", 0, \"middle\", 18)\r\n      }\r\n      for (let t in exeLi) {\r\n        let area = tools.calcTriangle((exeLi[t]['od']) * xStep, -30, 14);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n        _this.drawTxt(svg, (exeLi[t]['od']) * xStep, -23, \"E\", \"white\", 0, \"middle\", 18)\r\n      }\r\n    },\r\n    drawTimeAxis(svg) {\r\n      const _this = this;\r\n      let sumTotalDuration = _this.sumTotalDuration;\r\n      let data = _this.drawEntityLocation;\r\n      let addData = tools.deepClone(_this.drawEntityLocation);\r\n      let margin = _this.margin;\r\n      let prex = margin.left;\r\n      let prey = margin.top / 2;\r\n      let width = svg.attr(\"width\")// _this.width - margin.left - margin.right;\r\n      let height = _this.height - margin.top - margin.bottom;\r\n      let widthScale = d3.scaleLinear([0, sumTotalDuration], [0, width]);\r\n      data.forEach((self, indx, arr) => {\r\n        let totalDurationValue = self['totalDuration'];\r\n        let timeList = self['time'];\r\n        let id = self['id']\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        // console.log(timeList,tools.time2seconds(timeList[0]))\r\n        let evWidth = widthScale(duration) - 4;\r\n\r\n        let evTWidth = widthScale(totalDurationValue);\r\n        let lay = parseInt(self['layout']);\r\n        let evHight = 80 - 20 * lay;\r\n        let x = prex;\r\n        let y = prey + 20 * lay;\r\n        prex += evWidth + 4;\r\n        let cr = 3;\r\n        // if(self['type']==0){\r\n        if (1) {\r\n          if (lay == 0) {\r\n            _this.drawRect(svg, x - 2, y - 20, evTWidth, 100, 6, 6, self['color'], 0.3, 'white', `timeAxisEntB_${indx}`, 1.5, 'timeAxisEntB')\r\n          }\r\n          _this.drawRect(svg, x, y, evWidth, evHight, 3, 3, self['color'], 0.4, self['colorD'], `timeAxisEnt_${id}`, 1.5, 'timeAxisEnt')\r\n          _this.drawTxt(svg, x + evWidth / 2, y + evHight + 20, 10, [self['name'].split(\" \")], \"grey\", 16, `timeText_${id}`, 'timeText');\r\n        }\r\n        else {\r\n          if (lay == 0) {\r\n            _this.drawRect(svg, x - 2, y - 20, evTWidth, 100, 6, 6, self['color'], 0.3, 'white', `timeAxisEntB_${id}`, 1.5, 'timeAxisEnt')\r\n          }\r\n          let area = [[x + cr, y + evHight - cr], [x - cr + evWidth, y + evHight - cr], [x + evWidth / 2, y]];\r\n          _this.drawTriangle(svg, self['color'], area, self['color'], 1, cr * 2);\r\n        }\r\n        addData[indx]['timeX'] = x;\r\n        addData[indx]['timeW'] = evWidth\r\n      })\r\n\r\n      d3.selectAll('.timeText').attr(\"opacity\", 0)\r\n      _this.drawEntityLocation = addData;\r\n    },\r\n    drawTriangle(svg, color, points, stroke, opacity = 1, strokeW = 15) {\r\n      svg.append(\"polygon\")\r\n        .attr(\"points\", points)\r\n        .attr(\"fill\", color)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", strokeW);\r\n    },\r\n    drawpolygon(svg, color, areas, stroke, opacity = 1) {\r\n      svg.append(\"polygon\")\r\n        .attr(\"points\", areas)\r\n        .attr(\"fill\", color)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", \"1.5px\");\r\n    },\r\n    drawEntityTimeAxis(svg, entData) {\r\n\r\n      const _this = this;\r\n      let x = entData['x'];\r\n      let r = entData['r'];\r\n      let y = entData['y'] + r / 2;\r\n      let daId = entData['id']\r\n      let entDataO = _this.drawEntityLocation;\r\n      let sumTotalDuration = _this.sumTotalDuration;\r\n      let widthScale = d3.scaleLinear([0, sumTotalDuration], [0, Math.PI]);\r\n      let timeStepR = 0;\r\n      let timeStartR = -Math.PI / 2;\r\n      let inter = 0;\r\n      let sons = tools.deepClone(entData['son']);\r\n      let relList = [];\r\n      let relRootList = [];\r\n      let psNum = 0.5;\r\n      if ((sons.length > 0)) {\r\n        inter = 14\r\n      }\r\n\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let basicRel = relData['basicRel'];\r\n      for (let re = 0; re < basicRel.length; re++) {\r\n\r\n        let sorceId = basicRel[re][0];\r\n        let targetId = basicRel[re][1];\r\n        let cNode = '';\r\n        if (sorceId == daId) {\r\n          cNode = oData.find(function (d) { return d['id'] == targetId });\r\n          relList.push(targetId);\r\n          relRootList.push(cNode['rootIndex']);\r\n        }\r\n\r\n        if (targetId == daId) {\r\n          cNode = oData.find(function (d) { return d['id'] == sorceId });\r\n          relList.push(sorceId);\r\n          relRootList.push(cNode['rootIndex']);\r\n        }\r\n      };\r\n      // if(entData[]) \r\n      let wline = 0;\r\n      let sumTotalDurationF = 0;\r\n      entDataO.forEach((self, indx, arr) => {\r\n        let totalDurationValue = self['totalDuration'];\r\n        let timeList = self['time'];\r\n        let layout = self['layout'];\r\n        let rootIndex = self['rootIndex'];\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        timeStepR = widthScale(duration);\r\n        if (!relRootList.includes(rootIndex)) {\r\n          wline += timeStepR * psNum;\r\n          sumTotalDurationF += duration;\r\n        }\r\n      })\r\n      let widthScaleA = d3.scaleLinear([0, sumTotalDuration - sumTotalDurationF], [0, Math.PI - wline]);\r\n      // if(rootEntityList.length==0){\r\n      //   widthScaleA = widthScale\r\n      // }\r\n      // let wline = 0;\r\n      entDataO.forEach((self, indx, arr) => {\r\n        let totalDurationValue = self['totalDuration'];\r\n        let timeList = self['time'];\r\n        let layout = self['layout'];\r\n        let rootIndex = self['rootIndex'];\r\n        let cId = self['id'];\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        timeStepR = widthScale(duration);\r\n        if (!relRootList.includes(rootIndex)) {\r\n          if (relRootList.length != 0) {\r\n            timeStepR = psNum * widthScale(duration);\r\n          }\r\n        }\r\n        else {\r\n          timeStepR = widthScaleA(duration)\r\n        }\r\n        let endAnglet = timeStartR + timeStepR;\r\n        var dataset = { startAngle: timeStartR, endAngle: endAnglet }; //\r\n        timeStartR = endAnglet;\r\n        let color = 'blue';\r\n        let rh = 30;\r\n        let h = rh;\r\n        let nh = 0;\r\n        if (relRootList.length != 0) {\r\n          h = rh * 0.32 + rh * 0.6 - 3 * layout;\r\n          nh = rh * 0.3;\r\n        }\r\n        if (!relRootList.includes(self['rootIndex'])) {\r\n          h = rh * 0.7;\r\n          nh = h * 0 + h * 0.6;\r\n        }\r\n        else {\r\n          dataset.startAngle += 0.003;\r\n          dataset.endAngle -= 0.003;\r\n\r\n        }\r\n        var arcPath = d3.arc()\r\n          .innerRadius(r + inter + nh)\r\n          .outerRadius(r + inter + h);\r\n        var pathArc = arcPath(dataset);\r\n        let arc;\r\n        if (relRootList.length != 0) {\r\n          let jiantouPath = d3.path();\r\n          jiantouPath.arc(x, y - r / 2, r + h + inter, - Math.PI, 0);\r\n\r\n          // _this.drawTimeLine(_this.arcG, jiantouPath, \"rgb(200,200,200)\", 1, '9,5', 'timeLayout ', 'timeLayout ');\r\n\r\n          if (relRootList.includes(self['rootIndex'])) {\r\n            if (relList.includes(parseInt(self['id']))) {\r\n              arc = _this.drawArc(svg, x, y - r / 2, pathArc, self['color'], self['color'], `timeAxisFor f${entData['id']} ${self['id']}`, '0', 0, 1);\r\n            }\r\n            else {\r\n              arc = _this.drawArc(svg, x, y - r / 2, pathArc, \"white\", self['color'], `timeAxisFor f${entData['id']} ${self['id']}`, '0', 0.0, 0.4);\r\n            }\r\n          }\r\n          else {\r\n            arc = _this.drawArc(svg, x, y - r / 2, pathArc, self['color'], self['color'], `timeAxisFor f${entData['id']} ${self['id']}`, '0', 0, 0.2);\r\n\r\n          }\r\n          arc.on(\"mouseover\", function (d) {\r\n            let classN = d3.select(this).attr(\"class\");\r\n            let sId = (classN.split(\" \")[1] + \"\").slice(1);\r\n            let tId = classN.split(\" \")[2];\r\n            _this.showEntityRelIdList = [sId]\r\n            _this.overEntityId = sId;\r\n            _this.overTargetEntityId = tId;\r\n          })\r\n          arc.on(\"mouseleave\", function (d) {\r\n            let classN = d3.select(this).attr(\"class\");\r\n            let sId = (classN.split(\" \")[1] + \"\").slice(1);\r\n            let showRel = _this.showEntityRelIdList;\r\n            _this.overTargetEntityId = '';\r\n            _this.overEntityId = _this.curEntId;\r\n            if (_this.showEntityRelIdOverState == 1) {\r\n              showRel.push(parseInt(sId))\r\n            }\r\n            else {\r\n              showRel.splice(showRel.indexOf(parseInt(sId)), 1)\r\n            }\r\n          })\r\n        }\r\n      })\r\n    },\r\n    drawEntity(svg, x, y, r, data) {\r\n      const _this = this;\r\n      let color_linear = _this.importanceColor_linear;\r\n      let compute_color = _this.importanceCompute_color;\r\n      let rScale = _this.relevanceScale_linear;\r\n      let oData = _this.data;\r\n      let importanceValue = data['attribute']['importance'];\r\n      let relevanceValue = data['attribute']['relevance'];\r\n      // let r = rScale(relevanceValue)\r\n      // { 'id': data[i]['id'], \"x\": x, \"r\": r, \"layout\": lay, \"y\": y, \"sonFlag\": sonFlag }\r\n\r\n\r\n      if (data['type'] == '1') {\r\n        let area = tools.calcTriangle(x, y, r);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n\r\n        _this.drawTxt(svg, x, y + 8, 20, [\"T\"], 'white', 28, \"T\")\r\n      }\r\n      else if (data['type'] == '2') {\r\n        let area = tools.calcTriangle(x, y, r);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n\r\n        _this.drawTxt(svg, x, y + 8, 20, [\"E\"], 'white', 28, \"E\")\r\n      }\r\n      else {\r\n\r\n        let cy = y;\r\n        let totalDuration = _this.totalDuration;\r\n        let timeLineScale_linear = d3.scaleLinear([0, totalDuration], [x - r * Math.sqrt(3) / 2, x + r * Math.sqrt(3) / 2])\r\n        let timeLineHighScale_linear = d3.scaleLinear([0, _this.maxTotalDuration - 50], [r / 2, r * (1 + Math.sqrt(3) / 3 * 2)])\r\n        let circleColor = compute_color(color_linear(importanceValue));\r\n        _this.drawCircle(svg, x, cy, r, circleColor, data, 1, \"entCircle\", \"entCircle_\" + data['id']);\r\n\r\n        r = r * Math.sqrt(3) / 2;\r\n        y += r / 2;\r\n        let path = d3.path();\r\n\r\n\r\n        path.moveTo(x - r, y);\r\n        let lineLi = [data];\r\n        let linePoint = [{ 'id': data['id'], 'time': data['time'], 'x': 0, 'y': 0 }];\r\n        let jgidL = [data['id']];\r\n        let similarityRelsli = [data[\"similarityRel\"]];\r\n        while (similarityRelsli.length > 0) {\r\n          let similarityRels = similarityRelsli[0];\r\n          similarityRelsli.splice(0, 1);\r\n          let jg = 0;\r\n          for (let srel in similarityRels) {\r\n            let cdata = oData.find(function (d) { return d['id'] == similarityRels[srel] });\r\n            if (jgidL.indexOf(cdata['id']) == -1) {\r\n              similarityRelsli.push(cdata[\"similarityRel\"])\r\n              jg = 1;\r\n              lineLi.push(cdata)\r\n              jgidL.push(cdata['id'])\r\n              linePoint.push({ 'id': cdata['id'], 'time': cdata['time'], 'x': 0, 'y': 0 })\r\n            }\r\n          }\r\n          // if(jg==0){\r\n          // break;\r\n          // }\r\n        }\r\n\r\n        const sortmt = (a, b) => {\r\n          return tools.time2seconds(a[0]) - tools.time2seconds(b[0]);\r\n        }\r\n        const sortlp = (a, b) => {\r\n          return tools.time2seconds(a['time'][0]) - tools.time2seconds(b['time'][0]);\r\n        }\r\n\r\n        lineLi = lineLi.sort(sortlp);\r\n        linePoint = linePoint.sort(sortlp);\r\n        let lineData = [[x - r * Math.sqrt(3) / 2 - 4, y]];\r\n        for (let t = 0; t < lineLi.length; t++) {\r\n          let startT = lineLi[t]['time'][0];\r\n          let duration = lineLi[t]['totalDuration']\r\n          // let endT = lineLi[t]['time'][1];\r\n          let startS = tools.time2seconds(startT);\r\n          let endS = startS + duration;\r\n          // let startx = timeLineScale_linear((startS - duration * 10));\r\n          // let endx = timeLineScale_linear((endS + duration * 10));\r\n          let limst = (x - r * Math.sqrt(3) / 2);\r\n          let limed = (x + r * Math.sqrt(3) / 2);\r\n          let startx = (limst < timeLineScale_linear((startS))) ? (timeLineScale_linear((startS))) : (limst);\r\n          let endx = (limed > timeLineScale_linear((endS))) ? (timeLineScale_linear((endS))) : (limed);\r\n          // let midx = timeLineScale_linear((endS + startS) / 2);\r\n          let midx = (startx + endx) / 2;\r\n          let ys = y;\r\n          let yz = y - timeLineHighScale_linear((duration));\r\n          linePoint[t]['x'] = midx;\r\n          linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n          // if (startx < (lineData[lineData.length - 1][0])) {\r\n          if (t > 0) {\r\n            lineData.splice(lineData.length - 1, 1);\r\n            midx += t * 5;\r\n            startx = midx - ((midx - (lineData[lineData.length - 1][0] + midx) / 2)) / 2;\r\n            endx += t * 5;\r\n            ys = y + (y - lineData[lineData.length - 1][1]) / 3\r\n          }\r\n          // }\r\n          lineData.push([startx, ys], [midx, yz], [endx, y])\r\n          // let startx = timeLineScale_linear((startS - duration * 10));\r\n          // let endx = timeLineScale_linear((endS + duration * 10));\r\n\r\n          // let startyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let startyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let endyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let endyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let yz = y - timeLineHighScale_linear((duration));\r\n          // let midx = timeLineScale_linear((endS + startS) / 2);\r\n          // linePoint[t]['x'] = midx;\r\n          // linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n          // let y1 = y;\r\n          // if (startx < (lineData[lineData.length - 1][0])) {\r\n          //   if (t > 0) {\r\n          //     lineData.splice(lineData.length - 3, 3);\r\n          //     startx = (lineData[lineData.length - 1][0] + midx) / 2;\r\n          //     y1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n          //     startyf = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n          //     startyf1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n          //   }\r\n          // }\r\n          // let startx1 = startx + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // let endx1 = endx - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // let startx2 = startx1 + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // let endx2 = endx1 - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // if (endx > (r + x)) endx = r + x;\r\n          // if (startx1 < (lineData[lineData.length - 1][0])) startx1 = lineData[lineData.length - 1][0];\r\n          // if (endx1 > (r + x)) endx1 = r + x;\r\n          // if (startx2 < (lineData[lineData.length - 1][0])) startx2 = lineData[lineData.length - 1][0];\r\n          // if (endx2 > (r + x)) endx2 = r + x;\r\n          // lineData.push([startx, y1], [startx1, startyf1], [startx2, startyf], [midx, yz], [endx2, endyf], [endx1, endyf1], [endx, y])\r\n        }\r\n        lineData.push([x + r, y])\r\n        let curve_generator = d3.line()\r\n          .x((d) => d[0])\r\n          .y((d) => {\r\n            let h = Math.sqrt(Math.pow(r, 2) - Math.pow((d[0] - (x - r)), 2));\r\n            if ((y - d[1]) > (h + r * Math.sqrt(3) / 2))\r\n              return y - (h + r * Math.sqrt(3) / 2) + 2;\r\n            return d[1];\r\n          })\r\n          .curve(d3.curveBundle)\r\n        // .curve(d3.curveCatmullRom  )\r\n        // .curve(d3.curveBasis)\r\n        _this.drawTimeLine(svg, curve_generator(lineData), \"white\", 2, '0', 'sonLine ', 'sonLine ');\r\n\r\n\r\n        for (let p = 0; p < linePoint.length; p++) {\r\n          _this.drawCircle(svg, linePoint[p]['x'], linePoint[p]['y'], 5, \"red\", linePoint[p], 0, \"linePoint\", \"linePoint_\" + linePoint[p]['id']);\r\n        }\r\n\r\n        // \"1\": \"rgb(145, 204, 117)\",\r\n        //   \"2\": \"rgb(84, 112, 198)\",\r\n        //   \"3\": \"rgb(238, 102, 102)\",\r\n        let typeColor = {\r\n          \"1\": \"#ff9c9c\",\r\n          \"2\": \"#f4f4d0\",\r\n          \"3\": \"#6f8be0\",\r\n        };\r\n        let duration = tools.time2seconds(data['time'][0]) - tools.time2seconds(data['time'][1]);\r\n        let typeData = data['attribute']['expressions'];\r\n        let sonList = data['son'];\r\n        let sons = [sonList];\r\n        while (sons.length > 0) {\r\n          let curSonList = sons[0];\r\n          sons.splice(0, 1);\r\n          if (curSonList.length > 0) {\r\n            for (let s in curSonList) {\r\n              let sonData = oData.find(function (d) { return d['id'] == curSonList[s] });\r\n              let sonTypeData = sonData['attribute']['expressions'];\r\n\r\n              for (let t in sonTypeData) {\r\n                let typeDurition = sonTypeData[t];\r\n                for (let d in typeDurition) {\r\n                  typeData[t].push(typeDurition[d])\r\n                }\r\n              }\r\n              sons.push(sonData['son']);\r\n            }\r\n          }\r\n        }\r\n        var typeStartR = 0//Math.PI/4;\r\n\r\n        var typeStepR = Math.PI / 1;\r\n\r\n        if (sonList.length > 0) {\r\n          let typeTotalDur = 0;\r\n          for (let t in typeData) {\r\n            let typeDurition = typeData[t];\r\n            for (let d in typeDurition) {\r\n              typeTotalDur += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n          }\r\n          let typeArcScale_linear = d3.scaleLinear([0, typeTotalDur], [0, Math.PI * 2]);\r\n          for (let i in typeData) {\r\n            let color = typeColor[i];\r\n            let typeDurition = typeData[i];\r\n            let totalTypeSeconds = 0;\r\n            for (let d in typeDurition) {\r\n              totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n            if (totalTypeSeconds > 0) {\r\n              let typeStepR = typeArcScale_linear(totalTypeSeconds)//Math.PI/2;\r\n\r\n              let endAnglet = typeStartR + 1 * typeStepR\r\n              var dataset = { startAngle: typeStartR, endAngle: endAnglet }; //\r\n              typeStartR = endAnglet;\r\n              var arcPath = d3.arc()\r\n                .innerRadius(r + 10)\r\n                .outerRadius(r + 25);\r\n              var pathArc = arcPath(dataset);\r\n              _this.drawArc(svg, x, y - r / 2, pathArc, color, color, 'type f' + data['id'] + \" t\" + i);\r\n            }\r\n          }\r\n          let sonTotal = 0;\r\n          let sonNum = 0\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n            sonTotal += sonDur;\r\n            sonNum += 1;\r\n          }\r\n          let skipArc = Math.PI / (sonNum + 2);\r\n          let timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI - skipArc * (sonNum - 1)]);\r\n          let timeSonHeighLinear = d3.scaleLinear([0, sonTotal], [40, 40]);\r\n\r\n          let timeSonColor_linear = d3.scaleLinear().domain([0, sonTotal]).range([0, 1]);\r\n          let timeSonCompute_color = d3.interpolate(\"white\", circleColor);\r\n          var sonStartR = Math.PI / 2;\r\n\r\n          let relList = [];\r\n          let relRootList = [];\r\n          let psNum = 0.1;\r\n          let daId = data['id']\r\n          let relData = _this.relData;\r\n          let odData = _this.data;\r\n          let basicRel = relData['basicRel'];\r\n          for (let re = 0; re < basicRel.length; re++) {\r\n\r\n            let sorceId = basicRel[re][0];\r\n            let targetId = basicRel[re][1];\r\n            let cNode = '';\r\n            if (sorceId == daId) {\r\n              cNode = odData.find(function (d) { return parseInt(d['id']) == parseInt(targetId) });\r\n              relList.push(targetId);\r\n            }\r\n\r\n            if (targetId == daId) {\r\n              cNode = odData.find(function (d) { return parseInt(d['id']) == parseInt(sorceId) });\r\n              relList.push(sorceId);\r\n            }\r\n          };\r\n          if (relList.length == 0) {\r\n            sonStartR = 0;\r\n            timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI * 2 - skipArc * (sonNum)]);\r\n          }\r\n\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n\r\n            let sonStepR = timeSonLinear(sonDur)//Math.PI/2;\r\n\r\n            let endAnglet = sonStartR + sonStepR;\r\n            var dataset = { startAngle: sonStartR, endAngle: endAnglet }; //\r\n            sonStartR = endAnglet;\r\n            let color = 'blue';\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 28)\r\n              .outerRadius(r + timeSonHeighLinear(sonDur));\r\n            var arcMidPath = d3.arc()\r\n              .innerRadius(0)\r\n              .outerRadius(r + 32);\r\n            var pathArc = arcPath(dataset);\r\n\r\n            endAnglet = sonStartR + skipArc;\r\n            var midDataset = { startAngle: sonStartR, endAngle: endAnglet }; //\r\n\r\n            let jiantouPath = d3.path();\r\n            jiantouPath.arc(x, y - r / 2, r + 32, sonStartR - Math.PI / 2, endAnglet - Math.PI / 2);\r\n\r\n            sonStartR += skipArc;\r\n            var pathMidArc = arcMidPath(midDataset);\r\n            let timeSonColor = compute_color(color_linear(sonData['attribute']['importance']));\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, timeSonColor, timeSonColor, 'son f' + data['id'] + \" s\" + sonList[s], '0');\r\n            if (s != sonList.length - 1) {\r\n\r\n              // console.log\r\n              _this.drawTimeLine(_this.arcG, jiantouPath, \"rgb(200,200,200)\", 3, '9,5', 'midArc ', 'midArc ');\r\n              // _this.drawTimeLine(_this.arcG, path, \"white\", 2,'0', 'sonLine ', 'sonLine ');\r\n              // _this.drawArc(_this.arcG, x, y - r / 2, pathMidArc, \"rgb(200,200,200)\", \"white\", 'son f' + data['id'], \"9,5\", 3);\r\n            }\r\n          }\r\n\r\n        };\r\n      }\r\n      let txts = data['name'].split(\" \")\r\n      let tx = x - r - 30;\r\n      let ty = y + r + 60;\r\n      let tw = r * 2;\r\n      tx = x;\r\n      if (data['son'].length == 0) {\r\n        tx = x//-r-10;\r\n        ty = y + r * 2;\r\n      }\r\n      if (data['id'] == \"3\") {\r\n        tx = x - 10;\r\n        ty = y + r * 2;\r\n      }\r\n      if (data['id'] == \"4\") {\r\n        tx = x + 10;\r\n        ty = y + r * 2;\r\n      }\r\n      // if(data['type']=='1'){\r\n      //   tx = x-r/2;\r\n      //   ty = y+r*2;\r\n      // }\r\n\r\n      _this.drawTxt(svg, tx, ty, tw, txts, \"grey\", 16, `text_${data['id']}`);\r\n    },\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3, opacity = 1) {\r\n      let arc = svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n        .attr(\"opacity\", opacity);\r\n      return arc;\r\n    },\r\n    drawCircle(svg, x, y, r, fill, data, opacity, className, idName) {\r\n      const _this = this;\r\n      const oData = _this.data\r\n      svg.append(\"circle\")\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"cx\", x)\r\n        .attr(\"cy\", y)\r\n        .attr(\"r\", r)\r\n        .attr(\"fill\", fill)\r\n        .on(\"mouseover\", function (d) {\r\n          d3.select(this).attr(\"r\", r * 1.1)\r\n          let classN = d3.select(this).attr(\"class\");\r\n          let idN = d3.select(this).attr(\"id\").split(\"_\")[1]\r\n          _this.overEntityId = idN\r\n          let showRel = _this.showEntityRelIdList\r\n          if (!showRel.includes(parseInt(idN))) {\r\n            showRel.push(parseInt(idN))\r\n            _this.showEntityRelIdOverState = 0;\r\n          }\r\n          else {\r\n            _this.showEntityRelIdOverState = 1;\r\n          }\r\n          _this.showEntityRelIdList = showRel;\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 1).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1.1)\"\r\n              })\r\n\r\n            d3.selectAll(\".basicRel\")\r\n              .attr(\"class\", function (d) {\r\n                let classN = d3.select(this).attr(\"class\");\r\n                let classNList = classN.split(\" \");\r\n                let jg = 0;\r\n                for (let i = 0; i < classNList.length - 1; i++) {\r\n                  if ('source' + data['id'] == classNList[i]) { jg = 1; }\r\n                  if ('target' + data['id'] == classNList[i]) { jg = 1; }\r\n                }\r\n                if (jg == 1) {\r\n                  classN += \" activeS\";\r\n                }\r\n                return classN;\r\n              })\r\n          }\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(this).attr(\"r\", r)\r\n\r\n          _this.overEntityId = _this.curEntId;\r\n          let classN = d3.select(this).attr(\"class\");\r\n\r\n          let idN = d3.select(this).attr(\"id\").split(\"_\")[1]\r\n          let showRel = _this.showEntityRelIdList\r\n          if (_this.showEntityRelIdOverState == 1) {\r\n            showRel.push(parseInt(idN))\r\n          }\r\n          else {\r\n            showRel.splice(showRel.indexOf(parseInt(idN)), 1)\r\n          }\r\n          _this.showEntityRelIdList = showRel;\r\n\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 0).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1)\"\r\n              })\r\n            d3.select(\"#graphPanel\").selectAll(\"path\")\r\n              .attr(\"class\", function (d) {\r\n                let thisSelect = d3.select(this)\r\n                let classN = thisSelect.attr(\"class\");\r\n                let classNList = classN.split(\" \")\r\n                if (classNList[classNList.length - 1] == \"activeS\") {\r\n                  classN = \"\";\r\n                  for (let i = 0; i < classNList.length - 1; i++) {\r\n                    classN += \" \" + classNList[i];\r\n                  }\r\n                }\r\n                return classN\r\n              })\r\n          }\r\n        })\r\n        .on(\"click\", function (d) {\r\n\r\n          let idN = d3.select(this).attr(\"id\").split(\"_\")[1]\r\n          let showRel = _this.showEntityRelIdList;\r\n          //  - _this.showEntityRelIdOverState;\r\n          if (!showRel.includes(parseInt(idN))) {\r\n            showRel = [(parseInt(idN))]\r\n            _this.showEntityRelIdOverState = 1;\r\n          }\r\n          else if (showRel.includes(parseInt(idN))) {\r\n            // showRel.filter(item=>{return item==parseInt(idN)})\r\n            _this.showEntityRelIdOverState = 0;\r\n            showRel.splice(showRel.indexOf(parseInt(idN)), 1)\r\n          }\r\n          _this.showEntityRelIdList = showRel;\r\n\r\n          d3.select(this).attr(\"r\", r);\r\n          d3.selectAll(\".f\" + data['id'])\r\n            .attr(\"transform\", function (d) {\r\n              let transformd = d3.select(this).attr(\"transform\")\r\n              return transformd.split(\" \")[0] + \" scale(1)\"\r\n            })\r\n          let thisId = this.id.split(\"_\")[1];\r\n          _this.curEntId = thisId;\r\n          let thisData = oData.find(function (a) { return a['id'] == thisId })\r\n          let thisTime = thisData['time'];\r\n          _this.click_Ent(thisTime);\r\n          // console.log(thisTime,thisId,thisData)\r\n        })\r\n        .on(\"contextmenu\", function (d, i) {\r\n          d.preventDefault();\r\n\r\n          if (_this.btnEdi) {\r\n            _this.editDivShow = true;\r\n            _this.$refs.editDiv.style.top = `${d.clientY}px`;\r\n            _this.$refs.editDiv.style.left = `${d.clientX}px`;\r\n          }\r\n          else {\r\n            let thisId = this.id.split(\"_\")[1];\r\n            let thisShowEntityData = _this.showEntityList.find(function (d) { return d['id'] == thisId });\r\n            let thisSons = thisShowEntityData['son'];\r\n            if (thisSons.length != 0) {\r\n              let sons = tools.deepClone(thisSons);\r\n              let showJage = false;\r\n              let i = 0\r\n              while ((sons.length > 0)) {\r\n                let s = sons[0];\r\n                sons.splice(0, 1);\r\n                let curson = _this.showEntityList.find(function (d) { return d['id'] == s + '' })\r\n                if (i == 0) {\r\n                  i++;\r\n                  showJage = !curson['show']\r\n                }\r\n                // ['show'] = !_this.showEntityList.find(function (d) { return d['id'] == thisSons[s] })['show']\r\n                curson['show'] = showJage;\r\n                let curgson = curson['son'];\r\n                if (!showJage) {\r\n                  for (let gs = 0; gs < curgson.length; gs++) {\r\n                    sons.push(curgson[gs]);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          _this.updataGraph()\r\n        });\r\n      // .on(\"\")\r\n    },\r\n    drawRect(svg, x, y, w, h, rx, ry, fill, opacity, stroke, id = 'rect', strokeW = 1.5, classN = 'rect') {\r\n      d3.select(`#${id}`).remove()\r\n      let rect = svg.append(\"rect\")\r\n        .attr(\"id\", id)\r\n        .attr(\"class\", classN)\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"ry\", ry)\r\n        .attr(\"height\", h)\r\n        .attr(\"width\", w) //\r\n        .attr(\"fill\", fill)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", `${strokeW}px`);\r\n      return rect;\r\n    },\r\n    drawTxt(svg, x, y, width, txts, fill, fontsize = 12, idN, classN = \"text\") {\r\n      let tx = x;\r\n      let ty = y;\r\n      let preWidth = 0;\r\n      let preIdN = 0;\r\n      let pretext = ''\r\n      for (let t = 0; t < txts.length; t++) {\r\n        pretext += \" \" + txts[t];\r\n        let txt = svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"id\", `${idN}_${t}`)\r\n          .attr(\"class\", `${classN}`)\r\n          .attr(\"fill\", fill)\r\n          .attr(\"font-size\", fontsize)\r\n          .style(\"text-anchor\", \"middle\")\r\n          .text(pretext)\r\n        let textWidth = document.getElementById(`${idN}_${t}`).getBBox().width;\r\n        if ((textWidth > width) || (t == txts.length - 1)) {\r\n          pretext = '';\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n        else {\r\n          txt.remove()\r\n        }\r\n        preWidth += textWidth;\r\n      }\r\n    },\r\n    drawTimeLine(svg, path, stroke, width, stroke_dasharray = \"0\", idName, className) {\r\n      svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .attr('fill', 'none')\r\n        .on('mouseover', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let idN = thisSelect.attr(\"id\");\r\n          if (classN.split(\" \")[0] == \"basicRel\") {\r\n            d3.select(this).attr(\"class\", classN + \" activeS\");\r\n          }\r\n        })\r\n        .on('mouseleave', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let classNList = classN.split(\" \")\r\n          if (classNList[classNList.length - 1] == \"activeS\") {\r\n            classN = \"\";\r\n            for (let i = 0; i < classNList.length - 1; i++) {\r\n              classN += classNList[i] + \" \";\r\n            }\r\n            d3.select(this).attr(\"class\", classN);\r\n          }\r\n        })\r\n    },\r\n    transformGraphSvg(flag) {\r\n      const _this = this;\r\n      let groups = _this.groupsSvg;\r\n\r\n      let scalePre = _this.graphSvgScale;\r\n\r\n      let margin = _this.margin;\r\n      if (flag == 'left') {\r\n        _this.graphGTransformX += 10;\r\n      }\r\n      if (flag == 'right') {\r\n        _this.graphGTransformX -= 10;\r\n      }\r\n      // groups.attr('transform', 'translate(' + (_this.graphGTransformX) + ',' + (margin.top) + ') scale(' + (scalePre) + ')')\r\n    },\r\n    updataAssistGraphPanel() {\r\n      const _this = this;\r\n      var content = this.groupsSvg.html();\r\n      let height = document.getElementById(\"assistGraphPanel\").clientHeight;\r\n      let width = document.getElementById(\"assistGraphPanel\").clientWidth;\r\n      d3.select('#assistGraphPanel').select('svg').remove();\r\n      let transX = _this.assistGTransformX;\r\n      let transY = _this.assistGTransformY;\r\n      var div = d3.select('#assistGraphPanel')\r\n        .append('svg')\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n        .append(\"g\")\r\n        .attr(\"transform\", `translate(${transX},${transY})`)\r\n        .html(content);\r\n    },\r\n    moveGraphLeft(e) {\r\n      const _this = this;\r\n      _this.moveFlag == true;\r\n      clearInterval(this.moveTimer)// \r\n      this.moveTimer = setInterval(() => { _this.transformGraphSvg(\"left\") }, 10)//_this.transformGraphSvg('left'), 100);\r\n    },\r\n    moveGraphRight(e) {\r\n      const _this = this;\r\n      // console.log(\"\",e)\r\n      clearInterval(this.moveTimer)// \r\n      _this.moveFlag == true;\r\n      this.moveTimer = setInterval(() => { _this.transformGraphSvg(\"right\") }, 10)//_this.transformGraphSvg('left'), 100);\r\n    },\r\n    leaveGraphMove() {\r\n      // this.moveFlag == false;\r\n      clearInterval(this.moveTimer)// \r\n      // this.graphGTransformX = 0;\r\n    },\r\n    updataGraph() {\r\n      var _this = this;\r\n      let margin = _this.margin\r\n      let width = _this.$refs.graphDiv.offsetWidth - margin.left - margin.right;\r\n      let height = document.getElementById(\"graphPanel\").clientHeight - margin.top - margin.bottom;\r\n      let heightTimeAxis = document.getElementById(\"graphTimeAxisPanel\").clientHeight - margin.top - margin.bottom;\r\n      _this.width = width;\r\n      _this.height = height;\r\n      d3.select(\"#graphPanel\").select(\"svg\").remove()\r\n      var svg = d3.select(\"#graphPanel\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      _this.rootSvg = svg;\r\n      d3.select(\"#graphTimeAxisPanel\").select(\"svg\").remove()\r\n      var TimeAxisSvg = d3.select(\"#graphTimeAxisPanel\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      _this.TimeAxisSvg = TimeAxisSvg;\r\n      let data = _this.data;\r\n\r\n      let maxDImportance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let minDImportance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let maxDRelevance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let minDRelevance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let maxDDuration = Math.max.apply(Math, data.map(function (d) { return tools.time2seconds(d['time'][1]) - tools.time2seconds(d['time'][0]); }))\r\n      let maxTotalDuration = Math.max.apply(Math, data.map(function (d) { return d['totalDuration']; }))\r\n      _this.drawEntityLocation = [];\r\n      _this.minDImportance = minDImportance;\r\n      _this.maxDImportance = maxDImportance;\r\n      _this.minDRelevance = minDRelevance;\r\n      _this.maxDRelevance = maxDRelevance;\r\n      _this.maxDDuration = maxDDuration;\r\n      _this.maxTotalDuration = maxTotalDuration;\r\n\r\n      let currentMaxColor = _this.importanceMaxColor;\r\n      let currentMinColor = _this.importanceMinColor;\r\n      _this.importanceColor_linear = d3.scaleLinear().domain([minDImportance, maxDImportance]).range([0, 1]);\r\n      _this.importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n      _this.relevanceScale_linear = d3.scaleLinear([minDRelevance, maxDRelevance], [20, 50])\r\n      _this.totalDurationScale_linear = d3.scaleLinear().domain([0, maxTotalDuration]).range([20, 60]);\r\n\r\n      _this.drawMain(svg);\r\n      // });\r\n    },\r\n    zoomInLayoutClk() {\r\n      const _this = this;\r\n      _this.layoutShow += 1;\r\n      if (_this.layoutShow > 3) {\r\n        _this.layoutShow = 3;\r\n      }\r\n      // _this.updataGraph();\r\n    },\r\n    recognize0:async()=>{\r\n      // let worker = _this.worker;\r\n      console.log(worker)\r\n      await worker.loadLanguage('eng_sim');\r\n      await worker.initialize('eng_sim', OEM.LSTM_ONLY);\r\n      await worker.setParameters({\r\n        tessedit_pageseg_mode: PSM.SINGLE_BLOCK,\r\n      });\r\n\r\n    },\r\n    zoomOutLayoutClk() {\r\n      const _this = this;\r\n      _this.layoutShow -= 1;\r\n      if (_this.layoutShow < 0) {\r\n        _this.layoutShow = 0;\r\n      }\r\n      // _this.updataGraph();\r\n\r\n    },\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n  },\r\n  created() {\r\n    var _this = this;\r\n    let margin = _this.margin\r\n    this.$nextTick(() => {\r\n      // _this.scheduler = createScheduler();\r\n      //  scheduler.addWorker(_this.worker);\r\n      _this.updataGraph();\r\n      _this.updataAssistGraphPanel();\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this;\r\n    let width = _this.$refs.graphDiv.offsetWidth;\r\n    let height = _this.height;\r\n    let showEntityList = tools.deepClone(_this.data);\r\n    for (let e in showEntityList) {\r\n      showEntityList[e]['show'] = true;\r\n    }\r\n      // worker \r\n    _this.showEntityList = showEntityList;\r\n    // let width = _this.width;\r\n    this.$bus.$on('graphData', (val) => {\r\n      _this.data = val;\r\n      let showEntityList = tools.deepClone(_this.data);\r\n      for (let e in showEntityList) {\r\n        showEntityList[e]['show'] = true;\r\n      }\r\n      _this.showEntityList = showEntityList;\r\n      _this.updataGraph();\r\n    });\r\n    this.$bus.$on('switchL', (val) => {\r\n      _this.switchL = val;\r\n    });\r\n\r\n    // this.$refs.moveGraphLeft.addEventListener(\"mouseover\", _this.moveGraphLeft); // \r\n    // this.$refs.moveGraphRight.addEventListener(\"mousemove\", _this.moveGraphRight); // \r\n    // this.$refs.moveGraphLeft.addEventListener(\"mouseleave\", _this.leaveGraphMove); // \r\n    // this.$refs.moveGraphRight.addEventListener(\"mouseleave\", _this.leaveGraphMove); // \r\n\r\n  },\r\n  beforeDestroy() {\r\n    clearInterval(this.moveTimer);\r\n  },\r\n} \r\n</script>\r\n\r\n<style>@import './index.css';</style>\r\n"]}]}