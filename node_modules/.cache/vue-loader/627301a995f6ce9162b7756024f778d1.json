{"remainingRequest":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\Graph\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\src\\components\\Graph\\index.vue","mtime":1689080246944},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\babel-loader\\lib\\index.js","mtime":1688115046651},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1688115046166},{"path":"D:\\Cailibuhong\\video2Graph\\video2Graph\\node_modules\\vue-loader\\lib\\index.js","mtime":1688115046800}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycNCmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSAndnVlJzsNCmltcG9ydCBmaWxlbmFtZXMgZnJvbSAiQC91dGlscy9maWxlTmFtZSI7DQppbXBvcnQgZG9tdG9pbWFnZSBmcm9tICdkb20tdG8taW1hZ2UnOw0KaW1wb3J0IFRlc3RKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTJfZmluLmpzb24iOw0KaW1wb3J0IFRlc3RSZWxKc29uIGZyb20gIkAvYXNzZXRzL2pzb24vY2FzZTJfZmluX3JlbC5qc29uIjsNCmltcG9ydCB0b29scyBmcm9tICJAL3V0aWxzL3Rvb2xzLmpzIjsNCg0KZXhwb3J0IGRlZmF1bHQgew0KICBwcm9wczogWyJ2aWRlb1RpbWUiXSwNCiAgZGF0YSgpIHsNCiAgICByZXR1cm4gew0KICAgICAgZGF0YTogVGVzdEpzb24sDQogICAgICBnRGF0YTogIlRlc3RKc29uIiwNCiAgICAgIHJlbERhdGE6IFRlc3RSZWxKc29uLA0KICAgICAgYXNzaXN0R1RyYW5zZm9ybVg6IDEwLA0KICAgICAgYXNzaXN0R1RyYW5zZm9ybVk6IDEwMCwNCiAgICAgIGRyYXdFbnRpdHlMb2NhdGlvbjogW10sDQogICAgICBzaG93RW50aXR5TGlzdDogW10sDQogICAgICBvdmVyRW50aXR5SWQ6JycsDQogICAgICBzaG93RW50aXR5UmVsSWRMaXN0OiBbXSwNCiAgICAgIHNob3dFbnRpdHlSZWxJZE92ZXJTdGF0ZTogJycsDQogICAgICByb290RW50aXR5TGlzdDogW10sDQogICAgICByb290U3ZnOiBudWxsLA0KICAgICAgVGltZUF4aXNTdmc6IG51bGwsDQogICAgICBncm91cHNTdmc6IG51bGwsDQogICAgICBhcmNHOiBudWxsLA0KICAgICAgY3VyRW50SWQ6ICcnLA0KICAgICAgbWluREltcG9ydGFuY2U6IDAsDQogICAgICBtYXhESW1wb3J0YW5jZTogMCwNCiAgICAgIG1pbkRSZWxldmFuY2U6IDAsDQogICAgICBtYXhEUmVsZXZhbmNlOiAwLA0KICAgICAgbWF4RER1cmF0aW9uOiAwLA0KICAgICAgdGltZUF4aXNYOiAwLA0KICAgICAgdGltZUF4aXNXOiAyMDAsDQogICAgICB0aW1lQXhpc0Ryb3BGbGFnOiAwLA0KICAgICAgdGltZUF4aXNEb3duWDogMCwNCiAgICAgIHRpbWVBeGlzRG93blc6IDYwLA0KICAgICAgbWF4VG90YWxEdXJhdGlvbjogMCwNCiAgICAgIHZpZGVvRHVyYXRpb246IDY3MiwNCiAgICAgIHRvdGFsRHVyYXRpb246IDEwMDAsDQogICAgICBpbXBvcnRhbmNlQ29sb3JfbGluZWFyOiBudWxsLA0KICAgICAgaW1wb3J0YW5jZUNvbXB1dGVfY29sb3I6IG51bGwsDQogICAgICByZWxldmFuY2VTY2FsZV9saW5lYXI6IG51bGwsDQogICAgICB0b3RhbER1cmF0aW9uU2NhbGVfbGluZWFyOiBudWxsLA0KICAgICAgc3VtVG90YWxEdXJhdGlvbjogMCwNCiAgICAgIC8vIGltcG9ydGFuY2VNaW5Db2xvcjogInJnYigxLCAxNjQsIDE4MykiLA0KICAgICAgLy8gaW1wb3J0YW5jZU1heENvbG9yOiAicmdiKDEwNiwgNTIsIDEyNykiLA0KICAgICAgem9vbUluVXJsOiByZXF1aXJlKCJAL2Fzc2V0cy9pbWcvem9vbUluLnBuZyIpLA0KICAgICAgem9vbU91dFVybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL3pvb21PdXQucG5nIiksDQogICAgICBlZGl0VG9vbFVybDogcmVxdWlyZSgiQC9hc3NldHMvaW1nL2VkaXQucG5nIiksDQogICAgICBsYXlvdXRTaG93OiAyLA0KICAgICAgZ3JhcGhHVHJhbnNmb3JtSzogMSwNCiAgICAgIGdyYXBoR1RyYW5zZm9ybVg6IDEwLA0KICAgICAgZ3JhcGhHVHJhbnNmb3JtWTogMTAwLA0KICAgICAgZ3JhcGhHTW92ZVg6IDEwLA0KICAgICAgZ3JhcGhTdmdTY2FsZTogMSwNCiAgICAgIG1vdmVUaW1lcjogbnVsbCwNCiAgICAgIG1vdmVGbGFnOiBmYWxzZSwNCiAgICAgIGltcG9ydGFuY2VNaW5Db2xvcjogInJnYigyMDMsIDIzMCwgMjA5KSIsDQogICAgICBpbXBvcnRhbmNlTWF4Q29sb3I6ICJyZ2IoMjIsIDE0NCwgMjA3KSIsDQogICAgICBzdGVwWDogMTUwLA0KICAgICAgc3RlcFk6IDEwMCwNCiAgICAgIGNpcmNsZUludGVydmFsOiA1NSwNCiAgICAgIHdpZHRoOiAwLA0KICAgICAgaGVpZ2h0OiAwLA0KICAgICAgY3VyVG9vbFN0YXRlOiAndW5FZGl0JywNCiAgICAgIG1hcmdpbjogeyB0b3A6IDgwLCByaWdodDogMjAsIGJvdHRvbTogMCwgbGVmdDogMjAgfSwNCiAgICAgIGNvbG9yOiBbDQogICAgICAgICJyZ2IoMjU1LDYwLDYwKSIsDQogICAgICAgICJyZ2IoMCwgMTc4LCAxNzEpIiwNCiAgICAgICAgLy8gInJnYigyNTUsODMsMjU1KSIsDQogICAgICAgICJyZ2IoMjM1LDEzNSwxNjIpIiwNCiAgICAgICAgInJnYigyNTUsMTc4LDEwMSkiLA0KICAgICAgICAicmdiKDYzLDE1MSwxMzQpIiwNCiAgICAgICAgInJnYig4MywyNTUsMjU1KSIsDQogICAgICAgICJyZ2IoMCwxMjIsMjQ0KSIsDQogICAgICAgICJyZ2IoMTY4LDE2OCwyNTUpIiwNCiAgICAgICAgInJnYigyMDAsMjAwLDIwMCkiLA0KICAgICAgXSwNCiAgICAgIG1jb2xvcjogWw0KICAgICAgICAicmdiKDEyNSwgNjYsIDIwNikiLA0KICAgICAgICAicmdiKDI0OCwgMTM0LCAxMjQpIiwNCiAgICAgICAgInJnYig1MCwgMTk4LCAxOTEpIiwNCiAgICAgICAgInJnYigxMzUsIDEyNiwgMjUzKSIsDQogICAgICAgICJyZ2IoMTk4LCAxMjEsIDEyMykiLA0KICAgICAgICAicmdiKDI1MiwgMTc3LCA0OSkiLA0KICAgICAgICAicmdiKDExMiwgMjAyLCAyMjkpIiwNCiAgICAgIF0sDQogICAgICAvLyBtY29sb3I6IFsNCiAgICAgIC8vICAgInJnYig5MSwgMTA3LCAyNTUpIiwNCiAgICAgIC8vICAgInJnYigwLCAxNzgsIDE3MSkiLA0KICAgICAgLy8gICAvLyAicmdiKDYsIDIxNCwgMTYwKSIsDQogICAgICAvLyAgICJyZ2IoMjU1LCAxMjAsIDkwKSIsDQogICAgICAvLyAgICJyZ2IoMTI1LCA5OCwgMjExKSIsDQogICAgICAvLyAgICJyZ2IoMjU1LCAxMTMsIDIxMikiLA0KICAgICAgLy8gICAicmdiKDExMiwgMjE0LCAyNTUpIiwNCiAgICAgIC8vICAgInJnYigyNTUsIDE1OSwgMjgpIiwNCiAgICAgIC8vICAgInJnYigyNTUsIDc3LCAxMDkpIiwNCiAgICAgIC8vIF0sDQogICAgICBtRGFya2NvbG9yOiBbDQogICAgICAgICJyZ2IoOTUsIDM5LCAxNzkpIiwNCiAgICAgICAgInJnYigyMjEsIDgzLCA3MikiLA0KICAgICAgICAicmdiKDAsIDE1OCwgMTQ4KSIsDQogICAgICAgICJyZ2IoOTMsIDg4LCAyMDIpIiwNCiAgICAgICAgInJnYigxODAsIDcyLCA3OSkiLA0KICAgICAgICAicmdiKDIwMiwgMTM0LCAzMikiLA0KICAgICAgICAicmdiKDQ2LCAxNzQsIDIwMikiLA0KICAgICAgXSwNCiAgICAgIG1MaWdudGNvbG9yOiBbDQogICAgICAgICIjZmY5YzljIiwNCiAgICAgICAgIiNjYzg4YjAiLA0KICAgICAgICAiI2ZmYThmZiIsDQogICAgICAgICIjZTNiMDk3IiwNCiAgICAgICAgIiNmNGMzZDAiLA0KICAgICAgICAiI2Y0ZjRkMCIsDQogICAgICAgICIjZmZkOGIxIiwNCiAgICAgICAgIiM5ZWNhYzIiLA0KICAgICAgICAiI2E4Y2NmZiIsDQogICAgICAgICIjOTdlM2JhIiwNCiAgICAgICAgIiM2ZjhiZTAiLA0KICAgICAgICAicmdiKDAsMTIyLDI0NCkiLA0KICAgICAgICAiI2I2YTJmNyIsDQogICAgICAgICJyZ2IoMTY4LDE2OCwyNTUpIiwNCiAgICAgICAgInJnYigyMDAsMjAwLDIwMCkiLA0KICAgICAgXSwNCiAgICB9Ow0KICB9LA0KDQogIHdhdGNoOiB7DQogICAgdHlwZSh2YWwpIHsNCiAgICB9LA0KICAgIHRpbWVBeGlzWCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLnVwZGF0YVRpbWVBeGlzRHVyKF90aGlzLlRpbWVBeGlzU3ZnLCBfdGhpcy50aW1lQXhpc1gsIF90aGlzLnRpbWVBeGlzVyk7DQogICAgfSwNCiAgICBjdXJFbnRJZCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLm92ZXJFbnRpdHlJZCA9IHZhbDsNCiAgICAgIF90aGlzLiRidXMuJGVtaXQoInNlbGVjdEVudCIsIHZhbCk7DQogICAgICBsZXQgZW50aXR5TG9jYXRpb25EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KDQogICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICBsZXQgc2hvd0phZ2VEYXRhID0gX3RoaXMuc2hvd0VudGl0eUxpc3Q7DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBiYXNpY1JlbC5sZW5ndGg7IHIrKykgew0KICAgICAgICBsZXQgc29yY2VJZCA9IGJhc2ljUmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyXVsxXTsNCiAgICAgICAgbGV0IHNvcmNlSmFnZSA9IHNob3dKYWdlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNvcmNlSWQgfSlbJ3Nob3cnXTsNCiAgICAgICAgbGV0IHRhcmdldEphZ2UgPSBzaG93SmFnZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSB0YXJnZXRJZCB9KVsnc2hvdyddOw0KICAgICAgICBpZiAoc29yY2VKYWdlICYmIHRhcmdldEphZ2UpIHsNCiAgICAgICAgICBsZXQgdHJuSWQgPSAnLTEnOw0KICAgICAgICAgIGlmIChzb3JjZUlkID09IHBhcnNlSW50KHZhbCkpIHsNCiAgICAgICAgICAgIHRybklkID0gdGFyZ2V0SWQ7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKHRhcmdldElkID09IHBhcnNlSW50KHZhbCkpIHsNCiAgICAgICAgICAgIHRybklkID0gc29yY2VJZDsNCiAgICAgICAgICB9DQogICAgICAgICAgaWYgKHRybklkICE9ICctMScpIHsNCiAgICAgICAgICAgIGxldCBjdXJFbnQgPSBlbnRpdHlMb2NhdGlvbkRhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcGFyc2VJbnQoZFsnaWQnXSkgPT0gdHJuSWQgfSk7DQogICAgICAgICAgICBfdGhpcy5hc3Npc3RHVHJhbnNmb3JtWCA9IHBhcnNlSW50KC1jdXJFbnRbJ3gnXSkgKyBwYXJzZUZsb2F0KGN1ckVudFsnciddKSArIDE1MDsNCiAgICAgICAgICAgIF90aGlzLmFzc2lzdEdUcmFuc2Zvcm1ZID0gcGFyc2VJbnQoLWN1ckVudFsneSddKSArIHBhcnNlRmxvYXQoY3VyRW50WydyJ10pICsgMzAwOw0KICAgICAgICAgICAgX3RoaXMudXBkYXRhQXNzaXN0R3JhcGhQYW5lbCgpOw0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KDQogICAgICB9Ow0KICAgICAgbGV0IHNpbWlsYXJpdHlSZWwgPSByZWxEYXRhWydzaW1pbGFyaXR5UmVsJ107DQogICAgICBmb3IgKGxldCByID0gMDsgciA8IHNpbWlsYXJpdHlSZWwubGVuZ3RoOyByKyspIHsNCiAgICAgICAgbGV0IHNvcmNlSWQgPSBzaW1pbGFyaXR5UmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBzaW1pbGFyaXR5UmVsW3JdWzFdOw0KICAgICAgICBsZXQgc29yY2VKYWdlID0gc2hvd0phZ2VEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KVsnc2hvdyddOw0KICAgICAgICBsZXQgdGFyZ2V0SmFnZSA9IHNob3dKYWdlRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pWydzaG93J107DQogICAgICAgIGlmIChzb3JjZUphZ2UgJiYgdGFyZ2V0SmFnZSkgew0KICAgICAgICAgIGxldCB0cm5JZCA9ICctMSc7DQogICAgICAgICAgaWYgKHNvcmNlSWQgPT0gcGFyc2VJbnQodmFsKSkgew0KICAgICAgICAgICAgdHJuSWQgPSB0YXJnZXRJZDsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAodGFyZ2V0SWQgPT0gcGFyc2VJbnQodmFsKSkgew0KICAgICAgICAgICAgdHJuSWQgPSBzb3JjZUlkOw0KICAgICAgICAgIH0NCiAgICAgICAgICBpZiAodHJuSWQgIT0gJy0xJykgew0KICAgICAgICAgICAgbGV0IGN1ckVudCA9IGVudGl0eUxvY2F0aW9uRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBwYXJzZUludChkWydpZCddKSA9PSB0cm5JZCB9KTsNCiAgICAgICAgICAgIF90aGlzLmFzc2lzdEdUcmFuc2Zvcm1YID0gcGFyc2VJbnQoLWN1ckVudFsneCddKSArIHBhcnNlRmxvYXQoY3VyRW50WydyJ10pICsgMTUwOw0KICAgICAgICAgICAgX3RoaXMuYXNzaXN0R1RyYW5zZm9ybVkgPSBwYXJzZUludCgtY3VyRW50Wyd5J10pICsgcGFyc2VGbG9hdChjdXJFbnRbJ3InXSkgKyAzMDA7DQogICAgICAgICAgICBfdGhpcy51cGRhdGFBc3Npc3RHcmFwaFBhbmVsKCk7DQogICAgICAgICAgfQ0KICAgICAgICB9DQoNCiAgICAgIH07DQoNCg0KICAgIH0sDQogICAgb3ZlckVudGl0eUlkKHZhbCl7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICANCiAgICAgIGxldCByZWxMaXN0ID0gW107DQogICAgICBsZXQgcmVsUm9vdExpc3QgPSBbXTsNCiAgICAgIGxldCByZWxEYXRhID0gX3RoaXMucmVsRGF0YTsNCiAgICAgIGxldCBvRGF0YSA9IF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbjsNCiAgICAgIGxldCBiYXNpY1JlbCA9IHJlbERhdGFbJ2Jhc2ljUmVsJ107DQogICAgICBkMy5zZWxlY3RBbGwoJy50aW1lQXhpc0VudCcpLmF0dHIoInN0cm9rZS13aWR0aCIsMCkuYXR0cigib3BhY2l0eSIsMC40KS5hdHRyKCJzdHJva2UiLGZ1bmN0aW9uKCl7DQogICAgICAgIGxldCBjaWQgPSBkMy5zZWxlY3QodGhpcykuYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdOw0KICAgICAgICBsZXQgbmQgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGNpZCB9KTsNCiAgICAgICAgY29uc29sZS5sb2coMjIyMixuZCkNCiAgICAgICAgcmV0dXJuIG5kWydjb2xvckQnXQ0KICAgICAgfSk7DQogICAgICBmb3IgKGxldCByZSA9IDA7IHJlIDwgYmFzaWNSZWwubGVuZ3RoOyByZSsrKSB7DQoNCiAgICAgICAgbGV0IHNvcmNlSWQgPSBiYXNpY1JlbFtyZV1bMF07DQogICAgICAgIGxldCB0YXJnZXRJZCA9IGJhc2ljUmVsW3JlXVsxXTsNCiAgICAgICAgbGV0IGNOb2RlID0gJyc7DQogICAgICAgIGlmIChzb3JjZUlkID09IHZhbCkgew0KICAgICAgICAgIGNOb2RlID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSB0YXJnZXRJZCB9KTsNCiAgICAgICAgICByZWxMaXN0LnB1c2godGFyZ2V0SWQpOw0KICAgICAgICAgIHJlbFJvb3RMaXN0LnB1c2goY05vZGVbJ3Jvb3RJbmRleCddKTsNCiAgICAgICAgfQ0KDQogICAgICAgIGlmICh0YXJnZXRJZCA9PSB2YWwpIHsNCiAgICAgICAgICBjTm9kZSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KTsNCiAgICAgICAgICByZWxMaXN0LnB1c2goc29yY2VJZCk7DQogICAgICAgICAgcmVsUm9vdExpc3QucHVzaChjTm9kZVsncm9vdEluZGV4J10pOw0KICAgICAgICB9DQogICAgICB9Ow0KICAgICAgY29uc29sZS5sb2coMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMSxyZWxMaXN0KTsNCiAgICAgIHJlbExpc3QuZm9yRWFjaCgoc2VsZiwgaW5keCwgYXJyKSA9PiB7DQoNCiAgICAgICAgZDMuc2VsZWN0KGAjdGltZUF4aXNFbnRfJHtzZWxmfWApLmF0dHIoInN0cm9rZSIsJ3doaXRlJykuYXR0cigic3Ryb2tlLXdpZHRoIiwyKS5hdHRyKCJvcGFjaXR5IiwxKTsNCiAgICAgIH0pDQogICAgICAgIGQzLnNlbGVjdChgI3RpbWVBeGlzRW50XyR7dmFsfWApLmF0dHIoInN0cm9rZS13aWR0aCIsMikuYXR0cigib3BhY2l0eSIsMSk7DQogICAgfSwNCiAgICBzaG93RW50aXR5UmVsSWRMaXN0KHZhbCl7DQogICAgICB0aGlzLnVwZGF0YVJlbCgpOw0KICAgIH0sDQogICAgZ3JvdXBzU3ZnOiB7DQogICAgICBkZWVwOiB0cnVlLA0KICAgICAgaGFuZGxlcigpIHsNCiAgICAgICAgdGhpcy51cGRhdGFBc3Npc3RHcmFwaFBhbmVsKCk7DQogICAgICB9DQogICAgfSwNCiAgICBnRGF0YSh2YWwpIHsNCiAgICB9LA0KICAgIGxheW91dFNob3codmFsKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgc2hvd0VudGl0eUxpc3QgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuZGF0YSk7DQogICAgICBmb3IgKGxldCBlIGluIHNob3dFbnRpdHlMaXN0KSB7DQogICAgICAgIGlmIChwYXJzZUludChzaG93RW50aXR5TGlzdFtlXVsnbGF5b3V0J10pIDwgcGFyc2VJbnQodmFsKSkNCiAgICAgICAgICBzaG93RW50aXR5TGlzdFtlXVsnc2hvdyddID0gdHJ1ZTsNCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgc2hvd0VudGl0eUxpc3RbZV1bJ3Nob3cnXSA9IGZhbHNlOw0KICAgICAgICB9DQogICAgICB9DQogICAgICBfdGhpcy5zaG93RW50aXR5TGlzdCA9IHNob3dFbnRpdHlMaXN0Ow0KICAgICAgX3RoaXMudXBkYXRhR3JhcGgoKTsNCiAgICB9LA0KICAgIGRhdGEodmFsKSB7DQogICAgfSwNCiAgICB2aWRlb1RpbWUodmFsKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZW50aXR5TG9jYXRpb25EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBlbnRpdHlMb2NhdGlvbkRhdGEubGVuZ3RoOyBlKyspIHsNCiAgICAgICAgbGV0IGN1ckQgPSBlbnRpdHlMb2NhdGlvbkRhdGFbZV07DQogICAgICAgIGxldCB0aW1lU3RhcnQgPSB0b29scy50aW1lMnNlY29uZHMoZW50aXR5TG9jYXRpb25EYXRhW2VdWyd0aW1lJ11bMF0pOw0KICAgICAgICBsZXQgdGltZUVuZCA9IHRvb2xzLnRpbWUyc2Vjb25kcyhlbnRpdHlMb2NhdGlvbkRhdGFbZV1bJ3RpbWUnXVsxXSk7DQogICAgICAgIGlmICgodmFsID4gdGltZVN0YXJ0KSAmJiAodmFsIDwgdGltZUVuZCkpIHsNCiAgICAgICAgICBsZXQgZW50WCA9IGVudGl0eUxvY2F0aW9uRGF0YVtlXVsneCddOw0KICAgICAgICAgIGxldCBlbnRZID0gZW50aXR5TG9jYXRpb25EYXRhW2VdWyd5J107DQogICAgICAgICAgbGV0IGVudFIgPSBlbnRpdHlMb2NhdGlvbkRhdGFbZV1bJ3InXTsNCiAgICAgICAgICBsZXQgbW92ZUxpbmVhciA9IGQzLnNjYWxlTGluZWFyKFt0aW1lU3RhcnQsIHRpbWVFbmRdLCBbZW50WCAtIGVudFIsIGVudFggKyBlbnRSXSkNCiAgICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YID0gLW1vdmVMaW5lYXIoKHZhbCkpOw0KICAgICAgICB9DQogICAgICB9DQogICAgfSwNCiAgICBncmFwaEdNb3ZlWCh2YWwpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGNvbnNvbGUubG9nKHZhbCk7DQogICAgICBsZXQgZGF0YSA9IF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbjsNCiAgICAgIGxldCBzdGpnID0gMDsNCiAgICAgIGxldCBlbmpnID0gMDsNCiAgICAgIGxldCBzbm9kZSA9ICcnOw0KICAgICAgbGV0IGVub2RlID0gJyc7DQogICAgICBsZXQgd2lkdGggPSAxNTkwDQogICAgICBkYXRhLmZvckVhY2goKHNlbGYsIGluZHgsIGFycikgPT4gew0KICAgICAgICBsZXQgZW50eCA9IHNlbGZbJ3gnXSAqIF90aGlzLmdyYXBoR1RyYW5zZm9ybUs7DQogICAgICAgIGxldCB0cmFuc2Zvcm1YID0gZW50eCArIHZhbDsNCiAgICAgICAgaWYgKCh0cmFuc2Zvcm1YID4gMCkgJiYgKHRyYW5zZm9ybVggPCB3aWR0aCkpIHsNCiAgICAgICAgICBzdGpnKys7DQogICAgICAgIH0NCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgaWYgKChzdGpnID4gMCkgJiYgZW5qZyA9PSAwKSB7DQogICAgICAgICAgICBlbm9kZSA9IHNlbGY7DQogICAgICAgICAgICBlbmpnID0gMQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICBpZiAoc3RqZyA9PSAxKSB7DQogICAgICAgICAgc25vZGUgPSBzZWxmDQogICAgICAgIH0NCiAgICAgIH0pDQogICAgICBsZXQgZXcgPSBlbm9kZVsndGltZVcnXTsNCiAgICAgIGlmKHNub2RlID09ICcnKXsNCiAgICAgICAgX3RoaXMudGltZUF4aXNYID0wDQogICAgICB9DQogICAgICBlbHNlDQogICAgICBfdGhpcy50aW1lQXhpc1ggPSBzbm9kZVsndGltZVgnXTsNCiAgICAgIF90aGlzLnRpbWVBeGlzVyA9IGVub2RlWyd0aW1lWCddIC0gc25vZGVbJ3RpbWVYJ10gKyBlbm9kZVsndGltZVcnXQ0KICAgICAgaWYoZXc9PXVuZGVmaW5lZCl7DQogICAgICAgIF90aGlzLnRpbWVBeGlzVyA9IHdpZHRoIC0gc25vZGVbJ3RpbWVYJ10NCiAgICAgIH0NCiAgICB9LA0KICAgIGdyYXBoR1RyYW5zZm9ybVgodmFsKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgZ3JvdXBzID0gX3RoaXMuZ3JvdXBzU3ZnOw0KICAgICAgX3RoaXMuZ3JhcGhHTW92ZVggPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVggPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVkgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybUsgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LOw0KICAgICAgZ3JvdXBzLmF0dHIoInRyYW5zZm9ybSIsICJ0cmFuc2xhdGUoIiArIGdyYXBoR1RyYW5zZm9ybVggKyAnLCcgKyBncmFwaEdUcmFuc2Zvcm1ZICsgIikgc2NhbGUoIiArIGdyYXBoR1RyYW5zZm9ybUsgKyAiKSIpOw0KICAgIH0NCiAgfSwNCiAgbWV0aG9kczogew0KICAgIGVkaXRUb29sQ2xrKCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgaWYgKF90aGlzLmN1clRvb2xTdGF0ZSA9PSAnZWRpdCcpIF90aGlzLmN1clRvb2xTdGF0ZSA9ICd1bkVkaXQnOw0KICAgICAgZWxzZSBpZiAoX3RoaXMuY3VyVG9vbFN0YXRlICE9ICdlZGl0JykgX3RoaXMuY3VyVG9vbFN0YXRlID0gJ2VkaXQnOw0KICAgICAgdGhpcy4kZW1pdCgidG9vbFN0YXRlIiwgdGhpcy5jdXJUb29sU3RhdGUpOw0KICAgIH0sDQogICAgdXBkYXRhUmVsKCl7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICBsZXQgb0RhdGEgPSBfdGhpcy5kcmF3RW50aXR5TG9jYXRpb247DQogICAgICBsZXQgc2hvd0phZ2VEYXRhID0gX3RoaXMuc2hvd0VudGl0eUxpc3Q7DQogICAgICBsZXQgc2hvd1JlbCA9IF90aGlzLnNob3dFbnRpdHlSZWxJZExpc3Q7DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBiYXNpY1JlbC5sZW5ndGg7IHIrKykgew0KICAgICAgICBsZXQgc29yY2VJZCA9IGJhc2ljUmVsW3JdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyXVsxXTsNCiAgICAgICAgbGV0IGlkTiA9ICJiYXNpY1JlbCIgKyBzb3JjZUlkICsgIl8iICsgdGFyZ2V0SWQ7DQogICAgICAgIGNvbnNvbGUubG9nKHNvcmNlSWQsc2hvd1JlbCxzaG93UmVsLmluY2x1ZGVzKHNvcmNlSWQpKQ0KICAgICAgICBpZigoc2hvd1JlbC5pbmNsdWRlcyhzb3JjZUlkKSl8fChzaG93UmVsLmluY2x1ZGVzKHRhcmdldElkKSkpew0KICAgICAgICAgIGQzLnNlbGVjdChgIyR7aWROfWApLmF0dHIoJ29wYWNpdHknLDEpLmF0dHIoJ3N0cm9rZScsJ2RhcmtzbGF0ZWJsdWUnKQ0KICAgICAgICB9DQogICAgICAgIGVsc2V7DQogICAgICAgICAgZDMuc2VsZWN0KGAjJHtpZE59YCkuYXR0cignb3BhY2l0eScsMCkNCiAgICAgICAgICANCiAgICAgICAgfQ0KICAgICAgfTsNCiAgICB9LA0KICAgIGRyYXdSZWxhdGlvbnNoaXBMaW5lKHN2Zykgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHJlbERhdGEgPSBfdGhpcy5yZWxEYXRhOw0KICAgICAgbGV0IG9EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgbGV0IHNob3dKYWdlRGF0YSA9IF90aGlzLnNob3dFbnRpdHlMaXN0Ow0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGxldCBoZWlnaHQgPSBzdmcuYXR0cignaGVpZ2h0Jyk7DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBiYXNpY1JlbC5sZW5ndGg7IHIrKykgew0KDQogICAgICAgIGxldCBzb3JjZUlkID0gYmFzaWNSZWxbcl1bMF07DQogICAgICAgIGxldCB0YXJnZXRJZCA9IGJhc2ljUmVsW3JdWzFdOw0KICAgICAgICBsZXQgaWROID0gImJhc2ljUmVsIiArIHNvcmNlSWQgKyAiXyIgKyB0YXJnZXRJZDsNCiAgICAgICAgbGV0IGNsYXNzTiA9ICJiYXNpY1JlbCBzb3VyY2UiICsgc29yY2VJZCArICIgdGFyZ2V0IiArIHRhcmdldElkOw0KICAgICAgICBsZXQgc29yY2VOb2RlID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb3JjZUlkIH0pOw0KICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gdGFyZ2V0SWQgfSk7DQogICAgICAgIGxldCBzb3JjZUphZ2UgPSBzaG93SmFnZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb3JjZUlkIH0pWydzaG93J107DQogICAgICAgIGxldCB0YXJnZXRKYWdlID0gc2hvd0phZ2VEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gdGFyZ2V0SWQgfSlbJ3Nob3cnXTsNCiAgICAgICAgaWYgKHNvcmNlSmFnZSAmJiB0YXJnZXRKYWdlKSB7DQogICAgICAgICAgaWYgKHNvcmNlTm9kZVsneCddID4gdGFyZ2V0Tm9kZVsneCddKSB7DQogICAgICAgICAgICBsZXQgdHAgPSBzb3JjZU5vZGU7DQogICAgICAgICAgICBzb3JjZU5vZGUgPSB0YXJnZXROb2RlOw0KICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRwOw0KICAgICAgICAgIH0NCiAgICAgICAgICBjb25zdCBwYXRoID0gZDMucGF0aCgpOw0KDQogICAgICAgICAgbGV0IHN0YXJ0WCA9IHNvcmNlTm9kZVsneCddOw0KICAgICAgICAgIGxldCBlbmRYID0gdGFyZ2V0Tm9kZVsneCddOw0KICAgICAgICAgIGxldCBtaWRYID0gKHN0YXJ0WCArIGVuZFgpIC8gMjsNCiAgICAgICAgICBsZXQgZmxhZyA9ICgoc29yY2VOb2RlWydzb25GbGFnJ10pIHx8ICh0YXJnZXROb2RlWydzb25GbGFnJ10pKTsNCiAgICAgICAgICAvLyBpZigodGFyZ2V0Tm9kZVsnaWQnXSA9PSAiNCIpfHwoKHNvcmNlTm9kZVsnaWQnXT09IjEiKSYmKHRhcmdldE5vZGVbJ2lkJ109PSI2IikpfHwoKHNvcmNlTm9kZVsnaWQnXT09IjIiKSYmKHRhcmdldE5vZGVbJ2lkJ109PSI3IikpfHwoKHNvcmNlTm9kZVsnaWQnXT09IjMiKSYmKHRhcmdldE5vZGVbJ2lkJ109PSI4IikpKXsNCiAgICAgICAgICAvLyAgIGZsYWcgPSB0cnVlOw0KICAgICAgICAgIC8vIH0NCiAgICAgICAgICBpZiAodGFyZ2V0Tm9kZVsnaWQnXSA9PSAiNCIpIHsNCiAgICAgICAgICAgIGZsYWcgPSB0cnVlOw0KICAgICAgICAgIH0NCiAgICAgICAgICAvLyBpZih0YXJnZXROb2RlWydpZCddID09ICIzMCIpew0KICAgICAgICAgIC8vICAgZmxhZyA9IHRydWU7DQogICAgICAgICAgLy8gfQ0KICAgICAgICAgIGxldCByc291cmNlaW50ID0gKHNvcmNlTm9kZVsnc29uRmxhZyddKSA/ICgyMCkgOiAoMik7DQogICAgICAgICAgbGV0IHJ0YXJnZXRpbnQgPSAodGFyZ2V0Tm9kZVsnc29uRmxhZyddKSA/ICgyMCkgOiAoMik7DQogICAgICAgICAgbGV0IHN0YXJ0WSA9IChmbGFnKSA/IChzb3JjZU5vZGVbJ3knXSAtIHNvcmNlTm9kZVsnciddIC0gcnNvdXJjZWludCkgOiAoc29yY2VOb2RlWyd5J10gKyBzb3JjZU5vZGVbJ3InXSArIHJzb3VyY2VpbnQpOw0KICAgICAgICAgIGxldCBlbmRZID0gKGZsYWcpID8gKHRhcmdldE5vZGVbJ3knXSAtIHRhcmdldE5vZGVbJ3InXSAtIHJ0YXJnZXRpbnQpIDogKHRhcmdldE5vZGVbJ3knXSArIHRhcmdldE5vZGVbJ3InXSArIHJ0YXJnZXRpbnQpOw0KDQogICAgICAgICAgbGV0IGNueDEgPSBzdGFydFggLSA1MDsNCiAgICAgICAgICBsZXQgY254MiA9IGVuZFggKyA1MDsNCiAgICAgICAgICBsZXQgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7DQogICAgICAgICAgLy8gaWYoKChzb3JjZU5vZGVbJ2lkJ109PSIxIikmJih0YXJnZXROb2RlWydpZCddPT0iNiIpKXx8KChzb3JjZU5vZGVbJ2lkJ109PSIyIikmJih0YXJnZXROb2RlWydpZCddPT0iNyIpKXx8KChzb3JjZU5vZGVbJ2lkJ109PSIzIikmJih0YXJnZXROb2RlWydpZCddPT0iOCIpKSl7DQogICAgICAgICAgLy8gICBtaWRZLT0xNDANCiAgICAgICAgICAvLyB9DQogICAgICAgICAgbGV0IGggPSAoKChlbmRYIC0gc3RhcnRYKSAvIDUpID4gKHBhcnNlSW50KGhlaWdodCkgKyAxMDApKSA/IChwYXJzZUludChoZWlnaHQpICsgMTAwKSA6ICgoZW5kWCAtIHN0YXJ0WCkgLyA1KTsNCiAgICAgICAgICBsZXQgY255ID0gKGZsYWcpID8gKG1pZFkgLSBoKSA6IChtaWRZICsgaCk7DQoNCiAgICAgICAgICBsZXQgY255MSA9IGNueTsNCiAgICAgICAgICBsZXQgY255MiA9IGNueTsNCg0KICAgICAgICAgIGlmICgoKHNvcmNlTm9kZVsnbGF5b3V0J10gPT0gMikgJiYgKGNueSA8IDApKSB8fCAoKHNvcmNlTm9kZVsnbGF5b3V0J10gPT0gMCkgJiYgKGNueSA+IDApKSkgew0KICAgICAgICAgICAgY254MSAtPSAyNTA7DQogICAgICAgICAgICBjbnkxID0gY255ICogMS4zOw0KICAgICAgICAgIH0NCiAgICAgICAgICBpZiAoKCh0YXJnZXROb2RlWydsYXlvdXQnXSA9PSAyKSAmJiAoY255IDwgMCkpIHx8ICgodGFyZ2V0Tm9kZVsnbGF5b3V0J10gPT0gMCkgJiYgKGNueSA+IDApKSkgew0KICAgICAgICAgICAgY254MiArPSAyNTA7DQogICAgICAgICAgICBjbnkyID0gY255ICogMS4zOw0KICAgICAgICAgIH0NCiAgICAgICAgICAvLyBsZXQgbWlkUCA9IFsoc3RhcnRQWzBdK2VuZFBbMF0pLzIsKHN0YXJ0UFsxXSk+KGVuZFBbMV0pPyhzdGFydFBbMV0tMTAwKTooZW5kUFsxXS0xMDApXTsNCiAgICAgICAgICBwYXRoLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7DQogICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKG1pZFgsIGNueSwgbWlkWCwgY255LCBlbmRYLCBlbmRZKTsNCiAgICAgICAgICBfdGhpcy5kcmF3VGltZUxpbmUoc3ZnLCBwYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDUsICI5LDkiLCBpZE4sIGNsYXNzTik7DQogICAgICAgIH0NCg0KICAgICAgfTsNCiAgICAgIGxldCBzaW1pbGFyaXR5UmVsID0gcmVsRGF0YVsnc2ltaWxhcml0eVJlbCddOw0KICAgICAgLy8gbGV0IGJhc2ljUmVsID0gcmVsRGF0YVsnYmFzaWNSZWwnXTsNCiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgc2ltaWxhcml0eVJlbC5sZW5ndGg7IHIrKykgew0KDQogICAgICAgIGxldCBzb3JjZUlkID0gc2ltaWxhcml0eVJlbFtyXVswXTsNCiAgICAgICAgbGV0IHRhcmdldElkID0gc2ltaWxhcml0eVJlbFtyXVsxXTsNCg0KICAgICAgICBsZXQgaWROID0gInNpbWlsYXJpdHlSZWwiICsgc29yY2VJZCArICJfIiArIHRhcmdldElkOw0KDQogICAgICAgIGxldCBjbGFzc04gPSAic2ltaWxhcml0eVJlbCBzb3VyY2UiICsgc29yY2VJZCArICIgdGFyZ2V0IiArIHRhcmdldElkOw0KICAgICAgICBsZXQgc29yY2VOb2RlID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb3JjZUlkIH0pOw0KICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gdGFyZ2V0SWQgfSk7DQogICAgICAgIGxldCBzb3JjZUphZ2UgPSBzaG93SmFnZURhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb3JjZUlkIH0pWydzaG93J107DQogICAgICAgIGxldCB0YXJnZXRKYWdlID0gc2hvd0phZ2VEYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gdGFyZ2V0SWQgfSlbJ3Nob3cnXTsNCiAgICAgICAgaWYgKHNvcmNlSmFnZSAmJiB0YXJnZXRKYWdlKSB7DQoNCiAgICAgICAgICBpZiAoc29yY2VOb2RlWyd4J10gPiB0YXJnZXROb2RlWyd4J10pIHsNCiAgICAgICAgICAgIGxldCB0cCA9IHNvcmNlTm9kZTsNCiAgICAgICAgICAgIHNvcmNlTm9kZSA9IHRhcmdldE5vZGU7DQogICAgICAgICAgICB0YXJnZXROb2RlID0gdHA7DQogICAgICAgICAgfQ0KICAgICAgICAgIGNvbnN0IHBhdGggPSBkMy5wYXRoKCk7DQoNCiAgICAgICAgICBsZXQgc3RhcnRYID0gc29yY2VOb2RlWyd4J10gKyBzb3JjZU5vZGVbJ3InXSAvIDI7DQogICAgICAgICAgbGV0IGVuZFggPSB0YXJnZXROb2RlWyd4J10gLSB0YXJnZXROb2RlWydyJ10gLyAyOw0KICAgICAgICAgIGxldCBtaWRYID0gKHN0YXJ0WCArIGVuZFgpIC8gMjsNCiAgICAgICAgICBsZXQgZmxhZyA9ICgoc29yY2VOb2RlWydzb25GbGFnJ10pIHx8ICh0YXJnZXROb2RlWydzb25GbGFnJ10pKTsNCiAgICAgICAgICBsZXQgcnNvdXJjZWludCA9IChzb3JjZU5vZGVbJ3NvbkZsYWcnXSkgPyAoMjApIDogKDIpOw0KICAgICAgICAgIGxldCBydGFyZ2V0aW50ID0gKHRhcmdldE5vZGVbJ3NvbkZsYWcnXSkgPyAoMjApIDogKDIpOw0KICAgICAgICAgIGxldCBzdGFydFkgPSAoZmxhZykgPyAoc29yY2VOb2RlWyd5J10gLSBzb3JjZU5vZGVbJ3InXSAtIHJzb3VyY2VpbnQpIDogKHNvcmNlTm9kZVsneSddICsgc29yY2VOb2RlWydyJ10gKyByc291cmNlaW50KTsNCiAgICAgICAgICBsZXQgZW5kWSA9IChmbGFnKSA/ICh0YXJnZXROb2RlWyd5J10gLSB0YXJnZXROb2RlWydyJ10gLSBydGFyZ2V0aW50KSA6ICh0YXJnZXROb2RlWyd5J10gKyB0YXJnZXROb2RlWydyJ10gKyBydGFyZ2V0aW50KTsNCg0KICAgICAgICAgIGxldCBtaWRZID0gKHN0YXJ0WSArIGVuZFkpIC8gMjsNCg0KICAgICAgICAgIC8vIGxldCBoMVNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBfdGhpcy53aWR0aF0sIFsoc29yY2VOb2RlWyd5J10+dGFyZ2V0Tm9kZVsneSddKT8oc29yY2VOb2RlWyd5J10qMik6KHRhcmdldE5vZGVbJ3knXSoyKSxwYXJzZUludChoZWlnaHQpXSkNCiAgICAgICAgICBsZXQgaCA9ICgoKGVuZFggLSBzdGFydFgpIC8gMTQpID4gKHBhcnNlSW50KGhlaWdodCkgLSAxMCkpID8gKHBhcnNlSW50KGhlaWdodCkgLSAxMCkgOiAoKGVuZFggLSBzdGFydFgpIC8gMTQpOw0KICAgICAgICAgIGxldCBoU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIF90aGlzLndpZHRoIC8gMl0sIFswLCBoIC8gMyAqIDJdKQ0KICAgICAgICAgIGxldCBjbnkgPSAoZmxhZykgPyAobWlkWSAtIGhTY2FsZV9saW5lYXIoZW5kWCkpIDogKG1pZFkgKyBoU2NhbGVfbGluZWFyKGVuZFgpKTsNCiAgICAgICAgICBpZiAoc29yY2VOb2RlWydpZCddID09ICc3JykgeyBjbnkgLT0gMjAgfQ0KICAgICAgICAgIGlmIChjbnkgPCAtMTUwKSB7DQogICAgICAgICAgICBzdGFydFkgPSBzb3JjZU5vZGVbJ3knXSArIHNvcmNlTm9kZVsnciddICsgcnNvdXJjZWludA0KICAgICAgICAgICAgZW5kWSA9IHRhcmdldE5vZGVbJ3knXSArIHRhcmdldE5vZGVbJ3InXSArIHJ0YXJnZXRpbnQNCiAgICAgICAgICAgIGNueSA9IGhlaWdodCAtIGNueSAtIDMwMDsNCiAgICAgICAgICB9DQoNCiAgICAgICAgICBwYXRoLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7DQogICAgICAgICAgcGF0aC5saW5lVG8oc3RhcnRYLCBjbnkpOw0KICAgICAgICAgIHBhdGgubGluZVRvKGVuZFgsIGNueSk7DQogICAgICAgICAgcGF0aC5saW5lVG8oZW5kWCwgZW5kWSk7DQogICAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgcGF0aCwgInJnYigyMDAsMjAwLDIwMCkiLCA1LCAiMCIsIGlkTiwgY2xhc3NOKTsNCiAgICAgICAgfQ0KDQoNCiAgICAgIH07DQogICAgICBfdGhpcy51cGRhdGFSZWwoKQ0KICAgIH0sDQogICAgZHJhd01haW4oc3ZnKSB7DQogICAgICBsZXQgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGRhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCg0KICAgICAgbGV0IHdpZHRoID0gX3RoaXMud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCBoZWlnaHQgPSBfdGhpcy5oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCg0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVggPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybVkgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1ZOw0KICAgICAgbGV0IGdyYXBoR1RyYW5zZm9ybUsgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LOw0KICAgICAgbGV0IGF4aXNHcm91cHMgPSBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiYXhpc0dyb3VwcyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCkNCiAgICAgIC8vIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyBncmFwaEdUcmFuc2Zvcm1YICsgJywnICsgZ3JhcGhHVHJhbnNmb3JtWSArICIpIHNjYWxlKCIgKyBncmFwaEdUcmFuc2Zvcm1LICsgIikiKTsNCiAgICAgIGxldCBncm91cHMgPSBzdmcuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiZ3JvdXBzIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KQ0KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgiICsgZ3JhcGhHVHJhbnNmb3JtWCArICcsJyArIGdyYXBoR1RyYW5zZm9ybVkgKyAiKSBzY2FsZSgiICsgZ3JhcGhHVHJhbnNmb3JtSyArICIpIik7DQogICAgICB0aGlzLmdyb3Vwc1N2ZyA9IGdyb3VwczsNCg0KICAgICAgbGV0IGJhY2tHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImJhY2tHIikuYXR0cigid2lkdGgiLCB3aWR0aCkuYXR0cigiaGVpZ2h0IiwgaGVpZ2h0KTsNCiAgICAgIGxldCBhcmNHID0gZ3JvdXBzLmFwcGVuZCgiZyIpLmF0dHIoImlkIiwgImFyY0ciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IHRpbWVMaW5lRyA9IGdyb3Vwcy5hcHBlbmQoImciKS5hdHRyKCJpZCIsICJ0aW1lTGluZUciKS5hdHRyKCJ3aWR0aCIsIHdpZHRoKS5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgbGV0IGNpcmNsZUcgPSBncm91cHMuYXBwZW5kKCJnIikuYXR0cigiaWQiLCAiY2lyY2xlRyIpLmF0dHIoIndpZHRoIiwgd2lkdGgpLmF0dHIoImhlaWdodCIsIGhlaWdodCk7DQoNCiAgICAgIF90aGlzLmFyY0cgPSBhcmNHOw0KICAgICAgbGV0IHN0ZXBYID0gX3RoaXMuc3RlcFg7DQogICAgICBsZXQgc3RlcFkgPSBfdGhpcy5zdGVwWTsNCiAgICAgIGxldCBpbnRlcnZhbCA9IF90aGlzLmNpcmNsZUludGVydmFsOw0KDQoNCiAgICAgIGxldCBzY2FsZVByZSA9IF90aGlzLmdyYXBoU3ZnU2NhbGU7DQogICAgICBsZXQgc3R4ID0gMDsNCiAgICAgIGxldCBzdHkgPSAwOw0KICAgICAgbGV0IHN0ayA9IDE7DQogICAgICB2YXIgZ3JhcGhab29tID0gZDMuem9vbSgpDQogICAgICAgIC5zY2FsZUV4dGVudChbMCwgMTBdKQ0KICAgICAgICAub24oInN0YXJ0IiwgKGUpID0+IHsNCiAgICAgICAgICBzdHkgPSBlLnRyYW5zZm9ybS55Ow0KICAgICAgICAgIHN0eCA9IGUudHJhbnNmb3JtLng7DQogICAgICAgICAgc3RrID0gZS50cmFuc2Zvcm0uazsNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCd6b29tJywgKGUpID0+IHsNCiAgICAgICAgICBncmFwaEdUcmFuc2Zvcm1YID0gX3RoaXMuZ3JhcGhHVHJhbnNmb3JtWCArIGUudHJhbnNmb3JtLnggLSBzdHg7DQogICAgICAgICAgZ3JhcGhHVHJhbnNmb3JtWSA9IF90aGlzLmdyYXBoR1RyYW5zZm9ybVkgKyBlLnRyYW5zZm9ybS55IC0gc3R5Ow0KICAgICAgICAgIGdyYXBoR1RyYW5zZm9ybUsgPSBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1LICsgZS50cmFuc2Zvcm0uayAtIHN0azsNCiAgICAgICAgICBfdGhpcy5ncmFwaEdNb3ZlWCA9IGdyYXBoR1RyYW5zZm9ybVg7DQoNCiAgICAgICAgICBncm91cHMuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKGdyYXBoR1RyYW5zZm9ybVgpICsgJywnICsgKGdyYXBoR1RyYW5zZm9ybVkpICsgJykgc2NhbGUoJyArIChncmFwaEdUcmFuc2Zvcm1LKSArICcpJykNCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCdlbmQnLCAoZSkgPT4gew0KICAgICAgICAgIF90aGlzLmdyYXBoR1RyYW5zZm9ybVggPSBncmFwaEdUcmFuc2Zvcm1YOw0KICAgICAgICAgIF90aGlzLmdyYXBoR1RyYW5zZm9ybVkgPSBncmFwaEdUcmFuc2Zvcm1ZOw0KICAgICAgICAgIF90aGlzLmdyYXBoR1RyYW5zZm9ybUsgPSBncmFwaEdUcmFuc2Zvcm1LOw0KICAgICAgICAgIGdyb3Vwcy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoZ3JhcGhHVHJhbnNmb3JtWCkgKyAnLCcgKyAoZ3JhcGhHVHJhbnNmb3JtWSkgKyAnKSBzY2FsZSgnICsgKGdyYXBoR1RyYW5zZm9ybUspICsgJyknKQ0KICAgICAgICB9KTsNCg0KDQogICAgICBzdmcuY2FsbChncmFwaFpvb20pDQogICAgICAvLyAuY2FsbChncmFwaFpvb20udHJhbnNmb3JtLCBkMy56b29tSWRlbnRpdHkuc2NhbGUoMSkpDQogICAgICBjb25zdCBwYXRoID0gZDMucGF0aCgpDQogICAgICBwYXRoLm1vdmVUbyhtYXJnaW4ubGVmdCwgbWFyZ2luLnRvcCkNCiAgICAgIGxldCB4ID0gbWFyZ2luLmxlZnQ7DQogICAgICBsZXQgcHJleCA9IG1hcmdpbi5sZWZ0Ow0KICAgICAgbGV0IHByZXkgPSBtYXJnaW4udG9wOw0KICAgICAgbGV0IHByZXIgPSAwOw0KICAgICAgbGV0IHByZVNvbkxlbiA9IDA7DQogICAgICBsZXQgbGF5b3V0U2hvdyA9IF90aGlzLmxheW91dFNob3c7DQogICAgICBsZXQgc3VtVG90YWxEdXJhdGlvbiA9IDA7DQogICAgICBsZXQgcm9vdEluZGV4ID0gLTE7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IGxheSA9IHBhcnNlSW50KGRhdGFbaV1bJ2xheW91dCddKTsNCg0KICAgICAgICBsZXQgY29sb3JzID0gX3RoaXMubWNvbG9yOw0KICAgICAgICBsZXQgY29sb3JzRCA9IF90aGlzLm1EYXJrY29sb3I7DQogICAgICAgIGxldCBlbnRpdHlMb2NhdGlvbkRhdGEgPSB0b29scy5kZWVwQ2xvbmUoZGF0YVtpXSk7DQogICAgICAgIGlmIChsYXkgPT0gMCkgew0KICAgICAgICAgIHJvb3RJbmRleCsrOw0KICAgICAgICB9DQogICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsncm9vdEluZGV4J10gPSByb290SW5kZXg7DQogICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsnY29sb3InXSA9IGNvbG9yc1tyb290SW5kZXggJSBjb2xvcnMubGVuZ3RoXTsNCiAgICAgICAgZW50aXR5TG9jYXRpb25EYXRhWydjb2xvckQnXSA9IGNvbG9yc0Rbcm9vdEluZGV4ICUgY29sb3JzRC5sZW5ndGhdOw0KICAgICAgICBsZXQgdGltZUxpc3QgPSBkYXRhW2ldWyd0aW1lJ107DQogICAgICAgIGxldCBkdXJhdGlvbiA9IHRvb2xzLnRpbWUyc2Vjb25kcyh0aW1lTGlzdFsxXSkgLSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMF0pOw0KICAgICAgICBzdW1Ub3RhbER1cmF0aW9uICs9IGR1cmF0aW9uOw0KICAgICAgICBsZXQgc2hvd0VudGl0eSA9IF90aGlzLnNob3dFbnRpdHlMaXN0LmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gZGF0YVtpXVsnaWQnXSB9KTsNCiAgICAgICAgaWYgKChzaG93RW50aXR5WydzaG93J10gPT0gdHJ1ZSkpIHsNCiAgICAgICAgICBsZXQgeSA9IG1hcmdpbi50b3AgKyBsYXkgKiBzdGVwWQ0KICAgICAgICAgIGxldCByZWxldmFuY2VWYWx1ZSA9IGRhdGFbaV1bJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsNCiAgICAgICAgICBsZXQgdG90YWxEdXJhdGlvblZhbHVlID0gZGF0YVtpXVsndG90YWxEdXJhdGlvbiddOw0KICAgICAgICAgIGxldCByU2NhbGUgPSBfdGhpcy50b3RhbER1cmF0aW9uU2NhbGVfbGluZWFyOw0KDQoNCiAgICAgICAgICBsZXQgciA9IHJTY2FsZSh0b3RhbER1cmF0aW9uVmFsdWUpOw0KICAgICAgICAgIGxldCBzdGVwTCA9IHIgKyBzdGVwWCAvIDIgKyBpbnRlcnZhbCAvIDEwOw0KICAgICAgICAgIGxldCBjb250cm9sUDF4ID0gcHJleCArIGludGVydmFsIC8gMTsNCiAgICAgICAgICBsZXQgY29udHJvbFAyeCA9IHggLSBpbnRlcnZhbCAvIDE7DQogICAgICAgICAgbGV0IGN1ckxpbmV4ID0geCAtIHIgLSBpbnRlcnZhbDsNCg0KICAgICAgICAgIGxldCByZWxEYXRhID0gX3RoaXMucmVsRGF0YTsNCiAgICAgICAgICBsZXQgb0RhdGEgPSBfdGhpcy5kcmF3RW50aXR5TG9jYXRpb247DQogICAgICAgICAgbGV0IGJhc2ljUmVsID0gcmVsRGF0YVsnYmFzaWNSZWwnXTsNCiAgICAgICAgICBsZXQgZGFJZCA9IGRhdGFbKGkpXVsnaWQnXTsNCiAgICAgICAgICBsZXQgamc9MDsNCiAgICAgICAgICBmb3IgKGxldCByZSA9IDA7IHJlIDwgYmFzaWNSZWwubGVuZ3RoOyByZSsrKSB7DQoNCiAgICAgICAgICAgIGxldCBzb3JjZUlkID0gYmFzaWNSZWxbcmVdWzBdOw0KICAgICAgICAgICAgbGV0IHRhcmdldElkID0gYmFzaWNSZWxbcmVdWzFdOw0KICAgICAgICAgICAgbGV0IGNOb2RlID0gJyc7DQogICAgICAgICAgICBpZiAoKHNvcmNlSWQgPT0gZGFJZCl8fCh0YXJnZXRJZCA9PSBkYUlkKSkgew0KICAgICAgICAgICAgICBqZz0xOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH07DQogICAgICAgICAgbGV0IHNvbkZsYWcgPSAxOw0KICAgICAgICAgIGlmICgoKGkgPiAwKSAmJiAocHJlU29uTGVuID09IDApKSAmJiAoZGF0YVsoaSldWydzb24nXS5sZW5ndGggPT0gMCkpIHsNCiAgICAgICAgICAgIHNvbkZsYWcgPSAwOw0KICAgICAgICAgICAgc3RlcEwgPSByICsgc3RlcFggLyAxLjIgKyBpbnRlcnZhbCAvIDEwOw0KICAgICAgICAgICAgeCArPSBzdGVwTDsNCiAgICAgICAgICAgIGNvbnRyb2xQMXggPSBwcmV4ICsgaW50ZXJ2YWwgLyAxOw0KICAgICAgICAgICAgY29udHJvbFAyeCA9IHggLSByIC0gaW50ZXJ2YWwgLyAyIC0gaW50ZXJ2YWwgLyAxOw0KICAgICAgICAgICAgY3VyTGluZXggPSByICsgaW50ZXJ2YWwgLyAxMDsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAoKChpID4gMCkgJiYgKHByZVNvbkxlbiAhPSAwKSkgJiYgKGRhdGFbKGkpXVsnc29uJ10ubGVuZ3RoID09IDApKSB7DQogICAgICAgICAgICBzb25GbGFnID0gMDsNCiAgICAgICAgICAgIHN0ZXBMID0gciArIHN0ZXBYICsgaW50ZXJ2YWwgKyAzMDsNCiAgICAgICAgICAgIHggKz0gc3RlcEw7DQogICAgICAgICAgICBjb250cm9sUDF4ID0gcHJleCArIGludGVydmFsIC8gMTsNCiAgICAgICAgICAgIGNvbnRyb2xQMnggPSB4IC0gciAtIGludGVydmFsIC8gMSAtIGludGVydmFsIC8gMTsNCiAgICAgICAgICAgIGN1ckxpbmV4ID0gciArIGludGVydmFsIC8gMTA7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgc3RlcEwgPSByICsgc3RlcFggKyBpbnRlcnZhbCArIDEwOw0KICAgICAgICAgICAgeCArPSBzdGVwTDsNCiAgICAgICAgICAgIGNvbnRyb2xQMXggPSBwcmV4ICsgaW50ZXJ2YWwgLyAxOw0KICAgICAgICAgICAgY29udHJvbFAyeCA9IHggLSByIC0gaW50ZXJ2YWwgLSBpbnRlcnZhbCAvIDE7DQogICAgICAgICAgICBjdXJMaW5leCA9IHIgKyBpbnRlcnZhbDsNCiAgICAgICAgICB9DQogICAgICAgICAgDQogICAgICAgICAgaWYoKGpnPT0xKSYmKGRhdGFbaV1bJ3R5cGUnXT09MCkpew0KICAgICAgICAgICAgY3VyTGluZXgrPXIqMS41DQogICAgICAgICAgfQ0KICAgICAgICAgIF90aGlzLmRyYXdFbnRpdHkoY2lyY2xlRywgeCwgeSwgciwgZGF0YVtpXSkNCiAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oY29udHJvbFAxeCwgcHJleSwgY29udHJvbFAyeCwgeSwgeCAtIGN1ckxpbmV4LCB5KQ0KICAgICAgICAgIC8vIHBhdGgubGluZVRvKGNvbnRyb2xQMXgsIHByZXkpDQogICAgICAgICAgLy8gcGF0aC5saW5lVG8oY29udHJvbFAyeCwgeSkNCiAgICAgICAgICAvLyBwYXRoLmxpbmVUbyh4IC0gY3VyTGluZXgsIHkpDQogICAgICAgICAgcGF0aC5tb3ZlVG8oeCArIGN1ckxpbmV4LCB5KTsNCiAgICAgICAgICBwcmV4ID0geCArIGN1ckxpbmV4Ow0KICAgICAgICAgIHByZXkgPSB5Ow0KICAgICAgICAgIHByZXIgPSByOw0KICAgICAgICAgIHByZVNvbkxlbiA9IGRhdGFbKGkpXVsnc29uJ10ubGVuZ3RoOw0KICAgICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsneCddID0geDsNCiAgICAgICAgICBlbnRpdHlMb2NhdGlvbkRhdGFbJ3knXSA9IHk7DQogICAgICAgICAgZW50aXR5TG9jYXRpb25EYXRhWydyJ10gPSByOw0KICAgICAgICB9DQogICAgICAgIGVsc2Ugew0KICAgICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsneCddID0gcHJleDsNCiAgICAgICAgICBlbnRpdHlMb2NhdGlvbkRhdGFbJ3knXSA9IHByZXk7DQogICAgICAgICAgZW50aXR5TG9jYXRpb25EYXRhWydyJ10gPSBwcmVyOw0KICAgICAgICB9DQogICAgICAgIGVudGl0eUxvY2F0aW9uRGF0YVsnc29uRmxhZyddID0gKGVudGl0eUxvY2F0aW9uRGF0YVsnc29uJ10ubGVuZ3RoID4gMCkgPyAoMSkgOiAoMCk7DQogICAgICAgIC8vIGVudGl0eUxvY2F0aW9uRGF0YVsnc2hvd1JlbCddID0gZmFsc2U7DQogICAgICAgIF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbi5wdXNoKGVudGl0eUxvY2F0aW9uRGF0YSk7DQogICAgICB9DQogICAgICBsZXQgZW50aXR5TG9jYXRpb25EYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgbGV0IGNvbG9ycyA9IF90aGlzLm1jb2xvcjsNCiAgICAgIGxldCBjb2xvckluZGV4ID0gMDsNCiAgICAgIGxldCBjb2xvcnJvb3RJbmRleCA9IDA7DQoNCiAgICAgIF90aGlzLnN1bVRvdGFsRHVyYXRpb24gPSBzdW1Ub3RhbER1cmF0aW9uOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRpdHlMb2NhdGlvbkRhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgbGV0IHggPSBlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ3gnXTsNCiAgICAgICAgbGV0IHkgPSBlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ3knXTsNCiAgICAgICAgbGV0IHIgPSBlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ3InXTsNCiAgICAgICAgaWYoZW50aXR5TG9jYXRpb25EYXRhW2ldWyd0eXBlJ109PTApew0KICAgICAgICBfdGhpcy5kcmF3RW50aXR5VGltZUF4aXMoY2lyY2xlRywgZW50aXR5TG9jYXRpb25EYXRhW2ldKTt9DQogICAgICAgIGlmICgoZW50aXR5TG9jYXRpb25EYXRhW2ldWydsYXlvdXQnXSA9PSAnMCcgJiYgKGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnbmFtZSddICE9ICdUZXN0JykpKSB7DQogICAgICAgICAgY29sb3JJbmRleCA9IGNvbG9ycm9vdEluZGV4Ow0KICAgICAgICAgIGNvbG9ycm9vdEluZGV4Kys7DQoNCiAgICAgICAgfQ0KICAgICAgICBpZiAoKGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnc29uJ10ubGVuZ3RoICE9IDApICYmIChfdGhpcy5zaG93RW50aXR5TGlzdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnc29uJ11bMF0gfSlbJ3Nob3cnXSkpIHsNCiAgICAgICAgICBsZXQgbWF4eHMgPSBlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ3gnXSAtIGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnciddIC0gNDA7DQogICAgICAgICAgbGV0IG1heHlzID0gZW50aXR5TG9jYXRpb25EYXRhW2ldWyd5J10gLSBlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ3InXSAtIDQwOw0KICAgICAgICAgIGxldCBtaW54cyA9IHRvb2xzLmRlZXBDbG9uZShtYXh4cyk7DQogICAgICAgICAgbGV0IG1pbnlzID0gdG9vbHMuZGVlcENsb25lKG1heHlzKTsNCiAgICAgICAgICBsZXQgcmVjdFBvaW50cyA9IFtbbWF4eHMsIG1heHlzXV07DQogICAgICAgICAgbGV0IHNvbnMgPSB0b29scy5kZWVwQ2xvbmUoZGF0YVtpXVsnc29uJ10pOw0KICAgICAgICAgIHdoaWxlICgoc29ucy5sZW5ndGggPiAwKSkgew0KICAgICAgICAgICAgbGV0IHMgPSBzb25zWzBdOw0KICAgICAgICAgICAgc29ucy5zcGxpY2UoMCwgMSk7DQogICAgICAgICAgICBsZXQgY3Vyc29uID0gZW50aXR5TG9jYXRpb25EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gczsgfSk7DQogICAgICAgICAgICBsZXQgY3VyZ3NvbiA9IGN1cnNvblsnc29uJ107DQogICAgICAgICAgICBsZXQgY3VyeCA9IGN1cnNvblsneCddICsgY3Vyc29uWydyJ10gKiAyOw0KICAgICAgICAgICAgbGV0IGN1cnkgPSBjdXJzb25bJ3knXSArIGN1cnNvblsnciddICogMjsNCiAgICAgICAgICAgIGlmIChjdXJ4ID4gbWF4eHMpIHsgbWF4eHMgPSBjdXJ4OyB9DQogICAgICAgICAgICAvLyBpZihjdXJzb25bJ3knXTxtYXh5cyltYXh5cyA9IGN1cnNvblsneSddOw0KICAgICAgICAgICAgaWYgKGN1cnkgPCBtaW55cykgbWlueXMgPSBjdXJ5Ow0KICAgICAgICAgICAgaWYgKGN1cnkgPiBtYXh5cykgbWF4eXMgPSBjdXJ5Ow0KICAgICAgICAgICAgZm9yIChsZXQgZ3MgPSAwOyBncyA8IGN1cmdzb24ubGVuZ3RoOyBncysrKSB7DQogICAgICAgICAgICAgIHNvbnMucHVzaChjdXJnc29uW2dzXSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIHJlY3RQb2ludHMgPSBbW21pbnhzLCBtaW55c10sIFttaW54cywgbWF4eXNdLCBbbWF4eHMsIG1heHlzXSwgW21heHhzLCBtaW55c11dOw0KICAgICAgICAgIC8vIF90aGlzLmRyYXdwb2x5Z29uKGJhY2tHLCBjb2xvcnNbY29sb3JJbmRleF0sIHJlY3RQb2ludHMsICJyZ2IoMjU1LDI1NSwyNTUpIiwwLjMpOw0KICAgICAgICAgIF90aGlzLmRyYXdSZWN0KGJhY2tHLCBtaW54cywgbWlueXMsIE1hdGguYWJzKG1heHhzIC0gbWlueHMpLCBNYXRoLmFicyhtYXh5cyAtIG1pbnlzKSwgMjAsIDIwLCBjb2xvcnNbY29sb3JJbmRleF0sIDAuMSwgIndoaXRlIiwgYGJhY2tSZWN0JHtpfWApDQoNCiAgICAgICAgICBjb2xvckluZGV4Kys7DQogICAgICAgICAgY29sb3JJbmRleCAlPSBjb2xvcnMubGVuZ3RoDQogICAgICAgIH0NCiAgICAgICAgLy8gZW50aXR5TG9jYXRpb25EYXRhW2ldWydjb2xvciddID0gY29sb3JzW2NvbG9ySW5kZXggLSAxXTsNCiAgICAgICAgLy8gaWYgKChlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ2xheW91dCddID09ICcwJykgJiYgKChlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ25hbWUnXSA9PSAnVGVzdCcpIHx8IChlbnRpdHlMb2NhdGlvbkRhdGFbaV1bJ25hbWUnXSA9PSAnRXhhbXBsZScpKSkgew0KICAgICAgICAvLyAgIGVudGl0eUxvY2F0aW9uRGF0YVtpXVsnY29sb3InXSA9IGNvbG9yc1tjb2xvckluZGV4XQ0KICAgICAgICAvLyB9DQogICAgICB9DQogICAgICBfdGhpcy5kcmF3VGltZUxpbmUodGltZUxpbmVHLCBwYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDUsICcwJywgJ3RpbWVMaW5lICcsICd0aW1lTGluZSAnKTsNCiAgICAgIF90aGlzLmRyYXdSZWxhdGlvbnNoaXBMaW5lKHRpbWVMaW5lRyk7DQogICAgICBfdGhpcy5kcmF3VGltZUF4aXMoX3RoaXMuVGltZUF4aXNTdmcpOw0KICAgICAgX3RoaXMuZHJhd1R5cGVSaXZlcihfdGhpcy5UaW1lQXhpc1N2Zyk7DQogICAgICBfdGhpcy51cGRhdGFUaW1lQXhpc0R1cihfdGhpcy5UaW1lQXhpc1N2ZywgX3RoaXMudGltZUF4aXNYLCBfdGhpcy50aW1lQXhpc1cpOw0KICAgIH0sDQogICAgdXBkYXRhVGltZUF4aXNEdXIoc3ZnLCB4LCB3aWR0aCkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGxldCB0b3RhbFdpZHRoID0gX3RoaXMud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCB5ID0gMDsNCiAgICAgIGxldCBoID0gMTYwOw0KICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCAwLCB5LCB4LCBoLCAzLCAzLCAnd2hpdGUnLCAwLjMsICcnLCAidGltZUF4aXNSZWN0MSIpDQogICAgICBsZXQgY3VyUmVjdCA9IF90aGlzLmRyYXdSZWN0KHN2ZywgeCwgeS0wLCB3aWR0aCwgaC01LCAzLCAzLCAncmdiYSgwLDAsMCwwKScsIDEsICdyZ2IoMTQ1LCAxODAsIDE4OSknLCAnd2luUmVjdCcsMik7DQogICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KICAgICAgLy8gY3VyUmVjdC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHsNCiAgICAgIC8vICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoImN1cnNvciIsICdwb2ludGVyJyk7DQogICAgICAvLyAgIGlmIChfdGhpcy50aW1lQXhpc0Ryb3BGbGFnID09IDEpIHsNCiAgICAgIC8vICAgICBsZXQgbXggPSBlLmNsaWVudFggLSBfdGhpcy50aW1lQXhpc0Rvd25YOw0KICAgICAgLy8gICAgIF90aGlzLnRpbWVBeGlzWCA9IGUubGF5ZXJYIC0gNDUwIC0gX3RoaXMudGltZUF4aXNXIC8gMjsNCiAgICAgIC8vICAgfQ0KICAgICAgLy8gfSkNCiAgICAgIC8vIGN1clJlY3Qub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7DQogICAgICAvLyAgIF90aGlzLnRpbWVBeGlzRG93blggPSBlLmNsaWVudFg7DQogICAgICAvLyAgIF90aGlzLnRpbWVBeGlzRHJvcEZsYWcgPSAxOw0KICAgICAgLy8gfSkNCiAgICAgIC8vIGN1clJlY3Qub24oJ21vdXNldXAnLCBmdW5jdGlvbiAoZSkgew0KICAgICAgLy8gICBfdGhpcy50aW1lQXhpc0Rvd25YID0gZS5jbGllbnRYOw0KICAgICAgLy8gICBfdGhpcy50aW1lQXhpc0Ryb3BGbGFnID0gMDsNCiAgICAgIC8vIH0pDQogICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiAgICAgIF90aGlzLmRyYXdSZWN0KHN2ZywgeCArIHdpZHRoLCB5LCB0b3RhbFdpZHRoIC0gd2lkdGgsIGgsIDMsIDMsICd3aGl0ZScsIDAuMywgJycsICJ0aW1lQXhpc1JlY3QyIikNCiAgICB9LA0KICAgIGRyYXdUeXBlUml2ZXIoc3ZnKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBsZXQgb3JpRGF0YSA9IF90aGlzLmRhdGE7DQogICAgICBsZXQgcmVzRGF0YSA9IFtdOw0KICAgICAgbGV0IHRyaUxpID0gW107DQogICAgICBsZXQgZXhlTGkgPSBbXTsNCiAgICAgIHZhciBkZWZzID0gc3ZnLmFwcGVuZCgiZGVmcyIpOw0KDQogICAgICB2YXIgZmlsdGVyID0gZGVmcw0KICAgICAgICAuYXBwZW5kKCJmaWx0ZXIiKQ0KICAgICAgICAuYXR0cigiaWQiLCAiY29vbFNoYWRvdyIpDQogICAgICAgIC5hdHRyKCJ4IiwgIi0xMDAlIikNCiAgICAgICAgLmF0dHIoInkiLCAiLTEwMCUiKSAvLw0KICAgICAgICAuYXR0cigid2lkdGgiLCAiMzAwJSIpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCAiMzAwJSIpOyAvLw0KDQogICAgICBmaWx0ZXINCiAgICAgICAgLmFwcGVuZCgiZmVNb3JwaG9sb2d5IikNCiAgICAgICAgLmF0dHIoImluIiwgIlNvdXJjZUdyYXBoaWMiKQ0KICAgICAgICAuYXR0cigicmVzdWx0IiwgInVwcGVyTGF5ZXIiKQ0KICAgICAgICAuYXR0cigib3BlcmF0b3IiLCAiZGlsYXRlIikNCiAgICAgICAgLmF0dHIoInJhZGl1cyIsICIwLjIgMC4yIik7DQoNCiAgICAgIGZpbHRlcg0KICAgICAgICAuYXBwZW5kKCJmZU1vcnBob2xvZ3kiKQ0KICAgICAgICAuYXR0cigiaW4iLCAiU291cmNlQWxwaGEiKQ0KICAgICAgICAuYXR0cigicmVzdWx0IiwgImVubGFyZ2VkQWxwaGEiKQ0KICAgICAgICAuYXR0cigib3BlcmF0b3IiLCAiZGlsYXRlIikNCiAgICAgICAgLmF0dHIoInJhZGl1cyIsICIwLjIgMC4yIik7DQoNCiAgICAgIGZpbHRlcg0KICAgICAgICAuYXBwZW5kKCJmZUdhdXNzaWFuQmx1ciIpDQogICAgICAgIC5hdHRyKCJpbiIsICJlbmxhcmdlZEFscGhhIikNCiAgICAgICAgLmF0dHIoInJlc3VsdCIsICJibHVyZWRBbHBoYSIpDQogICAgICAgIC5hdHRyKCJzdGREZXZpYXRpb24iLCAiMyIpOw0KDQogICAgICBmaWx0ZXINCiAgICAgICAgLmFwcGVuZCgiZmVPZmZzZXQiKQ0KICAgICAgICAuYXR0cigiaW4iLCAiYmx1cmVkQWxwaGEiKQ0KICAgICAgICAuYXR0cigicmVzdWx0IiwgImxvd2VyTGF5ZXIiKQ0KICAgICAgICAuYXR0cigiZHkiLCAiMSIpOyAvLw0KDQogICAgICB2YXIgZmVNZXJnZSA9IGZpbHRlci5hcHBlbmQoImZlTWVyZ2UiKTsNCiAgICAgIGZlTWVyZ2UuYXBwZW5kKCJmZU1lcmdlTm9kZSIpLmF0dHIoImluIiwgImxvd2VyTGF5ZXIiKTsNCiAgICAgIGZlTWVyZ2UuYXBwZW5kKCJmZU1lcmdlTm9kZSIpLmF0dHIoImluIiwgInVwcGVyTGF5ZXIiKTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpRGF0YS5sZW5ndGg7IGkrKykgew0KICAgICAgICBsZXQgY3VyRW50ID0gb3JpRGF0YVtpXTsNCiAgICAgICAgbGV0IHRwID0ge30NCiAgICAgICAgdHBbJ29kJ10gPSBpOw0KICAgICAgICBpZiAoKGN1ckVudFsndHlwZSddID09ICIxIikpIHsNCiAgICAgICAgICB0cmlMaS5wdXNoKHRwKTsNCiAgICAgICAgfQ0KICAgICAgICBpZiAoY3VyRW50Wyd0eXBlJ10gPT0gIjIiKSB7DQogICAgICAgICAgZXhlTGkucHVzaCh0cCk7DQogICAgICAgIH0NCiAgICAgICAgbGV0IHR5cGVEYXRhID0gY3VyRW50WyJhdHRyaWJ1dGUiXVsiZXhwcmVzc2lvbnMiXTsNCiAgICAgICAgbGV0IHRvdGFsRHVyID0gMDsNCg0KICAgICAgICBmb3IgKGxldCB0IGluIHR5cGVEYXRhKSB7DQogICAgICAgICAgLy8gbGV0IGNvbG9yID0gdHlwZUNvbG9yW2ldOw0KICAgICAgICAgIGxldCB0eXBlRHVyaXRpb24gPSB0eXBlRGF0YVt0XTsNCiAgICAgICAgICBsZXQgdG90YWxUeXBlU2Vjb25kcyA9IDA7DQogICAgICAgICAgZm9yIChsZXQgZCBpbiB0eXBlRHVyaXRpb24pIHsNCiAgICAgICAgICAgIHRvdGFsVHlwZVNlY29uZHMgKz0gKHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVswXSkpDQogICAgICAgICAgfQ0KICAgICAgICAgIHRvdGFsRHVyICs9IHRvdGFsVHlwZVNlY29uZHM7DQogICAgICAgICAgdHBbdF0gPSB0b3RhbFR5cGVTZWNvbmRzOw0KICAgICAgICB9DQogICAgICAgIGZvciAobGV0IHQgaW4gdHApIHsNCiAgICAgICAgICBpZiAodCAhPSAnb2QnKSB7DQogICAgICAgICAgICB0cFt0XSAvPSB0b3RhbER1cjsNCiAgICAgICAgICAgIGlmICh0b3RhbER1ciA9PSAwKSB7DQogICAgICAgICAgICAgIHRwW3RdID0gMDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgcmVzRGF0YS5wdXNoKHRwKQ0KICAgICAgfQ0KDQogICAgICBsZXQgZGF0YSA9IHJlc0RhdGE7DQogICAgICBjb25zb2xlLmxvZyhkYXRhKQ0KICAgICAgdmFyIHN0YWNrID0gZDMuc3RhY2soKQ0KICAgICAgICAua2V5cyhbJzEnLCAnMicsICczJ10pDQogICAgICAgIC5vcmRlcihkMy5zdGFja09yZGVySW5zaWRlT3V0KQ0KICAgICAgICAub2Zmc2V0KGQzLnN0YWNrT2Zmc2V0V2lnZ2xlKTsNCg0KICAgICAgbGV0IHlSYW5nZVdpZHRoID0gODA7DQogICAgICBsZXQgeFN0ZXAgPSAoc3ZnLmF0dHIoIndpZHRoIikpIC8gb3JpRGF0YS5sZW5ndGg7DQogICAgICBsZXQgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWy0xLCAxXSkucmFuZ2UoWzAsIDgwXSk7DQogICAgICB2YXIgYXJlYSA9IGQzLmFyZWEoKQ0KICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAgICAgLngoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4gZC5kYXRhLm9kICogeFN0ZXAgKzE1Ow0KICAgICAgICB9KQ0KICAgICAgICAueTAoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4gMTIwK3lSYW5nZVdpZHRoIC0geVNjYWxlKGRbMF0pOw0KICAgICAgICB9KQ0KICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICByZXR1cm4geVJhbmdlV2lkdGggLSB5U2NhbGUoZFsxXSk7DQogICAgICAgIH0pOw0KICAgICAgY29uc29sZS5sb2coZGF0YSkNCiAgICAgIGxldCBzdGFja0RhdGEgPSBzdGFjayhkYXRhKQ0KICAgICAgY29uc29sZS5sb2coZGF0YSwgc3RhY2tEYXRhKQ0KICAgICAgbGV0IGxlblRocmVzaG9sZCA9IDAuNDsNCiAgICAgIGxldCBpY29uTGkgPSB7fQ0KICAgICAgZm9yIChsZXQgcyBpbiBzdGFja0RhdGEpIHsNCiAgICAgICAgaWNvbkxpW3NdID0gW10NCiAgICAgICAgZm9yIChsZXQgaSBpbiBzdGFja0RhdGFbc10pIHsNCiAgICAgICAgICBsZXQgbGVuQXJlYSA9IHN0YWNrRGF0YVtzXVtpXQ0KICAgICAgICAgIGlmICgobGVuQXJlYVsxXSAtIGxlbkFyZWFbMF0pID4gMC40KSB7DQogICAgICAgICAgICBpY29uTGlbc10ucHVzaChbaSwgbGVuQXJlYV0pOw0KICAgICAgICAgIH0NCiAgICAgICAgICBmb3IgKGxldCBsaSBpbiBpY29uTGlbc10pIHsNCiAgICAgICAgICAgIGlmIChpIDwgKGljb25MaVtzXVtsaV1bMF0gKyAyKSkgew0KICAgICAgICAgICAgICBsZXQgc2VsZWN0QXJlYSA9IGljb25MaVtzXVtsaV1bMV0NCiAgICAgICAgICAgICAgaWYgKCgoc2VsZWN0QXJlYVsxXSAtIGxlbkFyZWFbMV0pIC0gKHNlbGVjdEFyZWFbMF0gLSBsZW5BcmVhWzBdKSkgPCAwLjIpIHsNCiAgICAgICAgICAgICAgICBpY29uTGlbc10uc3BsaWNlKHMsIDEpOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICB9DQogICAgICAvLyBsZXQgYXJlYUcgPSBzdmcuYXBwZW5kKCJnIikNCiAgICAgIGxldCB0eXBlQ29sb3IgPSB7DQogICAgICAgICIxIjogIiNmZjljOWMiLA0KICAgICAgICAiMiI6ICIjZjRmNGQwIiwNCiAgICAgICAgIjMiOiAiIzZmOGJlMCIsDQogICAgICB9Ow0KICAgICAgbGV0IGNvbG9yTGkgPSBfdGhpcy5tY29sb3I7DQogICAgICBzdmcuc2VsZWN0QWxsKCJwYXRoIikNCiAgICAgICAgLmRhdGEoc3RhY2tEYXRhKQ0KICAgICAgICAuam9pbigicGF0aCIpDQogICAgICAgIC5hdHRyKCJpZCIsZnVuY3Rpb24oZCl7cmV0dXJuIGQua2V5fSkNCiAgICAgICAgLmF0dHIoImNsYXNzIiwicml2ZXIiKQ0KICAgICAgICAuYXR0cigiZCIsIGZ1bmN0aW9uIChkKSB7DQogICAgICAgICAgcmV0dXJuIGFyZWEoZCkNCiAgICAgICAgfSkNCiAgICAgICAgLmF0dHIoImZpbGwiLCBmdW5jdGlvbiAoZCwgaSkgew0KICAgICAgICAgIHJldHVybiB0eXBlQ29sb3JbZC5rZXldDQogICAgICAgIH0pDQogICAgICAgIC5vbigibW91c2VvdmVyIixmdW5jdGlvbihkKXsNCiAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5yaXZlciIpLnN0eWxlKCJmaWx0ZXIiLCAidXJsKCkiKQ0KICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgiZmlsdGVyIiwgInVybCgjY29vbFNoYWRvdykiKQ0KICAgICAgICB9KQ0KDQogICAgICBmb3IgKGxldCB0IGluIHRyaUxpKSB7DQogICAgICAgIGxldCBhcmVhID0gdG9vbHMuY2FsY1RyaWFuZ2xlKCh0cmlMaVt0XVsnb2QnXSkgKiB4U3RlcCwgLTMwLCAxNCk7DQogICAgICAgIF90aGlzLmRyYXdUcmlhbmdsZShzdmcsICJyZ2IoMjUwLCAxOTksIDg4KSIsIGFyZWEsICJyZ2IoMjUwLCAxOTksIDg4KSIpOw0KICAgICAgICBfdGhpcy5kcmF3VHh0KHN2ZywgKHRyaUxpW3RdWydvZCddKSAqIHhTdGVwLCAtMjMsICJUIiwgIndoaXRlIiwgMCwgIm1pZGRsZSIsIDE4KQ0KICAgICAgfQ0KICAgICAgZm9yIChsZXQgdCBpbiBleGVMaSkgew0KICAgICAgICBsZXQgYXJlYSA9IHRvb2xzLmNhbGNUcmlhbmdsZSgoZXhlTGlbdF1bJ29kJ10pICogeFN0ZXAsIC0zMCwgMTQpOw0KICAgICAgICBfdGhpcy5kcmF3VHJpYW5nbGUoc3ZnLCAicmdiKDI1MCwgMTk5LCA4OCkiLCBhcmVhLCAicmdiKDI1MCwgMTk5LCA4OCkiKTsNCiAgICAgICAgX3RoaXMuZHJhd1R4dChzdmcsIChleGVMaVt0XVsnb2QnXSkgKiB4U3RlcCwgLTIzLCAiRSIsICJ3aGl0ZSIsIDAsICJtaWRkbGUiLCAxOCkNCiAgICAgIH0NCiAgICB9LA0KICAgIGRyYXdUaW1lQXhpcyhzdmcpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBzdW1Ub3RhbER1cmF0aW9uID0gX3RoaXMuc3VtVG90YWxEdXJhdGlvbjsNCiAgICAgIGxldCBkYXRhID0gX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uOw0KICAgICAgbGV0IGFkZERhdGEgPSB0b29scy5kZWVwQ2xvbmUoX3RoaXMuZHJhd0VudGl0eUxvY2F0aW9uKTsNCiAgICAgIGxldCBtYXJnaW4gPSBfdGhpcy5tYXJnaW47DQogICAgICBsZXQgcHJleCA9IG1hcmdpbi5sZWZ0Ow0KICAgICAgbGV0IHByZXkgPSBtYXJnaW4udG9wIC8gMjsNCiAgICAgIGxldCB3aWR0aCA9IHN2Zy5hdHRyKCJ3aWR0aCIpLy8gX3RoaXMud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCBoZWlnaHQgPSBfdGhpcy5oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTsNCiAgICAgIGxldCB3aWR0aFNjYWxlID0gZDMuc2NhbGVMaW5lYXIoWzAsIHN1bVRvdGFsRHVyYXRpb25dLCBbMCwgd2lkdGhdKTsNCiAgICAgIGRhdGEuZm9yRWFjaCgoc2VsZiwgaW5keCwgYXJyKSA9PiB7DQogICAgICAgIGxldCB0b3RhbER1cmF0aW9uVmFsdWUgPSBzZWxmWyd0b3RhbER1cmF0aW9uJ107DQogICAgICAgIGxldCB0aW1lTGlzdCA9IHNlbGZbJ3RpbWUnXTsNCiAgICAgICAgbGV0IGlkID0gc2VsZlsnaWQnXQ0KICAgICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHRpbWVMaXN0WzBdKTsNCiAgICAgICAgLy8gY29uc29sZS5sb2codGltZUxpc3QsdG9vbHMudGltZTJzZWNvbmRzKHRpbWVMaXN0WzBdKSkNCiAgICAgICAgbGV0IGV2V2lkdGggPSB3aWR0aFNjYWxlKGR1cmF0aW9uKS00Ow0KDQogICAgICAgIGxldCBldlRXaWR0aCA9IHdpZHRoU2NhbGUodG90YWxEdXJhdGlvblZhbHVlKTsNCiAgICAgICAgbGV0IGxheSA9IHBhcnNlSW50KHNlbGZbJ2xheW91dCddKTsNCiAgICAgICAgbGV0IGV2SGlnaHQgPSA4MCAtIDIwICogbGF5Ow0KICAgICAgICBsZXQgeCA9IHByZXg7DQogICAgICAgIGxldCB5ID0gcHJleSArIDIwICogbGF5Ow0KICAgICAgICBwcmV4ICs9IGV2V2lkdGgrNDsNCiAgICAgICAgbGV0IGNyID0gMzsNCiAgICAgICAgLy8gaWYoc2VsZlsndHlwZSddPT0wKXsNCiAgICAgICAgaWYoMSl7DQogICAgICAgICAgaWYgKGxheSA9PSAwKSB7DQogICAgICAgICAgICBfdGhpcy5kcmF3UmVjdChzdmcsIHgtMiwgeSAtIDIwLCBldlRXaWR0aCwgMTAwLCA2LCA2LCBzZWxmWydjb2xvciddLCAwLjMsICd3aGl0ZScsIGB0aW1lQXhpc0VudEJfJHtpbmR4fWAsMS41LCAndGltZUF4aXNFbnRCJykNCiAgICAgICAgICB9DQogICAgICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCB4LCB5LCBldldpZHRoLCBldkhpZ2h0LCAzLCAzLCBzZWxmWydjb2xvciddLCAwLjQsIHNlbGZbJ2NvbG9yRCddLCBgdGltZUF4aXNFbnRfJHtpZH1gLDEuNSwgJ3RpbWVBeGlzRW50JykNCiAgICAgICAgfQ0KICAgICAgICBlbHNlew0KICAgICAgICAgIGlmIChsYXkgPT0gMCkgew0KICAgICAgICAgICAgX3RoaXMuZHJhd1JlY3Qoc3ZnLCB4LTIsIHkgLSAyMCwgZXZUV2lkdGgsIDEwMCwgNiwgNiwgc2VsZlsnY29sb3InXSwgMC4zLCAnd2hpdGUnLCBgdGltZUF4aXNFbnRCXyR7aWR9YCwxLjUsICd0aW1lQXhpc0VudCcpDQogICAgICAgICAgfQ0KICAgICAgICAgIGxldCBhcmVhID0gW1t4K2NyLHkrZXZIaWdodC1jcl0sW3gtY3IrZXZXaWR0aCx5K2V2SGlnaHQtY3JdLFt4K2V2V2lkdGgvMix5XV07DQogICAgICAgICAgX3RoaXMuZHJhd1RyaWFuZ2xlKHN2Zywgc2VsZlsnY29sb3InXSwgYXJlYSwgc2VsZlsnY29sb3InXSwxLGNyKjIpOw0KICAgICAgICB9DQogICAgICAgIGFkZERhdGFbaW5keF1bJ3RpbWVYJ10gPSB4Ow0KICAgICAgICBhZGREYXRhW2luZHhdWyd0aW1lVyddID0gZXZXaWR0aA0KICAgICAgfSkNCiAgICAgIF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbiA9IGFkZERhdGE7DQogICAgICBjb25zb2xlLmxvZygxMTExMTExMTExMTExMSwgd2lkdGgsIHN1bVRvdGFsRHVyYXRpb24sIGRhdGEsIF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbikNCiAgICB9LA0KICAgIGRyYXdUcmlhbmdsZShzdmcsIGNvbG9yLCBwb2ludHMsIHN0cm9rZSwgb3BhY2l0eSA9IDEsc3Ryb2tlVz0xNSkgew0KICAgICAgc3ZnLmFwcGVuZCgicG9seWdvbiIpDQogICAgICAgIC5hdHRyKCJwb2ludHMiLCBwb2ludHMpDQogICAgICAgIC5hdHRyKCJmaWxsIiwgY29sb3IpDQogICAgICAgIC5hdHRyKCJzdHJva2UtbGluZWpvaW4iLCAicm91bmQiKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCBzdHJva2VXKTsNCiAgICB9LA0KICAgIGRyYXdwb2x5Z29uKHN2ZywgY29sb3IsIGFyZWFzLCBzdHJva2UsIG9wYWNpdHkgPSAxKSB7DQogICAgICBzdmcuYXBwZW5kKCJwb2x5Z29uIikNCiAgICAgICAgLmF0dHIoInBvaW50cyIsIGFyZWFzKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGNvbG9yKQ0KICAgICAgICAuYXR0cigib3BhY2l0eSIsIG9wYWNpdHkpDQogICAgICAgIC5hdHRyKCJzdHJva2UiLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCAiMS41cHgiKTsNCiAgICB9LA0KICAgIGRyYXdFbnRpdHlUaW1lQXhpcyhzdmcsIGVudERhdGEpIHsNCg0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IHggPSBlbnREYXRhWyd4J107DQogICAgICBsZXQgciA9IGVudERhdGFbJ3InXTsNCiAgICAgIGxldCB5ID0gZW50RGF0YVsneSddICsgciAvIDI7DQogICAgICBsZXQgZGFJZCA9IGVudERhdGFbJ2lkJ10NCiAgICAgIGxldCBlbnREYXRhTyA9IF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbjsNCiAgICAgIGxldCBzdW1Ub3RhbER1cmF0aW9uID0gX3RoaXMuc3VtVG90YWxEdXJhdGlvbjsNCiAgICAgIGxldCB3aWR0aFNjYWxlID0gZDMuc2NhbGVMaW5lYXIoWzAsIHN1bVRvdGFsRHVyYXRpb25dLCBbMCwgTWF0aC5QSV0pOw0KICAgICAgbGV0IHRpbWVTdGVwUiA9IDA7DQogICAgICBsZXQgdGltZVN0YXJ0UiA9IC1NYXRoLlBJIC8gMjsNCiAgICAgIGxldCBpbnRlciA9IDA7DQogICAgICBsZXQgc29ucyA9IHRvb2xzLmRlZXBDbG9uZShlbnREYXRhWydzb24nXSk7DQogICAgICBsZXQgcmVsTGlzdCA9IFtdOw0KICAgICAgbGV0IHJlbFJvb3RMaXN0ID0gW107DQogICAgICBsZXQgcHNOdW0gPSAwLjU7DQogICAgICBpZiAoKHNvbnMubGVuZ3RoID4gMCkpIHsNCiAgICAgICAgaW50ZXIgPSAxNg0KICAgICAgfQ0KDQogICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICBsZXQgb0RhdGEgPSBfdGhpcy5kcmF3RW50aXR5TG9jYXRpb247DQogICAgICBsZXQgYmFzaWNSZWwgPSByZWxEYXRhWydiYXNpY1JlbCddOw0KICAgICAgZm9yIChsZXQgcmUgPSAwOyByZSA8IGJhc2ljUmVsLmxlbmd0aDsgcmUrKykgew0KDQogICAgICAgIGxldCBzb3JjZUlkID0gYmFzaWNSZWxbcmVdWzBdOw0KICAgICAgICBsZXQgdGFyZ2V0SWQgPSBiYXNpY1JlbFtyZV1bMV07DQogICAgICAgIGxldCBjTm9kZSA9ICcnOw0KICAgICAgICBpZiAoc29yY2VJZCA9PSBkYUlkKSB7DQogICAgICAgICAgY05vZGUgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHRhcmdldElkIH0pOw0KICAgICAgICAgIHJlbExpc3QucHVzaCh0YXJnZXRJZCk7DQogICAgICAgICAgcmVsUm9vdExpc3QucHVzaChjTm9kZVsncm9vdEluZGV4J10pOw0KICAgICAgICB9DQoNCiAgICAgICAgaWYgKHRhcmdldElkID09IGRhSWQpIHsNCiAgICAgICAgICBjTm9kZSA9IG9EYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gc29yY2VJZCB9KTsNCiAgICAgICAgICByZWxMaXN0LnB1c2goc29yY2VJZCk7DQogICAgICAgICAgcmVsUm9vdExpc3QucHVzaChjTm9kZVsncm9vdEluZGV4J10pOw0KICAgICAgICAgIGNvbnNvbGUubG9nKHNvcmNlSWQsIHRhcmdldElkLCBkYUlkLCBjTm9kZSkNCiAgICAgICAgfQ0KICAgICAgfTsNCiAgICAgIGNvbnNvbGUubG9nKHJlbExpc3QsIHJlbFJvb3RMaXN0KQ0KICAgICAgLy8gaWYoZW50RGF0YVtdKSANCiAgICAgIGxldCB3bGluZSA9IDA7DQogICAgICBsZXQgc3VtVG90YWxEdXJhdGlvbkYgPSAwOw0KICAgICAgZW50RGF0YU8uZm9yRWFjaCgoc2VsZiwgaW5keCwgYXJyKSA9PiB7DQogICAgICAgIGxldCB0b3RhbER1cmF0aW9uVmFsdWUgPSBzZWxmWyd0b3RhbER1cmF0aW9uJ107DQogICAgICAgIGxldCB0aW1lTGlzdCA9IHNlbGZbJ3RpbWUnXTsNCiAgICAgICAgbGV0IGxheW91dCA9IHNlbGZbJ2xheW91dCddOw0KICAgICAgICBsZXQgcm9vdEluZGV4ID0gc2VsZlsncm9vdEluZGV4J107DQogICAgICAgIGxldCBkdXJhdGlvbiA9IHRvb2xzLnRpbWUyc2Vjb25kcyh0aW1lTGlzdFsxXSkgLSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMF0pOw0KICAgICAgICB0aW1lU3RlcFIgPSB3aWR0aFNjYWxlKGR1cmF0aW9uKTsNCiAgICAgICAgaWYgKCFyZWxSb290TGlzdC5pbmNsdWRlcyhyb290SW5kZXgpKSB7DQogICAgICAgICAgd2xpbmUgKz0gdGltZVN0ZXBSICogcHNOdW07DQogICAgICAgICAgc3VtVG90YWxEdXJhdGlvbkYgKz0gZHVyYXRpb247DQogICAgICAgIH0NCiAgICAgIH0pDQogICAgICBsZXQgd2lkdGhTY2FsZUEgPSBkMy5zY2FsZUxpbmVhcihbMCwgc3VtVG90YWxEdXJhdGlvbiAtIHN1bVRvdGFsRHVyYXRpb25GXSwgWzAsIE1hdGguUEkgLSB3bGluZV0pOw0KICAgICAgLy8gaWYocm9vdEVudGl0eUxpc3QubGVuZ3RoPT0wKXsNCiAgICAgIC8vICAgd2lkdGhTY2FsZUEgPSB3aWR0aFNjYWxlDQogICAgICAvLyB9DQogICAgICAvLyBsZXQgd2xpbmUgPSAwOw0KICAgICAgZW50RGF0YU8uZm9yRWFjaCgoc2VsZiwgaW5keCwgYXJyKSA9PiB7DQogICAgICAgIGxldCB0b3RhbER1cmF0aW9uVmFsdWUgPSBzZWxmWyd0b3RhbER1cmF0aW9uJ107DQogICAgICAgIGxldCB0aW1lTGlzdCA9IHNlbGZbJ3RpbWUnXTsNCiAgICAgICAgbGV0IGxheW91dCA9IHNlbGZbJ2xheW91dCddOw0KICAgICAgICBsZXQgcm9vdEluZGV4ID0gc2VsZlsncm9vdEluZGV4J107DQogICAgICAgIGxldCBjSWQgPSBzZWxmWydpZCddOw0KICAgICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHModGltZUxpc3RbMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHRpbWVMaXN0WzBdKTsNCiAgICAgICAgdGltZVN0ZXBSID0gd2lkdGhTY2FsZShkdXJhdGlvbik7DQogICAgICAgIGlmICghcmVsUm9vdExpc3QuaW5jbHVkZXMocm9vdEluZGV4KSkgew0KICAgICAgICAgIGlmIChyZWxSb290TGlzdC5sZW5ndGggIT0gMCkgew0KICAgICAgICAgICAgdGltZVN0ZXBSID0gcHNOdW0gKiB3aWR0aFNjYWxlKGR1cmF0aW9uKTsNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgdGltZVN0ZXBSID0gd2lkdGhTY2FsZUEoZHVyYXRpb24pDQogICAgICAgIH0NCiAgICAgICAgbGV0IGVuZEFuZ2xldCA9IHRpbWVTdGFydFIgKyB0aW1lU3RlcFI7DQogICAgICAgIHZhciBkYXRhc2V0ID0geyBzdGFydEFuZ2xlOiB0aW1lU3RhcnRSLCBlbmRBbmdsZTogZW5kQW5nbGV0IH07IC8v5Yib5bu65LiA5Liq5byn55Sf5oiQ5ZmoDQogICAgICAgIHRpbWVTdGFydFIgPSBlbmRBbmdsZXQ7DQogICAgICAgIGxldCBjb2xvciA9ICdibHVlJzsNCiAgICAgICAgbGV0IHJoID0gciowLjc7DQogICAgICAgIGxldCBoID0gcmg7DQogICAgICAgIGxldCBuaCA9IDA7DQogICAgICAgIGlmIChyZWxSb290TGlzdC5sZW5ndGggIT0gMCkgew0KICAgICAgICAgIGggPSByaCowLjMgKyByaCowLjYgLSAzICogbGF5b3V0Ow0KICAgICAgICAgIG5oID0gcmgqMC4zOw0KICAgICAgICB9DQogICAgICAgIGlmICghcmVsUm9vdExpc3QuaW5jbHVkZXMoc2VsZlsncm9vdEluZGV4J10pKSB7DQogICAgICAgICAgaCA9IHJoKjAuNzsNCiAgICAgICAgICBuaCA9IGgqMCArIGgqMC42Ow0KICAgICAgICB9DQogICAgICAgIGVsc2V7DQogICAgICAgICAgZGF0YXNldC5zdGFydEFuZ2xlKz0wLjAwMzsNCiAgICAgICAgICBkYXRhc2V0LmVuZEFuZ2xlLT0wLjAwMzsgDQoNCiAgICAgICAgfQ0KICAgICAgICB2YXIgYXJjUGF0aCA9IGQzLmFyYygpDQogICAgICAgICAgLmlubmVyUmFkaXVzKHIgKyBpbnRlciArIG5oKQ0KICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgaW50ZXIgKyBoKTsNCiAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KICAgICAgICBjb25zb2xlLmxvZyhzZWxmLCByZWxMaXN0LCByZWxMaXN0LmluY2x1ZGVzKHNlbGZbJ2lkJ10pKQ0KICAgICAgICBsZXQgYXJjOw0KICAgICAgICBpZiAocmVsUm9vdExpc3QubGVuZ3RoICE9IDApIHsNCiAgICAgICAgICBpZiAocmVsUm9vdExpc3QuaW5jbHVkZXMoc2VsZlsncm9vdEluZGV4J10pKSB7DQogICAgICAgICAgICBpZiAocmVsTGlzdC5pbmNsdWRlcyhwYXJzZUludChzZWxmWydpZCddKSkpIHsNCiAgICAgICAgICAgICBhcmM9IF90aGlzLmRyYXdBcmMoc3ZnLCB4LCB5IC0gciAvIDIsIHBhdGhBcmMsIHNlbGZbJ2NvbG9yJ10sIHNlbGZbJ2NvbG9yJ10sIGB0aW1lQXhpc0ZvciBmJHtlbnREYXRhWydpZCddfSAke3NlbGZbJ2lkJ119YCwgJzAnLCAwLCAxKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICBhcmMgPSBfdGhpcy5kcmF3QXJjKHN2ZywgeCwgeSAtIHIgLyAyLCBwYXRoQXJjLCAid2hpdGUiLCBzZWxmWydjb2xvciddLCBgdGltZUF4aXNGb3IgZiR7ZW50RGF0YVsnaWQnXX0gJHtzZWxmWydpZCddfWAsICcwJywgMC4wLCAwLjQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlew0KICAgICAgICAgICAgIGFyYyA9IF90aGlzLmRyYXdBcmMoc3ZnLCB4LCB5IC0gciAvIDIsIHBhdGhBcmMsIHNlbGZbJ2NvbG9yJ10sIHNlbGZbJ2NvbG9yJ10sIGB0aW1lQXhpc0ZvciBmJHtlbnREYXRhWydpZCddfSAke3NlbGZbJ2lkJ119YCwgJzAnLCAwLCAwLjIpOw0KICAgICAgICANCiAgICAgICAgICB9DQogICAgICAgICBhcmMub24oIm1vdXNlb3ZlciIsZnVuY3Rpb24oZCl7DQogICAgICAgICAgICBsZXQgY2xhc3NOID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoImZpbGwiLCdyZWQnKTsNCiAgICAgICAgICAgIGxldCB0SWQgPSBjbGFzc04uc3BsaXQoIiAiKVsyXTsNCg0KICAgICAgICAgIH0pDQogICAgICAgICB9DQogICAgICB9KQ0KICAgIH0sDQogICAgZHJhd0VudGl0eShzdmcsIHgsIHksIHIsIGRhdGEpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGxldCBjb2xvcl9saW5lYXIgPSBfdGhpcy5pbXBvcnRhbmNlQ29sb3JfbGluZWFyOw0KICAgICAgbGV0IGNvbXB1dGVfY29sb3IgPSBfdGhpcy5pbXBvcnRhbmNlQ29tcHV0ZV9jb2xvcjsNCiAgICAgIGxldCByU2NhbGUgPSBfdGhpcy5yZWxldmFuY2VTY2FsZV9saW5lYXI7DQogICAgICBsZXQgb0RhdGEgPSBfdGhpcy5kYXRhOw0KICAgICAgbGV0IGltcG9ydGFuY2VWYWx1ZSA9IGRhdGFbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107DQogICAgICBsZXQgcmVsZXZhbmNlVmFsdWUgPSBkYXRhWydhdHRyaWJ1dGUnXVsncmVsZXZhbmNlJ107DQogICAgICAvLyBsZXQgciA9IHJTY2FsZShyZWxldmFuY2VWYWx1ZSkNCiAgICAgIC8vIHsgJ2lkJzogZGF0YVtpXVsnaWQnXSwgIngiOiB4LCAiciI6IHIsICJsYXlvdXQiOiBsYXksICJ5IjogeSwgInNvbkZsYWciOiBzb25GbGFnIH0NCg0KDQogICAgICBpZiAoZGF0YVsndHlwZSddID09ICcxJykgew0KICAgICAgICBsZXQgYXJlYSA9IHRvb2xzLmNhbGNUcmlhbmdsZSh4LCB5LCByKTsNCiAgICAgICAgX3RoaXMuZHJhd1RyaWFuZ2xlKHN2ZywgInJnYigyNTAsIDE5OSwgODgpIiwgYXJlYSwgInJnYigyNTAsIDE5OSwgODgpIik7DQoNCiAgICAgICAgX3RoaXMuZHJhd1R4dChzdmcsIHgsIHkgKyA4LCAyMCwgWyJUIl0sICd3aGl0ZScsIDI4LCAiVCIpDQogICAgICB9DQogICAgICBlbHNlIGlmIChkYXRhWyd0eXBlJ10gPT0gJzInKSB7DQogICAgICAgIGxldCBhcmVhID0gdG9vbHMuY2FsY1RyaWFuZ2xlKHgsIHksIHIpOw0KICAgICAgICBfdGhpcy5kcmF3VHJpYW5nbGUoc3ZnLCAicmdiKDI1MCwgMTk5LCA4OCkiLCBhcmVhLCAicmdiKDI1MCwgMTk5LCA4OCkiKTsNCg0KICAgICAgICBfdGhpcy5kcmF3VHh0KHN2ZywgeCwgeSArIDgsIDIwLCBbIkUiXSwgJ3doaXRlJywgMjgsICJFIikNCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KDQogICAgICAgIGxldCBjeSA9IHk7DQogICAgICAgIGxldCB0b3RhbER1cmF0aW9uID0gX3RoaXMudG90YWxEdXJhdGlvbjsNCiAgICAgICAgbGV0IHRpbWVMaW5lU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHRvdGFsRHVyYXRpb25dLCBbeCAtIHIgKiBNYXRoLnNxcnQoMykgLyAyLCB4ICsgciAqIE1hdGguc3FydCgzKSAvIDJdKQ0KICAgICAgICBsZXQgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIF90aGlzLm1heFRvdGFsRHVyYXRpb24gLSA1MF0sIFtyIC8gMiwgciAqICgxICsgTWF0aC5zcXJ0KDMpIC8gMyAqIDIpXSkNCiAgICAgICAgbGV0IGNpcmNsZUNvbG9yID0gY29tcHV0ZV9jb2xvcihjb2xvcl9saW5lYXIoaW1wb3J0YW5jZVZhbHVlKSk7DQogICAgICAgIF90aGlzLmRyYXdDaXJjbGUoc3ZnLCB4LCBjeSwgciwgY2lyY2xlQ29sb3IsIGRhdGEsIDEsICJlbnRDaXJjbGUiLCAiZW50Q2lyY2xlXyIgKyBkYXRhWydpZCddKTsNCg0KICAgICAgICByID0gciAqIE1hdGguc3FydCgzKSAvIDI7DQogICAgICAgIHkgKz0gciAvIDI7DQogICAgICAgIGxldCBwYXRoID0gZDMucGF0aCgpOw0KDQoNCiAgICAgICAgcGF0aC5tb3ZlVG8oeCAtIHIsIHkpOw0KICAgICAgICBsZXQgbGluZUxpID0gW2RhdGFdOw0KICAgICAgICBsZXQgbGluZVBvaW50ID0gW3sgJ2lkJzogZGF0YVsnaWQnXSwgJ3RpbWUnOiBkYXRhWyd0aW1lJ10sICd4JzogMCwgJ3knOiAwIH1dOw0KICAgICAgICBsZXQgamdpZEwgPSBbZGF0YVsnaWQnXV07DQogICAgICAgIGxldCBzaW1pbGFyaXR5UmVsc2xpID0gW2RhdGFbInNpbWlsYXJpdHlSZWwiXV07DQogICAgICAgIHdoaWxlIChzaW1pbGFyaXR5UmVsc2xpLmxlbmd0aCA+IDApIHsNCiAgICAgICAgICBsZXQgc2ltaWxhcml0eVJlbHMgPSBzaW1pbGFyaXR5UmVsc2xpWzBdOw0KICAgICAgICAgIHNpbWlsYXJpdHlSZWxzbGkuc3BsaWNlKDAsIDEpOw0KICAgICAgICAgIGxldCBqZyA9IDA7DQogICAgICAgICAgZm9yIChsZXQgc3JlbCBpbiBzaW1pbGFyaXR5UmVscykgew0KICAgICAgICAgICAgbGV0IGNkYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzaW1pbGFyaXR5UmVsc1tzcmVsXSB9KTsNCiAgICAgICAgICAgIGlmIChqZ2lkTC5pbmRleE9mKGNkYXRhWydpZCddKSA9PSAtMSkgew0KICAgICAgICAgICAgICBzaW1pbGFyaXR5UmVsc2xpLnB1c2goY2RhdGFbInNpbWlsYXJpdHlSZWwiXSkNCiAgICAgICAgICAgICAgamcgPSAxOw0KICAgICAgICAgICAgICBsaW5lTGkucHVzaChjZGF0YSkNCiAgICAgICAgICAgICAgamdpZEwucHVzaChjZGF0YVsnaWQnXSkNCiAgICAgICAgICAgICAgbGluZVBvaW50LnB1c2goeyAnaWQnOiBjZGF0YVsnaWQnXSwgJ3RpbWUnOiBjZGF0YVsndGltZSddLCAneCc6IDAsICd5JzogMCB9KQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICAvLyBpZihqZz09MCl7DQogICAgICAgICAgLy8gYnJlYWs7DQogICAgICAgICAgLy8gfQ0KICAgICAgICB9DQoNCiAgICAgICAgY29uc3Qgc29ydG10ID0gKGEsIGIpID0+IHsNCiAgICAgICAgICByZXR1cm4gdG9vbHMudGltZTJzZWNvbmRzKGFbMF0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGJbMF0pOw0KICAgICAgICB9DQogICAgICAgIGNvbnN0IHNvcnRscCA9IChhLCBiKSA9PiB7DQogICAgICAgICAgcmV0dXJuIHRvb2xzLnRpbWUyc2Vjb25kcyhhWyd0aW1lJ11bMF0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGJbJ3RpbWUnXVswXSk7DQogICAgICAgIH0NCg0KICAgICAgICBsaW5lTGkgPSBsaW5lTGkuc29ydChzb3J0bHApOw0KICAgICAgICBsaW5lUG9pbnQgPSBsaW5lUG9pbnQuc29ydChzb3J0bHApOw0KICAgICAgICBsZXQgbGluZURhdGEgPSBbW3ggLSByICogTWF0aC5zcXJ0KDMpIC8gMiAtIDQsIHldXTsNCiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBsaW5lTGkubGVuZ3RoOyB0KyspIHsNCiAgICAgICAgICBsZXQgc3RhcnRUID0gbGluZUxpW3RdWyd0aW1lJ11bMF07DQogICAgICAgICAgbGV0IGR1cmF0aW9uID0gbGluZUxpW3RdWyd0b3RhbER1cmF0aW9uJ10NCiAgICAgICAgICAvLyBsZXQgZW5kVCA9IGxpbmVMaVt0XVsndGltZSddWzFdOw0KICAgICAgICAgIGxldCBzdGFydFMgPSB0b29scy50aW1lMnNlY29uZHMoc3RhcnRUKTsNCiAgICAgICAgICBsZXQgZW5kUyA9IHN0YXJ0UyArIGR1cmF0aW9uOw0KICAgICAgICAgIC8vIGxldCBzdGFydHggPSB0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTIC0gZHVyYXRpb24gKiAxMCkpOw0KICAgICAgICAgIC8vIGxldCBlbmR4ID0gdGltZUxpbmVTY2FsZV9saW5lYXIoKGVuZFMgKyBkdXJhdGlvbiAqIDEwKSk7DQogICAgICAgICAgbGV0IGxpbXN0ID0gKHggLSByICogTWF0aC5zcXJ0KDMpIC8gMik7DQogICAgICAgICAgbGV0IGxpbWVkID0gKHggKyByICogTWF0aC5zcXJ0KDMpIC8gMik7DQogICAgICAgICAgbGV0IHN0YXJ0eCA9IChsaW1zdCA8IHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSkgPyAodGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UykpKSA6IChsaW1zdCk7DQogICAgICAgICAgbGV0IGVuZHggPSAobGltZWQgPiB0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUykpKSA/ICh0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUykpKSA6IChsaW1lZCk7DQogICAgICAgICAgLy8gbGV0IG1pZHggPSB0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUyArIHN0YXJ0UykgLyAyKTsNCiAgICAgICAgICBsZXQgbWlkeCA9IChzdGFydHggKyBlbmR4KSAvIDI7DQogICAgICAgICAgbGV0IHlzID0geTsNCiAgICAgICAgICBsZXQgeXogPSB5IC0gdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpOw0KICAgICAgICAgIGxpbmVQb2ludFt0XVsneCddID0gbWlkeDsNCiAgICAgICAgICBsaW5lUG9pbnRbdF1bJ3knXSA9IHkgLSB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoZHVyYXRpb24pIC8gMS43Ow0KICAgICAgICAgIC8vIGlmIChzdGFydHggPCAobGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF0pKSB7DQogICAgICAgICAgaWYgKHQgPiAwKSB7DQogICAgICAgICAgICBsaW5lRGF0YS5zcGxpY2UobGluZURhdGEubGVuZ3RoIC0gMSwgMSk7DQogICAgICAgICAgICBtaWR4ICs9IHQgKiA1Ow0KICAgICAgICAgICAgc3RhcnR4ID0gbWlkeCAtICgobWlkeCAtIChsaW5lRGF0YVtsaW5lRGF0YS5sZW5ndGggLSAxXVswXSArIG1pZHgpIC8gMikpIC8gMjsNCiAgICAgICAgICAgIGVuZHggKz0gdCAqIDU7DQogICAgICAgICAgICB5cyA9IHkgKyAoeSAtIGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzFdKSAvIDMNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gfQ0KICAgICAgICAgIGxpbmVEYXRhLnB1c2goW3N0YXJ0eCwgeXNdLCBbbWlkeCwgeXpdLCBbZW5keCwgeV0pDQogICAgICAgICAgLy8gbGV0IHN0YXJ0eCA9IHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMgLSBkdXJhdGlvbiAqIDEwKSk7DQogICAgICAgICAgLy8gbGV0IGVuZHggPSB0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUyArIGR1cmF0aW9uICogMTApKTsNCg0KICAgICAgICAgIC8vIGxldCBzdGFydHlmID0geSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDg7DQogICAgICAgICAgLy8gbGV0IHN0YXJ0eWYxID0geSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDg7DQogICAgICAgICAgLy8gbGV0IGVuZHlmID0geSArIHRpbWVMaW5lSGlnaFNjYWxlX2xpbmVhcigoZHVyYXRpb24pKSAvIDg7DQogICAgICAgICAgLy8gbGV0IGVuZHlmMSA9IHkgKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyA4Ow0KICAgICAgICAgIC8vIGxldCB5eiA9IHkgLSB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSk7DQogICAgICAgICAgLy8gbGV0IG1pZHggPSB0aW1lTGluZVNjYWxlX2xpbmVhcigoZW5kUyArIHN0YXJ0UykgLyAyKTsNCiAgICAgICAgICAvLyBsaW5lUG9pbnRbdF1bJ3gnXSA9IG1pZHg7DQogICAgICAgICAgLy8gbGluZVBvaW50W3RdWyd5J10gPSB5IC0gdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKGR1cmF0aW9uKSAvIDEuNzsNCiAgICAgICAgICAvLyBsZXQgeTEgPSB5Ow0KICAgICAgICAgIC8vIGlmIChzdGFydHggPCAobGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF0pKSB7DQogICAgICAgICAgLy8gICBpZiAodCA+IDApIHsNCiAgICAgICAgICAvLyAgICAgbGluZURhdGEuc3BsaWNlKGxpbmVEYXRhLmxlbmd0aCAtIDMsIDMpOw0KICAgICAgICAgIC8vICAgICBzdGFydHggPSAobGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF0gKyBtaWR4KSAvIDI7DQogICAgICAgICAgLy8gICAgIHkxID0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMV0gKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyAyOw0KICAgICAgICAgIC8vICAgICBzdGFydHlmID0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMV0gKyB0aW1lTGluZUhpZ2hTY2FsZV9saW5lYXIoKGR1cmF0aW9uKSkgLyAyOw0KICAgICAgICAgIC8vICAgICBzdGFydHlmMSA9IGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzFdICsgdGltZUxpbmVIaWdoU2NhbGVfbGluZWFyKChkdXJhdGlvbikpIC8gMjsNCiAgICAgICAgICAvLyAgIH0NCiAgICAgICAgICAvLyB9DQogICAgICAgICAgLy8gbGV0IHN0YXJ0eDEgPSBzdGFydHggKyAodGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyArIGR1cmF0aW9uKSkgLSB0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTKSkpOw0KICAgICAgICAgIC8vIGxldCBlbmR4MSA9IGVuZHggLSAodGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyArIGR1cmF0aW9uKSkgLSB0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTKSkpOw0KICAgICAgICAgIC8vIGxldCBzdGFydHgyID0gc3RhcnR4MSArICh0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTICsgZHVyYXRpb24pKSAtIHRpbWVMaW5lU2NhbGVfbGluZWFyKChzdGFydFMpKSk7DQogICAgICAgICAgLy8gbGV0IGVuZHgyID0gZW5keDEgLSAodGltZUxpbmVTY2FsZV9saW5lYXIoKHN0YXJ0UyArIGR1cmF0aW9uKSkgLSB0aW1lTGluZVNjYWxlX2xpbmVhcigoc3RhcnRTKSkpOw0KICAgICAgICAgIC8vIGlmIChlbmR4ID4gKHIgKyB4KSkgZW5keCA9IHIgKyB4Ow0KICAgICAgICAgIC8vIGlmIChzdGFydHgxIDwgKGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdKSkgc3RhcnR4MSA9IGxpbmVEYXRhW2xpbmVEYXRhLmxlbmd0aCAtIDFdWzBdOw0KICAgICAgICAgIC8vIGlmIChlbmR4MSA+IChyICsgeCkpIGVuZHgxID0gciArIHg7DQogICAgICAgICAgLy8gaWYgKHN0YXJ0eDIgPCAobGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF0pKSBzdGFydHgyID0gbGluZURhdGFbbGluZURhdGEubGVuZ3RoIC0gMV1bMF07DQogICAgICAgICAgLy8gaWYgKGVuZHgyID4gKHIgKyB4KSkgZW5keDIgPSByICsgeDsNCiAgICAgICAgICAvLyBsaW5lRGF0YS5wdXNoKFtzdGFydHgsIHkxXSwgW3N0YXJ0eDEsIHN0YXJ0eWYxXSwgW3N0YXJ0eDIsIHN0YXJ0eWZdLCBbbWlkeCwgeXpdLCBbZW5keDIsIGVuZHlmXSwgW2VuZHgxLCBlbmR5ZjFdLCBbZW5keCwgeV0pDQogICAgICAgIH0NCiAgICAgICAgbGluZURhdGEucHVzaChbeCArIHIsIHldKQ0KICAgICAgICBsZXQgY3VydmVfZ2VuZXJhdG9yID0gZDMubGluZSgpDQogICAgICAgICAgLngoKGQpID0+IGRbMF0pDQogICAgICAgICAgLnkoKGQpID0+IHsNCiAgICAgICAgICAgIGxldCBoID0gTWF0aC5zcXJ0KE1hdGgucG93KHIsIDIpIC0gTWF0aC5wb3coKGRbMF0gLSAoeCAtIHIpKSwgMikpOw0KICAgICAgICAgICAgaWYgKCh5IC0gZFsxXSkgPiAoaCArIHIgKiBNYXRoLnNxcnQoMykgLyAyKSkNCiAgICAgICAgICAgICAgcmV0dXJuIHkgLSAoaCArIHIgKiBNYXRoLnNxcnQoMykgLyAyKSArIDI7DQogICAgICAgICAgICByZXR1cm4gZFsxXTsNCiAgICAgICAgICB9KQ0KICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJ1bmRsZSkNCiAgICAgICAgLy8gLmN1cnZlKGQzLmN1cnZlQ2F0bXVsbFJvbSAgKQ0KICAgICAgICAvLyAuY3VydmUoZDMuY3VydmVCYXNpcykNCiAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKHN2ZywgY3VydmVfZ2VuZXJhdG9yKGxpbmVEYXRhKSwgIndoaXRlIiwgMiwgJzAnLCAnc29uTGluZSAnLCAnc29uTGluZSAnKTsNCg0KDQogICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbGluZVBvaW50Lmxlbmd0aDsgcCsrKSB7DQogICAgICAgICAgX3RoaXMuZHJhd0NpcmNsZShzdmcsIGxpbmVQb2ludFtwXVsneCddLCBsaW5lUG9pbnRbcF1bJ3knXSwgNSwgInJlZCIsIGxpbmVQb2ludFtwXSwgMCwgImxpbmVQb2ludCIsICJsaW5lUG9pbnRfIiArIGxpbmVQb2ludFtwXVsnaWQnXSk7DQogICAgICAgIH0NCg0KICAgICAgICAvLyAiMSI6ICJyZ2IoMTQ1LCAyMDQsIDExNykiLA0KICAgICAgICAvLyAgICIyIjogInJnYig4NCwgMTEyLCAxOTgpIiwNCiAgICAgICAgLy8gICAiMyI6ICJyZ2IoMjM4LCAxMDIsIDEwMikiLA0KICAgICAgICBsZXQgdHlwZUNvbG9yID0gew0KICAgICAgICAgICIxIjogIiNmZjljOWMiLA0KICAgICAgICAgICIyIjogIiNmNGY0ZDAiLA0KICAgICAgICAgICIzIjogIiM2ZjhiZTAiLA0KICAgICAgICB9Ow0KICAgICAgICBsZXQgZHVyYXRpb24gPSB0b29scy50aW1lMnNlY29uZHMoZGF0YVsndGltZSddWzBdKSAtIHRvb2xzLnRpbWUyc2Vjb25kcyhkYXRhWyd0aW1lJ11bMV0pOw0KICAgICAgICBsZXQgdHlwZURhdGEgPSBkYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXTsNCiAgICAgICAgbGV0IHNvbkxpc3QgPSBkYXRhWydzb24nXTsNCiAgICAgICAgbGV0IHNvbnMgPSBbc29uTGlzdF07DQogICAgICAgIHdoaWxlIChzb25zLmxlbmd0aCA+IDApIHsNCiAgICAgICAgICBsZXQgY3VyU29uTGlzdCA9IHNvbnNbMF07DQogICAgICAgICAgc29ucy5zcGxpY2UoMCwgMSk7DQogICAgICAgICAgaWYgKGN1clNvbkxpc3QubGVuZ3RoID4gMCkgew0KICAgICAgICAgICAgZm9yIChsZXQgcyBpbiBjdXJTb25MaXN0KSB7DQogICAgICAgICAgICAgIGxldCBzb25EYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBjdXJTb25MaXN0W3NdIH0pOw0KICAgICAgICAgICAgICBsZXQgc29uVHlwZURhdGEgPSBzb25EYXRhWydhdHRyaWJ1dGUnXVsnZXhwcmVzc2lvbnMnXTsNCg0KICAgICAgICAgICAgICBmb3IgKGxldCB0IGluIHNvblR5cGVEYXRhKSB7DQogICAgICAgICAgICAgICAgbGV0IHR5cGVEdXJpdGlvbiA9IHNvblR5cGVEYXRhW3RdOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgICAgICAgICB0eXBlRGF0YVt0XS5wdXNoKHR5cGVEdXJpdGlvbltkXSkNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgc29ucy5wdXNoKHNvbkRhdGFbJ3NvbiddKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgdmFyIHR5cGVTdGFydFIgPSAwLy9NYXRoLlBJLzQ7DQoNCiAgICAgICAgdmFyIHR5cGVTdGVwUiA9IE1hdGguUEkgLyAxOw0KDQogICAgICAgIGlmIChzb25MaXN0Lmxlbmd0aCA+IDApIHsNCiAgICAgICAgICBsZXQgdHlwZVRvdGFsRHVyID0gMDsNCiAgICAgICAgICBmb3IgKGxldCB0IGluIHR5cGVEYXRhKSB7DQogICAgICAgICAgICBsZXQgdHlwZUR1cml0aW9uID0gdHlwZURhdGFbdF07DQogICAgICAgICAgICBmb3IgKGxldCBkIGluIHR5cGVEdXJpdGlvbikgew0KICAgICAgICAgICAgICB0eXBlVG90YWxEdXIgKz0gKHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVswXSkpDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIGxldCB0eXBlQXJjU2NhbGVfbGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHR5cGVUb3RhbER1cl0sIFswLCBNYXRoLlBJICogMl0pOw0KICAgICAgICAgIGZvciAobGV0IGkgaW4gdHlwZURhdGEpIHsNCiAgICAgICAgICAgIGxldCBjb2xvciA9IHR5cGVDb2xvcltpXTsNCiAgICAgICAgICAgIGxldCB0eXBlRHVyaXRpb24gPSB0eXBlRGF0YVtpXTsNCiAgICAgICAgICAgIGxldCB0b3RhbFR5cGVTZWNvbmRzID0gMDsNCiAgICAgICAgICAgIGZvciAobGV0IGQgaW4gdHlwZUR1cml0aW9uKSB7DQogICAgICAgICAgICAgIHRvdGFsVHlwZVNlY29uZHMgKz0gKHRvb2xzLnRpbWUyc2Vjb25kcyh0eXBlRHVyaXRpb25bZF1bMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKHR5cGVEdXJpdGlvbltkXVswXSkpDQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAodG90YWxUeXBlU2Vjb25kcyA+IDApIHsNCiAgICAgICAgICAgICAgbGV0IHR5cGVTdGVwUiA9IHR5cGVBcmNTY2FsZV9saW5lYXIodG90YWxUeXBlU2Vjb25kcykvL01hdGguUEkvMjsNCg0KICAgICAgICAgICAgICBsZXQgZW5kQW5nbGV0ID0gdHlwZVN0YXJ0UiArIDEgKiB0eXBlU3RlcFINCiAgICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHR5cGVTdGFydFIsIGVuZEFuZ2xlOiBlbmRBbmdsZXQgfTsgLy/liJvlu7rkuIDkuKrlvKfnlJ/miJDlmagNCiAgICAgICAgICAgICAgdHlwZVN0YXJ0UiA9IGVuZEFuZ2xldDsNCiAgICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgICAgICAgIC5pbm5lclJhZGl1cyhyICsgMTApDQogICAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKHIgKyAyNSk7DQogICAgICAgICAgICAgIHZhciBwYXRoQXJjID0gYXJjUGF0aChkYXRhc2V0KTsNCiAgICAgICAgICAgICAgX3RoaXMuZHJhd0FyYyhzdmcsIHgsIHkgLSByIC8gMiwgcGF0aEFyYywgY29sb3IsIGNvbG9yLCAndHlwZSBmJyArIGRhdGFbJ2lkJ10gKyAiIHQiICsgaSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIGxldCBzb25Ub3RhbCA9IDA7DQogICAgICAgICAgbGV0IHNvbk51bSA9IDANCiAgICAgICAgICBmb3IgKGxldCBzIGluIHNvbkxpc3QpIHsNCiAgICAgICAgICAgIGxldCBzb25EYXRhID0gb0RhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSBzb25MaXN0W3NdIH0pOw0KICAgICAgICAgICAgbGV0IHNvbkR1ciA9IHNvbkRhdGFbJ3RvdGFsRHVyYXRpb24nXTsNCiAgICAgICAgICAgIHNvblRvdGFsICs9IHNvbkR1cjsNCiAgICAgICAgICAgIHNvbk51bSArPSAxOw0KICAgICAgICAgIH0NCiAgICAgICAgICBsZXQgc2tpcEFyYyA9IE1hdGguUEkgLyAoc29uTnVtICsgMik7DQogICAgICAgICAgbGV0IHRpbWVTb25MaW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbMCwgc29uVG90YWxdLCBbMCwgTWF0aC5QSSAtIHNraXBBcmMgKiAoc29uTnVtIC0gMSldKTsNCiAgICAgICAgICBsZXQgdGltZVNvbkhlaWdoTGluZWFyID0gZDMuc2NhbGVMaW5lYXIoWzAsIHNvblRvdGFsXSwgWzQwLCA0MF0pOw0KDQogICAgICAgICAgbGV0IHRpbWVTb25Db2xvcl9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgc29uVG90YWxdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgICAgIGxldCB0aW1lU29uQ29tcHV0ZV9jb2xvciA9IGQzLmludGVycG9sYXRlKCJ3aGl0ZSIsIGNpcmNsZUNvbG9yKTsNCiAgICAgICAgICB2YXIgc29uU3RhcnRSID0gTWF0aC5QSSAvIDI7DQoNCiAgICAgICAgICBsZXQgcmVsTGlzdCA9IFtdOw0KICAgICAgICAgIGxldCByZWxSb290TGlzdCA9IFtdOw0KICAgICAgICAgIGxldCBwc051bSA9IDAuMTsNCiAgICAgICAgICBsZXQgZGFJZCA9IGRhdGFbJ2lkJ10NCiAgICAgICAgICBsZXQgcmVsRGF0YSA9IF90aGlzLnJlbERhdGE7DQogICAgICAgICAgbGV0IG9kRGF0YSA9IF90aGlzLmRhdGE7DQogICAgICAgICAgbGV0IGJhc2ljUmVsID0gcmVsRGF0YVsnYmFzaWNSZWwnXTsNCiAgICAgICAgICBmb3IgKGxldCByZSA9IDA7IHJlIDwgYmFzaWNSZWwubGVuZ3RoOyByZSsrKSB7DQoNCiAgICAgICAgICAgIGxldCBzb3JjZUlkID0gYmFzaWNSZWxbcmVdWzBdOw0KICAgICAgICAgICAgbGV0IHRhcmdldElkID0gYmFzaWNSZWxbcmVdWzFdOw0KICAgICAgICAgICAgbGV0IGNOb2RlID0gJyc7DQogICAgICAgICAgICBpZiAoc29yY2VJZCA9PSBkYUlkKSB7DQogICAgICAgICAgICAgIGNOb2RlID0gb2REYXRhLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHBhcnNlSW50KGRbJ2lkJ10pID09IHBhcnNlSW50KHRhcmdldElkKSB9KTsNCiAgICAgICAgICAgICAgcmVsTGlzdC5wdXNoKHRhcmdldElkKTsNCiAgICAgICAgICAgIH0NCg0KICAgICAgICAgICAgaWYgKHRhcmdldElkID09IGRhSWQpIHsNCiAgICAgICAgICAgICAgY05vZGUgPSBvZERhdGEuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcGFyc2VJbnQoZFsnaWQnXSkgPT0gcGFyc2VJbnQoc29yY2VJZCkgfSk7DQogICAgICAgICAgICAgIHJlbExpc3QucHVzaChzb3JjZUlkKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9Ow0KICAgICAgICAgIGlmIChyZWxMaXN0Lmxlbmd0aCA9PSAwKSB7DQogICAgICAgICAgICBzb25TdGFydFIgPSAwOw0KICAgICAgICAgICAgdGltZVNvbkxpbmVhciA9IGQzLnNjYWxlTGluZWFyKFswLCBzb25Ub3RhbF0sIFswLCBNYXRoLlBJICogMiAtIHNraXBBcmMgKiAoc29uTnVtKV0pOw0KICAgICAgICAgIH0NCg0KICAgICAgICAgIGZvciAobGV0IHMgaW4gc29uTGlzdCkgew0KICAgICAgICAgICAgbGV0IHNvbkRhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHNvbkxpc3Rbc10gfSk7DQogICAgICAgICAgICBsZXQgc29uRHVyID0gc29uRGF0YVsndG90YWxEdXJhdGlvbiddOw0KDQogICAgICAgICAgICBsZXQgc29uU3RlcFIgPSB0aW1lU29uTGluZWFyKHNvbkR1cikvL01hdGguUEkvMjsNCg0KICAgICAgICAgICAgbGV0IGVuZEFuZ2xldCA9IHNvblN0YXJ0UiArIHNvblN0ZXBSOw0KICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHNvblN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KICAgICAgICAgICAgc29uU3RhcnRSID0gZW5kQW5nbGV0Ow0KICAgICAgICAgICAgbGV0IGNvbG9yID0gJ2JsdWUnOw0KICAgICAgICAgICAgdmFyIGFyY1BhdGggPSBkMy5hcmMoKQ0KICAgICAgICAgICAgICAuaW5uZXJSYWRpdXMociArIDI4KQ0KICAgICAgICAgICAgICAub3V0ZXJSYWRpdXMociArIHRpbWVTb25IZWlnaExpbmVhcihzb25EdXIpKTsNCiAgICAgICAgICAgIHZhciBhcmNNaWRQYXRoID0gZDMuYXJjKCkNCiAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKDApDQogICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyICsgMzIpOw0KICAgICAgICAgICAgdmFyIHBhdGhBcmMgPSBhcmNQYXRoKGRhdGFzZXQpOw0KDQogICAgICAgICAgICBlbmRBbmdsZXQgPSBzb25TdGFydFIgKyBza2lwQXJjOw0KICAgICAgICAgICAgdmFyIG1pZERhdGFzZXQgPSB7IHN0YXJ0QW5nbGU6IHNvblN0YXJ0UiwgZW5kQW5nbGU6IGVuZEFuZ2xldCB9OyAvL+WIm+W7uuS4gOS4quW8p+eUn+aIkOWZqA0KDQogICAgICAgICAgICBsZXQgamlhbnRvdVBhdGggPSBkMy5wYXRoKCk7DQogICAgICAgICAgICBqaWFudG91UGF0aC5hcmMoeCwgeSAtIHIgLyAyLCByICsgMzIsIHNvblN0YXJ0UiAtIE1hdGguUEkgLyAyLCBlbmRBbmdsZXQgLSBNYXRoLlBJIC8gMik7DQoNCiAgICAgICAgICAgIHNvblN0YXJ0UiArPSBza2lwQXJjOw0KICAgICAgICAgICAgdmFyIHBhdGhNaWRBcmMgPSBhcmNNaWRQYXRoKG1pZERhdGFzZXQpOw0KICAgICAgICAgICAgbGV0IHRpbWVTb25Db2xvciA9IGNvbXB1dGVfY29sb3IoY29sb3JfbGluZWFyKHNvbkRhdGFbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ10pKTsNCiAgICAgICAgICAgIF90aGlzLmRyYXdBcmMoc3ZnLCB4LCB5IC0gciAvIDIsIHBhdGhBcmMsIHRpbWVTb25Db2xvciwgdGltZVNvbkNvbG9yLCAnc29uIGYnICsgZGF0YVsnaWQnXSArICIgcyIgKyBzb25MaXN0W3NdLCAnMCcpOw0KICAgICAgICAgICAgaWYgKHMgIT0gc29uTGlzdC5sZW5ndGggLSAxKSB7DQoNCiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cNCiAgICAgICAgICAgICAgX3RoaXMuZHJhd1RpbWVMaW5lKF90aGlzLmFyY0csIGppYW50b3VQYXRoLCAicmdiKDIwMCwyMDAsMjAwKSIsIDMsICc5LDUnLCAnbWlkQXJjICcsICdtaWRBcmMgJyk7DQogICAgICAgICAgICAgIC8vIF90aGlzLmRyYXdUaW1lTGluZShfdGhpcy5hcmNHLCBwYXRoLCAid2hpdGUiLCAyLCcwJywgJ3NvbkxpbmUgJywgJ3NvbkxpbmUgJyk7DQogICAgICAgICAgICAgIC8vIF90aGlzLmRyYXdBcmMoX3RoaXMuYXJjRywgeCwgeSAtIHIgLyAyLCBwYXRoTWlkQXJjLCAicmdiKDIwMCwyMDAsMjAwKSIsICJ3aGl0ZSIsICdzb24gZicgKyBkYXRhWydpZCddLCAiOSw1IiwgMyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KDQogICAgICAgIH07DQogICAgICB9DQogICAgICBsZXQgdHh0cyA9IGRhdGFbJ25hbWUnXS5zcGxpdCgiICIpDQogICAgICBsZXQgdHggPSB4IC0gciAtIDMwOw0KICAgICAgbGV0IHR5ID0geSArIHIgKyA2MDsNCiAgICAgIGxldCB0dyA9IHIgKiAyOw0KICAgICAgdHggPSB4Ow0KICAgICAgaWYgKGRhdGFbJ3NvbiddLmxlbmd0aCA9PSAwKSB7DQogICAgICAgIHR4ID0geC8vLXItMTA7DQogICAgICAgIHR5ID0geSArIHIgKiAyOw0KICAgICAgfQ0KICAgICAgaWYgKGRhdGFbJ2lkJ10gPT0gIjMiKSB7DQogICAgICAgIHR4ID0geCAtIDEwOw0KICAgICAgICB0eSA9IHkgKyByICogMjsNCiAgICAgIH0NCiAgICAgIGlmIChkYXRhWydpZCddID09ICI0Iikgew0KICAgICAgICB0eCA9IHggKyAxMDsNCiAgICAgICAgdHkgPSB5ICsgciAqIDI7DQogICAgICB9DQogICAgICAvLyBpZihkYXRhWyd0eXBlJ109PScxJyl7DQogICAgICAvLyAgIHR4ID0geC1yLzI7DQogICAgICAvLyAgIHR5ID0geStyKjI7DQogICAgICAvLyB9DQoNCiAgICAgIF90aGlzLmRyYXdUeHQoc3ZnLCB0eCwgdHksIHR3LCB0eHRzLCAiZ3JleSIsIDE2LCBgdGV4dF8ke2RhdGFbJ2lkJ119YCk7DQogICAgfSwNCiAgICBkcmF3QXJjKHN2ZywgeCwgeSwgYXJjUGF0aCwgc3Ryb2tlLCBmaWxsLCBjbGFzc05hbWUsIHN0cm9rZV9kYXNoYXJyYXkgPSAiMCIsIHdpZHRoID0gMywgb3BhY2l0eSA9IDEpIHsNCiAgICAgIGxldCBhcmMgPSBzdmcuYXBwZW5kKCJwYXRoIikNCiAgICAgICAgLmF0dHIoImQiLCBhcmNQYXRoKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyB4ICsgIiwiICsgeSArICIpIikNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWRhc2hhcnJheSIsIHN0cm9rZV9kYXNoYXJyYXkpDQogICAgICAgIC5hdHRyKCJzdHJva2UtbGluZWpvaW4iLCAicm91bmQiKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSk7DQogICAgICAgIHJldHVybiBhcmM7DQogICAgfSwNCiAgICBkcmF3Q2lyY2xlKHN2ZywgeCwgeSwgciwgZmlsbCwgZGF0YSwgb3BhY2l0eSwgY2xhc3NOYW1lLCBpZE5hbWUpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIGNvbnN0IG9EYXRhID0gX3RoaXMuZGF0YQ0KICAgICAgc3ZnLmFwcGVuZCgiY2lyY2xlIikNCiAgICAgICAgLmF0dHIoImlkIiwgaWROYW1lKQ0KICAgICAgICAuYXR0cigiY2xhc3MiLCBjbGFzc05hbWUpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoImN4IiwgeCkNCiAgICAgICAgLmF0dHIoImN5IiwgeSkNCiAgICAgICAgLmF0dHIoInIiLCByKQ0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5vbigibW91c2VvdmVyIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiciIsIHIgKiAxLjEpDQogICAgICAgICAgbGV0IGNsYXNzTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIGxldCBpZE4gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdDQogICAgICAgICAgbGV0IHNob3dSZWwgPSBfdGhpcy5zaG93RW50aXR5UmVsSWRMaXN0DQogICAgICAgICAgaWYoIXNob3dSZWwuaW5jbHVkZXMocGFyc2VJbnQoaWROKSkpeyANCiAgICAgICAgICAgIHNob3dSZWwucHVzaChwYXJzZUludChpZE4pKQ0KICAgICAgICAgICAgX3RoaXMuc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlID0gMDsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZXsNCiAgICAgICAgICAgIF90aGlzLnNob3dFbnRpdHlSZWxJZE92ZXJTdGF0ZSA9IDE7DQogICAgICAgICAgfQ0KICAgICAgICAgIF90aGlzLnNob3dFbnRpdHlSZWxJZExpc3QgPSBzaG93UmVsOw0KICAgICAgICAgIGlmIChjbGFzc04gPT0gJ2xpbmVQb2ludCcpIHsNCiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJvcGFjaXR5IiwgMSkuYXR0cigiciIsIDUpDQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCIuZiIgKyBkYXRhWydpZCddKQ0KICAgICAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZCA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJ0cmFuc2Zvcm0iKQ0KICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1kLnNwbGl0KCIgIilbMF0gKyAiIHNjYWxlKDEuMSkiDQogICAgICAgICAgICAgIH0pDQoNCiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmJhc2ljUmVsIikNCiAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIik7DQogICAgICAgICAgICAgICAgbGV0IGNsYXNzTkxpc3QgPSBjbGFzc04uc3BsaXQoIiAiKTsNCiAgICAgICAgICAgICAgICBsZXQgamcgPSAwOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NOTGlzdC5sZW5ndGggLSAxOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgIGlmICgnc291cmNlJyArIGRhdGFbJ2lkJ10gPT0gY2xhc3NOTGlzdFtpXSkgeyBqZyA9IDE7IH0NCiAgICAgICAgICAgICAgICAgIGlmICgndGFyZ2V0JyArIGRhdGFbJ2lkJ10gPT0gY2xhc3NOTGlzdFtpXSkgeyBqZyA9IDE7IH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgaWYgKGpnID09IDEpIHsNCiAgICAgICAgICAgICAgICAgIGNsYXNzTiArPSAiIGFjdGl2ZVMiOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NOOw0KICAgICAgICAgICAgICB9KQ0KICAgICAgICAgIH0NCiAgICAgICAgfSkNCiAgICAgICAgLm9uKCJtb3VzZWxlYXZlIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiciIsIHIpDQogICAgICAgICAgbGV0IGNsYXNzTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIpOw0KICAgICAgICAgIA0KICAgICAgICAgIGxldCBpZE4gPSBkMy5zZWxlY3QodGhpcykuYXR0cigiaWQiKS5zcGxpdCgiXyIpWzFdDQogICAgICAgICAgbGV0IHNob3dSZWwgPSBfdGhpcy5zaG93RW50aXR5UmVsSWRMaXN0DQogICAgICAgICAgaWYoX3RoaXMuc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlID09IDEpeyANCiAgICAgICAgICAgIHNob3dSZWwucHVzaChwYXJzZUludChpZE4pKQ0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlew0KICAgICAgICAgICAgc2hvd1JlbC5zcGxpY2Uoc2hvd1JlbC5pbmRleE9mKHBhcnNlSW50KGlkTikpLDEpDQogICAgICAgICAgfQ0KICAgICAgICAgIF90aGlzLnNob3dFbnRpdHlSZWxJZExpc3QgPSBzaG93UmVsOw0KDQogICAgICAgICAgaWYgKGNsYXNzTiA9PSAnbGluZVBvaW50Jykgew0KICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoIm9wYWNpdHkiLCAwKS5hdHRyKCJyIiwgNSkNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICBkMy5zZWxlY3RBbGwoIi5mIiArIGRhdGFbJ2lkJ10pDQogICAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1kID0gZDMuc2VsZWN0KHRoaXMpLmF0dHIoInRyYW5zZm9ybSIpDQogICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWQuc3BsaXQoIiAiKVswXSArICIgc2NhbGUoMSkiDQogICAgICAgICAgICAgIH0pDQogICAgICAgICAgICBkMy5zZWxlY3QoIiNncmFwaFBhbmVsIikuc2VsZWN0QWxsKCJwYXRoIikNCiAgICAgICAgICAgICAgLmF0dHIoImNsYXNzIiwgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICAgICAgICBsZXQgdGhpc1NlbGVjdCA9IGQzLnNlbGVjdCh0aGlzKQ0KICAgICAgICAgICAgICAgIGxldCBjbGFzc04gPSB0aGlzU2VsZWN0LmF0dHIoImNsYXNzIik7DQogICAgICAgICAgICAgICAgbGV0IGNsYXNzTkxpc3QgPSBjbGFzc04uc3BsaXQoIiAiKQ0KICAgICAgICAgICAgICAgIGlmIChjbGFzc05MaXN0W2NsYXNzTkxpc3QubGVuZ3RoIC0gMV0gPT0gImFjdGl2ZVMiKSB7DQogICAgICAgICAgICAgICAgICBjbGFzc04gPSAiIjsNCiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NOTGlzdC5sZW5ndGggLSAxOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgICAgY2xhc3NOICs9ICIgIiArIGNsYXNzTkxpc3RbaV07DQogICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc04NCiAgICAgICAgICAgICAgfSkNCiAgICAgICAgICB9DQogICAgICAgIH0pDQogICAgICAgIC5vbigiY2xpY2siLCBmdW5jdGlvbiAoZCkgew0KDQogICAgICAgICAgbGV0IGlkTiA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJpZCIpLnNwbGl0KCJfIilbMV0NCiAgICAgICAgICBsZXQgc2hvd1JlbCA9IF90aGlzLnNob3dFbnRpdHlSZWxJZExpc3Q7DQogICAgICAgICAgLy8gIC0gX3RoaXMuc2hvd0VudGl0eVJlbElkT3ZlclN0YXRlOw0KICAgICAgICAgIGlmKCFzaG93UmVsLmluY2x1ZGVzKHBhcnNlSW50KGlkTikpKXsgDQogICAgICAgICAgICBzaG93UmVsID0gWyhwYXJzZUludChpZE4pKV0NCiAgICAgICAgICAgIF90aGlzLnNob3dFbnRpdHlSZWxJZE92ZXJTdGF0ZSA9IDE7DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYoc2hvd1JlbC5pbmNsdWRlcyhwYXJzZUludChpZE4pKSl7IA0KICAgICAgICAgICAgLy8gc2hvd1JlbC5maWx0ZXIoaXRlbT0+e3JldHVybiBpdGVtPT1wYXJzZUludChpZE4pfSkNCiAgICAgICAgICAgIF90aGlzLnNob3dFbnRpdHlSZWxJZE92ZXJTdGF0ZSA9IDA7DQogICAgICAgICAgICBzaG93UmVsLnNwbGljZShzaG93UmVsLmluZGV4T2YocGFyc2VJbnQoaWROKSksMSkNCiAgICAgICAgICB9DQogICAgICAgICAgX3RoaXMuc2hvd0VudGl0eVJlbElkTGlzdCA9IHNob3dSZWw7DQoNCiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigiciIsIHIpOw0KICAgICAgICAgIGQzLnNlbGVjdEFsbCgiLmYiICsgZGF0YVsnaWQnXSkNCiAgICAgICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZCA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJ0cmFuc2Zvcm0iKQ0KICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZC5zcGxpdCgiICIpWzBdICsgIiBzY2FsZSgxKSINCiAgICAgICAgICAgIH0pDQogICAgICAgICAgbGV0IHRoaXNJZCA9IHRoaXMuaWQuc3BsaXQoIl8iKVsxXTsNCiAgICAgICAgICBfdGhpcy5jdXJFbnRJZCA9IHRoaXNJZDsNCiAgICAgICAgICBsZXQgdGhpc0RhdGEgPSBvRGF0YS5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWydpZCddID09IHRoaXNJZCB9KQ0KICAgICAgICAgIGxldCB0aGlzVGltZSA9IHRoaXNEYXRhWyd0aW1lJ107DQogICAgICAgICAgX3RoaXMuY2xpY2tfRW50KHRoaXNUaW1lKTsNCiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzVGltZSx0aGlzSWQsdGhpc0RhdGEpDQogICAgICAgIH0pDQogICAgICAgIC5vbigiY29udGV4dG1lbnUiLCBmdW5jdGlvbiAoZCwgaSkgew0KICAgICAgICAgIGQucHJldmVudERlZmF1bHQoKTsNCg0KICAgICAgICAgIGxldCB0aGlzSWQgPSB0aGlzLmlkLnNwbGl0KCJfIilbMV07DQogICAgICAgICAgbGV0IHRoaXNTaG93RW50aXR5RGF0YSA9IF90aGlzLnNob3dFbnRpdHlMaXN0LmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2lkJ10gPT0gdGhpc0lkIH0pOw0KICAgICAgICAgIGxldCB0aGlzU29ucyA9IHRoaXNTaG93RW50aXR5RGF0YVsnc29uJ107DQogICAgICAgICAgaWYgKHRoaXNTb25zLmxlbmd0aCAhPSAwKSB7DQogICAgICAgICAgICBsZXQgc29ucyA9IHRvb2xzLmRlZXBDbG9uZSh0aGlzU29ucyk7DQogICAgICAgICAgICBsZXQgc2hvd0phZ2UgPSBmYWxzZTsNCiAgICAgICAgICAgIGxldCBpID0gMA0KICAgICAgICAgICAgd2hpbGUgKChzb25zLmxlbmd0aCA+IDApKSB7DQogICAgICAgICAgICAgIGxldCBzID0gc29uc1swXTsNCiAgICAgICAgICAgICAgc29ucy5zcGxpY2UoMCwgMSk7DQogICAgICAgICAgICAgIGxldCBjdXJzb24gPSBfdGhpcy5zaG93RW50aXR5TGlzdC5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWydpZCddID09IHMgKyAnJyB9KQ0KICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7DQogICAgICAgICAgICAgICAgaSsrOw0KICAgICAgICAgICAgICAgIHNob3dKYWdlID0gIWN1cnNvblsnc2hvdyddDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgLy8gWydzaG93J10gPSAhX3RoaXMuc2hvd0VudGl0eUxpc3QuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnaWQnXSA9PSB0aGlzU29uc1tzXSB9KVsnc2hvdyddDQogICAgICAgICAgICAgIGN1cnNvblsnc2hvdyddID0gc2hvd0phZ2U7DQogICAgICAgICAgICAgIGxldCBjdXJnc29uID0gY3Vyc29uWydzb24nXTsNCiAgICAgICAgICAgICAgaWYgKCFzaG93SmFnZSkgew0KICAgICAgICAgICAgICAgIGZvciAobGV0IGdzID0gMDsgZ3MgPCBjdXJnc29uLmxlbmd0aDsgZ3MrKykgew0KICAgICAgICAgICAgICAgICAgc29ucy5wdXNoKGN1cmdzb25bZ3NdKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgX3RoaXMudXBkYXRhR3JhcGgoKQ0KICAgICAgICB9KTsNCiAgICAgIC8vIC5vbigiIikNCiAgICB9LA0KICAgIGRyYXdSZWN0KHN2ZywgeCwgeSwgdywgaCwgcngsIHJ5LCBmaWxsLCBvcGFjaXR5LCBzdHJva2UsIGlkID0gJ3JlY3QnLHN0cm9rZVcgPSAxLjUsY2xhc3NOID0gJ3JlY3QnKSB7DQogICAgICBkMy5zZWxlY3QoYCMke2lkfWApLnJlbW92ZSgpDQogICAgICBsZXQgcmVjdCA9IHN2Zy5hcHBlbmQoInJlY3QiKQ0KICAgICAgICAuYXR0cigiaWQiLCBpZCkNCiAgICAgICAgLmF0dHIoImNsYXNzIixjbGFzc04pDQogICAgICAgIC5hdHRyKCJ4IiwgeCkNCiAgICAgICAgLmF0dHIoInkiLCB5KQ0KICAgICAgICAuYXR0cigicngiLCByeCkNCiAgICAgICAgLmF0dHIoInJ5IiwgcnkpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3KSAvL+WImuaJjeiuvue9rueahOWdl+eahOWuveW6pg0KICAgICAgICAuYXR0cigiZmlsbCIsIGZpbGwpDQogICAgICAgIC5hdHRyKCJvcGFjaXR5Iiwgb3BhY2l0eSkNCiAgICAgICAgLmF0dHIoInN0cm9rZSIsIHN0cm9rZSkNCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsIGAke3N0cm9rZVd9cHhgKTsNCiAgICAgIHJldHVybiByZWN0Ow0KICAgIH0sDQogICAgZHJhd1R4dChzdmcsIHgsIHksIHdpZHRoLCB0eHRzLCBmaWxsLCBmb250c2l6ZSA9IDEyLCBpZE4pIHsNCiAgICAgIGxldCB0eCA9IHg7DQogICAgICBsZXQgdHkgPSB5Ow0KICAgICAgbGV0IHByZVdpZHRoID0gMDsNCiAgICAgIGxldCBwcmVJZE4gPSAwOw0KICAgICAgbGV0IHByZXRleHQgPSAnJw0KICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0eHRzLmxlbmd0aDsgdCsrKSB7DQogICAgICAgIHByZXRleHQgKz0gIiAiICsgdHh0c1t0XTsNCiAgICAgICAgbGV0IHR4dCA9IHN2Zy5hcHBlbmQoInRleHQiKQ0KICAgICAgICAgIC5hdHRyKCJ5IiwgdHkpDQogICAgICAgICAgLmF0dHIoIngiLCB0eCkNCiAgICAgICAgICAuYXR0cigiaWQiLCBgJHtpZE59XyR7dH1gKQ0KICAgICAgICAgIC5hdHRyKCJmaWxsIiwgZmlsbCkNCiAgICAgICAgICAuYXR0cigiZm9udC1zaXplIiwgZm9udHNpemUpDQogICAgICAgICAgLnN0eWxlKCJ0ZXh0LWFuY2hvciIsICJtaWRkbGUiKQ0KICAgICAgICAgIC50ZXh0KHByZXRleHQpDQogICAgICAgIGxldCB0ZXh0V2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtpZE59XyR7dH1gKS5nZXRCQm94KCkud2lkdGg7DQogICAgICAgIGlmICgodGV4dFdpZHRoID4gd2lkdGgpIHx8ICh0ID09IHR4dHMubGVuZ3RoIC0gMSkpIHsNCiAgICAgICAgICBwcmV0ZXh0ID0gJyc7DQogICAgICAgICAgdHggPSB4Ow0KICAgICAgICAgIHR5ICs9IDI1Ow0KICAgICAgICB9DQogICAgICAgIGVsc2Ugew0KICAgICAgICAgIHR4dC5yZW1vdmUoKQ0KICAgICAgICB9DQogICAgICAgIHByZVdpZHRoICs9IHRleHRXaWR0aDsNCiAgICAgIH0NCiAgICB9LA0KICAgIGRyYXdUaW1lTGluZShzdmcsIHBhdGgsIHN0cm9rZSwgd2lkdGgsIHN0cm9rZV9kYXNoYXJyYXkgPSAiMCIsIGlkTmFtZSwgY2xhc3NOYW1lKSB7DQogICAgICBzdmcuYXBwZW5kKCdwYXRoJykNCiAgICAgICAgLmF0dHIoJ2QnLCBwYXRoLnRvU3RyaW5nKCkpDQogICAgICAgIC5hdHRyKCdzdHJva2UnLCBzdHJva2UpDQogICAgICAgIC5hdHRyKCdjbGFzcycsIGNsYXNzTmFtZSkNCiAgICAgICAgLmF0dHIoJ2lkJywgaWROYW1lKQ0KICAgICAgICAuYXR0cigic3Ryb2tlLWRhc2hhcnJheSIsIHN0cm9rZV9kYXNoYXJyYXkpDQogICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpDQogICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQpIHsNCiAgICAgICAgICBsZXQgdGhpc1NlbGVjdCA9IGQzLnNlbGVjdCh0aGlzKQ0KICAgICAgICAgIGxldCBjbGFzc04gPSB0aGlzU2VsZWN0LmF0dHIoImNsYXNzIik7DQogICAgICAgICAgbGV0IGlkTiA9IHRoaXNTZWxlY3QuYXR0cigiaWQiKTsNCiAgICAgICAgICBpZiAoY2xhc3NOLnNwbGl0KCIgIilbMF0gPT0gImJhc2ljUmVsIikgew0KICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoImNsYXNzIiwgY2xhc3NOICsgIiBhY3RpdmVTIik7DQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KICAgICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoZCkgew0KICAgICAgICAgIGxldCB0aGlzU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMpDQogICAgICAgICAgbGV0IGNsYXNzTiA9IHRoaXNTZWxlY3QuYXR0cigiY2xhc3MiKTsNCiAgICAgICAgICBsZXQgY2xhc3NOTGlzdCA9IGNsYXNzTi5zcGxpdCgiICIpDQogICAgICAgICAgaWYgKGNsYXNzTkxpc3RbY2xhc3NOTGlzdC5sZW5ndGggLSAxXSA9PSAiYWN0aXZlUyIpIHsNCiAgICAgICAgICAgIGNsYXNzTiA9ICIiOw0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc05MaXN0Lmxlbmd0aCAtIDE7IGkrKykgew0KICAgICAgICAgICAgICBjbGFzc04gKz0gY2xhc3NOTGlzdFtpXSArICIgIjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCJjbGFzcyIsIGNsYXNzTik7DQogICAgICAgICAgfQ0KICAgICAgICB9KQ0KICAgIH0sDQogICAgdHJhbnNmb3JtR3JhcGhTdmcoZmxhZykgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IGdyb3VwcyA9IF90aGlzLmdyb3Vwc1N2ZzsNCg0KICAgICAgbGV0IHNjYWxlUHJlID0gX3RoaXMuZ3JhcGhTdmdTY2FsZTsNCg0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbjsNCiAgICAgIGlmIChmbGFnID09ICdsZWZ0Jykgew0KICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YICs9IDEwOw0KICAgICAgfQ0KICAgICAgaWYgKGZsYWcgPT0gJ3JpZ2h0Jykgew0KICAgICAgICBfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YIC09IDEwOw0KICAgICAgfQ0KICAgICAgLy8gZ3JvdXBzLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChfdGhpcy5ncmFwaEdUcmFuc2Zvcm1YKSArICcsJyArIChtYXJnaW4udG9wKSArICcpIHNjYWxlKCcgKyAoc2NhbGVQcmUpICsgJyknKQ0KICAgIH0sDQogICAgdXBkYXRhQXNzaXN0R3JhcGhQYW5lbCgpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5ncm91cHNTdmcuaHRtbCgpOw0KICAgICAgbGV0IGhlaWdodCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJhc3Npc3RHcmFwaFBhbmVsIikuY2xpZW50SGVpZ2h0Ow0KICAgICAgbGV0IHdpZHRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImFzc2lzdEdyYXBoUGFuZWwiKS5jbGllbnRXaWR0aDsNCiAgICAgIGQzLnNlbGVjdCgnI2Fzc2lzdEdyYXBoUGFuZWwnKS5zZWxlY3QoJ3N2ZycpLnJlbW92ZSgpOw0KICAgICAgbGV0IHRyYW5zWCA9IF90aGlzLmFzc2lzdEdUcmFuc2Zvcm1YOw0KICAgICAgbGV0IHRyYW5zWSA9IF90aGlzLmFzc2lzdEdUcmFuc2Zvcm1ZOw0KICAgICAgdmFyIGRpdiA9IGQzLnNlbGVjdCgnI2Fzc2lzdEdyYXBoUGFuZWwnKQ0KICAgICAgICAuYXBwZW5kKCdzdmcnKQ0KICAgICAgICAuYXR0cigid2lkdGgiLCB3aWR0aCkNCiAgICAgICAgLmF0dHIoImhlaWdodCIsIGhlaWdodCkNCiAgICAgICAgLmFwcGVuZCgiZyIpDQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBgdHJhbnNsYXRlKCR7dHJhbnNYfSwke3RyYW5zWX0pYCkNCiAgICAgICAgLmh0bWwoY29udGVudCk7DQogICAgfSwNCiAgICBtb3ZlR3JhcGhMZWZ0KGUpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLm1vdmVGbGFnID09IHRydWU7DQogICAgICBjbGVhckludGVydmFsKHRoaXMubW92ZVRpbWVyKS8vIOa4hemZpOWumuaXtuWZqA0KICAgICAgdGhpcy5tb3ZlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IF90aGlzLnRyYW5zZm9ybUdyYXBoU3ZnKCJsZWZ0IikgfSwgMTApLy9fdGhpcy50cmFuc2Zvcm1HcmFwaFN2ZygnbGVmdCcpLCAxMDApOw0KICAgIH0sDQogICAgbW92ZUdyYXBoUmlnaHQoZSkgew0KICAgICAgY29uc3QgX3RoaXMgPSB0aGlzOw0KICAgICAgLy8gY29uc29sZS5sb2coIuKaofCfkLLwn6un4p2E77iP8J+Rge+4jyIsZSkNCiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlVGltZXIpLy8g5riF6Zmk5a6a5pe25ZmoDQogICAgICBfdGhpcy5tb3ZlRmxhZyA9PSB0cnVlOw0KICAgICAgdGhpcy5tb3ZlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IF90aGlzLnRyYW5zZm9ybUdyYXBoU3ZnKCJyaWdodCIpIH0sIDEwKS8vX3RoaXMudHJhbnNmb3JtR3JhcGhTdmcoJ2xlZnQnKSwgMTAwKTsNCiAgICB9LA0KICAgIGxlYXZlR3JhcGhNb3ZlKCkgew0KICAgICAgLy8gdGhpcy5tb3ZlRmxhZyA9PSBmYWxzZTsNCiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlVGltZXIpLy8g5riF6Zmk5a6a5pe25ZmoDQogICAgICAvLyB0aGlzLmdyYXBoR1RyYW5zZm9ybVggPSAwOw0KICAgIH0sDQogICAgdXBkYXRhR3JhcGgoKSB7DQogICAgICB2YXIgX3RoaXMgPSB0aGlzOw0KICAgICAgbGV0IG1hcmdpbiA9IF90aGlzLm1hcmdpbg0KICAgICAgbGV0IHdpZHRoID0gX3RoaXMuJHJlZnMuZ3JhcGhEaXYub2Zmc2V0V2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsNCiAgICAgIGxldCBoZWlnaHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ3JhcGhQYW5lbCIpLmNsaWVudEhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tOw0KICAgICAgbGV0IGhlaWdodFRpbWVBeGlzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoImdyYXBoVGltZUF4aXNQYW5lbCIpLmNsaWVudEhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tOw0KICAgICAgX3RoaXMud2lkdGggPSB3aWR0aDsNCiAgICAgIF90aGlzLmhlaWdodCA9IGhlaWdodDsNCiAgICAgIGQzLnNlbGVjdCgiI2dyYXBoUGFuZWwiKS5zZWxlY3QoInN2ZyIpLnJlbW92ZSgpDQogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjZ3JhcGhQYW5lbCIpLmFwcGVuZCgic3ZnIikNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgX3RoaXMucm9vdFN2ZyA9IHN2ZzsNCiAgICAgIGQzLnNlbGVjdCgiI2dyYXBoVGltZUF4aXNQYW5lbCIpLnNlbGVjdCgic3ZnIikucmVtb3ZlKCkNCiAgICAgIHZhciBUaW1lQXhpc1N2ZyA9IGQzLnNlbGVjdCgiI2dyYXBoVGltZUF4aXNQYW5lbCIpLmFwcGVuZCgic3ZnIikNCiAgICAgICAgLmF0dHIoIndpZHRoIiwgd2lkdGgpDQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCBoZWlnaHQpOw0KICAgICAgX3RoaXMuVGltZUF4aXNTdmcgPSBUaW1lQXhpc1N2ZzsNCiAgICAgIGxldCBkYXRhID0gX3RoaXMuZGF0YTsNCg0KICAgICAgbGV0IG1heERJbXBvcnRhbmNlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107IH0pKQ0KICAgICAgbGV0IG1pbkRJbXBvcnRhbmNlID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydpbXBvcnRhbmNlJ107IH0pKQ0KICAgICAgbGV0IG1heERSZWxldmFuY2UgPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsnYXR0cmlidXRlJ11bJ3JlbGV2YW5jZSddOyB9KSkNCiAgICAgIGxldCBtaW5EUmVsZXZhbmNlID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbJ2F0dHJpYnV0ZSddWydyZWxldmFuY2UnXTsgfSkpDQogICAgICBsZXQgbWF4RER1cmF0aW9uID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHRvb2xzLnRpbWUyc2Vjb25kcyhkWyd0aW1lJ11bMV0pIC0gdG9vbHMudGltZTJzZWNvbmRzKGRbJ3RpbWUnXVswXSk7IH0pKQ0KICAgICAgbGV0IG1heFRvdGFsRHVyYXRpb24gPSBNYXRoLm1heC5hcHBseShNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFsndG90YWxEdXJhdGlvbiddOyB9KSkNCiAgICAgIF90aGlzLmRyYXdFbnRpdHlMb2NhdGlvbiA9IFtdOw0KICAgICAgX3RoaXMubWluREltcG9ydGFuY2UgPSBtaW5ESW1wb3J0YW5jZTsNCiAgICAgIF90aGlzLm1heERJbXBvcnRhbmNlID0gbWF4REltcG9ydGFuY2U7DQogICAgICBfdGhpcy5taW5EUmVsZXZhbmNlID0gbWluRFJlbGV2YW5jZTsNCiAgICAgIF90aGlzLm1heERSZWxldmFuY2UgPSBtYXhEUmVsZXZhbmNlOw0KICAgICAgX3RoaXMubWF4RER1cmF0aW9uID0gbWF4RER1cmF0aW9uOw0KICAgICAgX3RoaXMubWF4VG90YWxEdXJhdGlvbiA9IG1heFRvdGFsRHVyYXRpb247DQoNCiAgICAgIGxldCBjdXJyZW50TWF4Q29sb3IgPSBfdGhpcy5pbXBvcnRhbmNlTWF4Q29sb3I7DQogICAgICBsZXQgY3VycmVudE1pbkNvbG9yID0gX3RoaXMuaW1wb3J0YW5jZU1pbkNvbG9yOw0KICAgICAgX3RoaXMuaW1wb3J0YW5jZUNvbG9yX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFttaW5ESW1wb3J0YW5jZSwgbWF4REltcG9ydGFuY2VdKS5yYW5nZShbMCwgMV0pOw0KICAgICAgX3RoaXMuaW1wb3J0YW5jZUNvbXB1dGVfY29sb3IgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50TWluQ29sb3IsIGN1cnJlbnRNYXhDb2xvcik7DQogICAgICBfdGhpcy5yZWxldmFuY2VTY2FsZV9saW5lYXIgPSBkMy5zY2FsZUxpbmVhcihbbWluRFJlbGV2YW5jZSwgbWF4RFJlbGV2YW5jZV0sIFsyMCwgNTBdKQ0KICAgICAgX3RoaXMudG90YWxEdXJhdGlvblNjYWxlX2xpbmVhciA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBtYXhUb3RhbER1cmF0aW9uXSkucmFuZ2UoWzIwLCA2MF0pOw0KDQogICAgICBfdGhpcy5kcmF3TWFpbihzdmcpOw0KICAgICAgLy8gfSk7DQogICAgfSwNCiAgICB6b29tSW5MYXlvdXRDbGsoKSB7DQogICAgICBjb25zdCBfdGhpcyA9IHRoaXM7DQogICAgICBfdGhpcy5sYXlvdXRTaG93ICs9IDE7DQogICAgICBpZiAoX3RoaXMubGF5b3V0U2hvdyA+IDMpIHsNCiAgICAgICAgX3RoaXMubGF5b3V0U2hvdyA9IDM7DQogICAgICB9DQogICAgICAvLyBfdGhpcy51cGRhdGFHcmFwaCgpOw0KICAgIH0sDQogICAgem9vbU91dExheW91dENsaygpIHsNCiAgICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICAgIF90aGlzLmxheW91dFNob3cgLT0gMTsNCiAgICAgIGlmIChfdGhpcy5sYXlvdXRTaG93IDwgMCkgew0KICAgICAgICBfdGhpcy5sYXlvdXRTaG93ID0gMDsNCiAgICAgIH0NCiAgICAgIC8vIF90aGlzLnVwZGF0YUdyYXBoKCk7DQoNCiAgICB9LA0KICAgIGNsaWNrX0VudCh0aW1lKSB7DQogICAgICB0aGlzLiRlbWl0KCJ0aW1lRHVyIiwgdGltZSk7DQogICAgfSwNCiAgfSwNCiAgY3JlYXRlZCgpIHsNCiAgICB2YXIgX3RoaXMgPSB0aGlzOw0KICAgIGxldCBtYXJnaW4gPSBfdGhpcy5tYXJnaW4NCiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7DQogICAgICBfdGhpcy51cGRhdGFHcmFwaCgpOw0KICAgICAgX3RoaXMudXBkYXRhQXNzaXN0R3JhcGhQYW5lbCgpOw0KICAgIH0pOw0KICB9LA0KICBtb3VudGVkKCkgew0KICAgIGNvbnN0IF90aGlzID0gdGhpczsNCiAgICBsZXQgd2lkdGggPSBfdGhpcy4kcmVmcy5ncmFwaERpdi5vZmZzZXRXaWR0aDsNCiAgICBsZXQgaGVpZ2h0ID0gX3RoaXMuaGVpZ2h0Ow0KICAgIGxldCBzaG93RW50aXR5TGlzdCA9IHRvb2xzLmRlZXBDbG9uZShfdGhpcy5kYXRhKTsNCiAgICBmb3IgKGxldCBlIGluIHNob3dFbnRpdHlMaXN0KSB7DQogICAgICBzaG93RW50aXR5TGlzdFtlXVsnc2hvdyddID0gdHJ1ZTsNCiAgICB9DQogICAgX3RoaXMuc2hvd0VudGl0eUxpc3QgPSBzaG93RW50aXR5TGlzdDsNCiAgICAvLyBsZXQgd2lkdGggPSBfdGhpcy53aWR0aDsNCiAgICB0aGlzLiRidXMuJG9uKCdncmFwaERhdGEnLCAodmFsKSA9PiB7DQogICAgICBfdGhpcy5kYXRhID0gdmFsOw0KICAgICAgbGV0IHNob3dFbnRpdHlMaXN0ID0gdG9vbHMuZGVlcENsb25lKF90aGlzLmRhdGEpOw0KICAgICAgZm9yIChsZXQgZSBpbiBzaG93RW50aXR5TGlzdCkgew0KICAgICAgICBzaG93RW50aXR5TGlzdFtlXVsnc2hvdyddID0gdHJ1ZTsNCiAgICAgIH0NCiAgICAgIF90aGlzLnNob3dFbnRpdHlMaXN0ID0gc2hvd0VudGl0eUxpc3Q7DQogICAgICBfdGhpcy51cGRhdGFHcmFwaCgpOw0KICAgIH0pOw0KDQogICAgLy8gdGhpcy4kcmVmcy5tb3ZlR3JhcGhMZWZ0LmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlb3ZlciIsIF90aGlzLm1vdmVHcmFwaExlZnQpOyAvLyDnm5HlkKzngrnlh7vkuovku7YNCiAgICAvLyB0aGlzLiRyZWZzLm1vdmVHcmFwaFJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbW92ZSIsIF90aGlzLm1vdmVHcmFwaFJpZ2h0KTsgLy8g55uR5ZCs54K55Ye75LqL5Lu2DQogICAgLy8gdGhpcy4kcmVmcy5tb3ZlR3JhcGhMZWZ0LmFkZEV2ZW50TGlzdGVuZXIoIm1vdXNlbGVhdmUiLCBfdGhpcy5sZWF2ZUdyYXBoTW92ZSk7IC8vIOebkeWQrOeCueWHu+S6i+S7tg0KICAgIC8vIHRoaXMuJHJlZnMubW92ZUdyYXBoUmlnaHQuYWRkRXZlbnRMaXN0ZW5lcigibW91c2VsZWF2ZSIsIF90aGlzLmxlYXZlR3JhcGhNb3ZlKTsgLy8g55uR5ZCs54K55Ye75LqL5Lu2DQoNCiAgfSwNCiAgYmVmb3JlRGVzdHJveSgpIHsNCiAgICBjbGVhckludGVydmFsKHRoaXMubW92ZVRpbWVyKTsNCiAgfSwNCn0gDQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/components/Graph","sourcesContent":["<!-- eslint-disable no-unused-vars -->\r\n<!-- eslint-disable no-unused-vars -->\r\n\r\n<template>\r\n  <div class=\"graph\" ref=\"graphDiv\">\r\n    <!-- <div class=\"panelHead\">ConceptMap</div> -->\r\n    <div id=\"graphTimeAxisPanel\" class=\"\">\r\n    </div>\r\n    <div id=\"graphPanel\" class=\"panelBody\">\r\n    </div>\r\n    <!-- <div id=\"moveLeft\" ref=\"moveGraphLeft\"></div>\r\n                    <div id=\"moveRight\" ref=\"moveGraphRight\"></div> -->\r\n    <div id=\"assistGraphPanel\" class=\"panel\">\r\n      <div class=\"panelHead\"></div>\r\n    </div>\r\n\r\n    <div id=\"zoomInDiv\" @click=\"zoomInLayoutClk\">\r\n      <img class=\"icons\" :src=\"zoomInUrl\">\r\n    </div>\r\n    <div id=\"zoomOutDiv\" @click=\"zoomOutLayoutClk\">\r\n      <img class=\"icons\" :src=\"zoomOutUrl\">\r\n    </div>\r\n    <div id=\"editToolDiv\" @click=\"editToolClk\">\r\n      <img class=\"icons\" :src=\"editToolUrl\">\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nimport * as d3 from 'd3'\r\nimport { onMounted, ref } from 'vue';\r\nimport filenames from \"@/utils/fileName\";\r\nimport domtoimage from 'dom-to-image';\r\nimport TestJson from \"@/assets/json/case2_fin.json\";\r\nimport TestRelJson from \"@/assets/json/case2_fin_rel.json\";\r\nimport tools from \"@/utils/tools.js\";\r\n\r\nexport default {\r\n  props: [\"videoTime\"],\r\n  data() {\r\n    return {\r\n      data: TestJson,\r\n      gData: \"TestJson\",\r\n      relData: TestRelJson,\r\n      assistGTransformX: 10,\r\n      assistGTransformY: 100,\r\n      drawEntityLocation: [],\r\n      showEntityList: [],\r\n      overEntityId:'',\r\n      showEntityRelIdList: [],\r\n      showEntityRelIdOverState: '',\r\n      rootEntityList: [],\r\n      rootSvg: null,\r\n      TimeAxisSvg: null,\r\n      groupsSvg: null,\r\n      arcG: null,\r\n      curEntId: '',\r\n      minDImportance: 0,\r\n      maxDImportance: 0,\r\n      minDRelevance: 0,\r\n      maxDRelevance: 0,\r\n      maxDDuration: 0,\r\n      timeAxisX: 0,\r\n      timeAxisW: 200,\r\n      timeAxisDropFlag: 0,\r\n      timeAxisDownX: 0,\r\n      timeAxisDownW: 60,\r\n      maxTotalDuration: 0,\r\n      videoDuration: 672,\r\n      totalDuration: 1000,\r\n      importanceColor_linear: null,\r\n      importanceCompute_color: null,\r\n      relevanceScale_linear: null,\r\n      totalDurationScale_linear: null,\r\n      sumTotalDuration: 0,\r\n      // importanceMinColor: \"rgb(1, 164, 183)\",\r\n      // importanceMaxColor: \"rgb(106, 52, 127)\",\r\n      zoomInUrl: require(\"@/assets/img/zoomIn.png\"),\r\n      zoomOutUrl: require(\"@/assets/img/zoomOut.png\"),\r\n      editToolUrl: require(\"@/assets/img/edit.png\"),\r\n      layoutShow: 2,\r\n      graphGTransformK: 1,\r\n      graphGTransformX: 10,\r\n      graphGTransformY: 100,\r\n      graphGMoveX: 10,\r\n      graphSvgScale: 1,\r\n      moveTimer: null,\r\n      moveFlag: false,\r\n      importanceMinColor: \"rgb(203, 230, 209)\",\r\n      importanceMaxColor: \"rgb(22, 144, 207)\",\r\n      stepX: 150,\r\n      stepY: 100,\r\n      circleInterval: 55,\r\n      width: 0,\r\n      height: 0,\r\n      curToolState: 'unEdit',\r\n      margin: { top: 80, right: 20, bottom: 0, left: 20 },\r\n      color: [\r\n        \"rgb(255,60,60)\",\r\n        \"rgb(0, 178, 171)\",\r\n        // \"rgb(255,83,255)\",\r\n        \"rgb(235,135,162)\",\r\n        \"rgb(255,178,101)\",\r\n        \"rgb(63,151,134)\",\r\n        \"rgb(83,255,255)\",\r\n        \"rgb(0,122,244)\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n      mcolor: [\r\n        \"rgb(125, 66, 206)\",\r\n        \"rgb(248, 134, 124)\",\r\n        \"rgb(50, 198, 191)\",\r\n        \"rgb(135, 126, 253)\",\r\n        \"rgb(198, 121, 123)\",\r\n        \"rgb(252, 177, 49)\",\r\n        \"rgb(112, 202, 229)\",\r\n      ],\r\n      // mcolor: [\r\n      //   \"rgb(91, 107, 255)\",\r\n      //   \"rgb(0, 178, 171)\",\r\n      //   // \"rgb(6, 214, 160)\",\r\n      //   \"rgb(255, 120, 90)\",\r\n      //   \"rgb(125, 98, 211)\",\r\n      //   \"rgb(255, 113, 212)\",\r\n      //   \"rgb(112, 214, 255)\",\r\n      //   \"rgb(255, 159, 28)\",\r\n      //   \"rgb(255, 77, 109)\",\r\n      // ],\r\n      mDarkcolor: [\r\n        \"rgb(95, 39, 179)\",\r\n        \"rgb(221, 83, 72)\",\r\n        \"rgb(0, 158, 148)\",\r\n        \"rgb(93, 88, 202)\",\r\n        \"rgb(180, 72, 79)\",\r\n        \"rgb(202, 134, 32)\",\r\n        \"rgb(46, 174, 202)\",\r\n      ],\r\n      mLigntcolor: [\r\n        \"#ff9c9c\",\r\n        \"#cc88b0\",\r\n        \"#ffa8ff\",\r\n        \"#e3b097\",\r\n        \"#f4c3d0\",\r\n        \"#f4f4d0\",\r\n        \"#ffd8b1\",\r\n        \"#9ecac2\",\r\n        \"#a8ccff\",\r\n        \"#97e3ba\",\r\n        \"#6f8be0\",\r\n        \"rgb(0,122,244)\",\r\n        \"#b6a2f7\",\r\n        \"rgb(168,168,255)\",\r\n        \"rgb(200,200,200)\",\r\n      ],\r\n    };\r\n  },\r\n\r\n  watch: {\r\n    type(val) {\r\n    },\r\n    timeAxisX(val) {\r\n      const _this = this;\r\n      _this.updataTimeAxisDur(_this.TimeAxisSvg, _this.timeAxisX, _this.timeAxisW);\r\n    },\r\n    curEntId(val) {\r\n      const _this = this;\r\n      _this.overEntityId = val;\r\n      _this.$bus.$emit(\"selectEnt\", val);\r\n      let entityLocationData = _this.drawEntityLocation;\r\n\r\n      let relData = _this.relData;\r\n      let showJageData = _this.showEntityList;\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n        let sorceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n          let trnId = '-1';\r\n          if (sorceId == parseInt(val)) {\r\n            trnId = targetId;\r\n          }\r\n          else if (targetId == parseInt(val)) {\r\n            trnId = sorceId;\r\n          }\r\n          if (trnId != '-1') {\r\n            let curEnt = entityLocationData.find(function (d) { return parseInt(d['id']) == trnId });\r\n            _this.assistGTransformX = parseInt(-curEnt['x']) + parseFloat(curEnt['r']) + 150;\r\n            _this.assistGTransformY = parseInt(-curEnt['y']) + parseFloat(curEnt['r']) + 300;\r\n            _this.updataAssistGraphPanel();\r\n          }\r\n        }\r\n\r\n      };\r\n      let similarityRel = relData['similarityRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n        let sorceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n          let trnId = '-1';\r\n          if (sorceId == parseInt(val)) {\r\n            trnId = targetId;\r\n          }\r\n          else if (targetId == parseInt(val)) {\r\n            trnId = sorceId;\r\n          }\r\n          if (trnId != '-1') {\r\n            let curEnt = entityLocationData.find(function (d) { return parseInt(d['id']) == trnId });\r\n            _this.assistGTransformX = parseInt(-curEnt['x']) + parseFloat(curEnt['r']) + 150;\r\n            _this.assistGTransformY = parseInt(-curEnt['y']) + parseFloat(curEnt['r']) + 300;\r\n            _this.updataAssistGraphPanel();\r\n          }\r\n        }\r\n\r\n      };\r\n\r\n\r\n    },\r\n    overEntityId(val){\r\n      const _this = this;\r\n      \r\n      let relList = [];\r\n      let relRootList = [];\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let basicRel = relData['basicRel'];\r\n      d3.selectAll('.timeAxisEnt').attr(\"stroke-width\",0).attr(\"opacity\",0.4).attr(\"stroke\",function(){\r\n        let cid = d3.select(this).attr(\"id\").split(\"_\")[1];\r\n        let nd = oData.find(function (d) { return d['id'] == cid });\r\n        console.log(2222,nd)\r\n        return nd['colorD']\r\n      });\r\n      for (let re = 0; re < basicRel.length; re++) {\r\n\r\n        let sorceId = basicRel[re][0];\r\n        let targetId = basicRel[re][1];\r\n        let cNode = '';\r\n        if (sorceId == val) {\r\n          cNode = oData.find(function (d) { return d['id'] == targetId });\r\n          relList.push(targetId);\r\n          relRootList.push(cNode['rootIndex']);\r\n        }\r\n\r\n        if (targetId == val) {\r\n          cNode = oData.find(function (d) { return d['id'] == sorceId });\r\n          relList.push(sorceId);\r\n          relRootList.push(cNode['rootIndex']);\r\n        }\r\n      };\r\n      console.log(1111111111111111111111111111111,relList);\r\n      relList.forEach((self, indx, arr) => {\r\n\r\n        d3.select(`#timeAxisEnt_${self}`).attr(\"stroke\",'white').attr(\"stroke-width\",2).attr(\"opacity\",1);\r\n      })\r\n        d3.select(`#timeAxisEnt_${val}`).attr(\"stroke-width\",2).attr(\"opacity\",1);\r\n    },\r\n    showEntityRelIdList(val){\r\n      this.updataRel();\r\n    },\r\n    groupsSvg: {\r\n      deep: true,\r\n      handler() {\r\n        this.updataAssistGraphPanel();\r\n      }\r\n    },\r\n    gData(val) {\r\n    },\r\n    layoutShow(val) {\r\n      const _this = this;\r\n      let showEntityList = tools.deepClone(_this.data);\r\n      for (let e in showEntityList) {\r\n        if (parseInt(showEntityList[e]['layout']) < parseInt(val))\r\n          showEntityList[e]['show'] = true;\r\n        else {\r\n          showEntityList[e]['show'] = false;\r\n        }\r\n      }\r\n      _this.showEntityList = showEntityList;\r\n      _this.updataGraph();\r\n    },\r\n    data(val) {\r\n    },\r\n    videoTime(val) {\r\n      const _this = this;\r\n      let entityLocationData = _this.drawEntityLocation;\r\n      for (let e = 0; e < entityLocationData.length; e++) {\r\n        let curD = entityLocationData[e];\r\n        let timeStart = tools.time2seconds(entityLocationData[e]['time'][0]);\r\n        let timeEnd = tools.time2seconds(entityLocationData[e]['time'][1]);\r\n        if ((val > timeStart) && (val < timeEnd)) {\r\n          let entX = entityLocationData[e]['x'];\r\n          let entY = entityLocationData[e]['y'];\r\n          let entR = entityLocationData[e]['r'];\r\n          let moveLinear = d3.scaleLinear([timeStart, timeEnd], [entX - entR, entX + entR])\r\n          _this.graphGTransformX = -moveLinear((val));\r\n        }\r\n      }\r\n    },\r\n    graphGMoveX(val) {\r\n      const _this = this;\r\n      console.log(val);\r\n      let data = _this.drawEntityLocation;\r\n      let stjg = 0;\r\n      let enjg = 0;\r\n      let snode = '';\r\n      let enode = '';\r\n      let width = 1590\r\n      data.forEach((self, indx, arr) => {\r\n        let entx = self['x'] * _this.graphGTransformK;\r\n        let transformX = entx + val;\r\n        if ((transformX > 0) && (transformX < width)) {\r\n          stjg++;\r\n        }\r\n        else {\r\n          if ((stjg > 0) && enjg == 0) {\r\n            enode = self;\r\n            enjg = 1\r\n          }\r\n        }\r\n        if (stjg == 1) {\r\n          snode = self\r\n        }\r\n      })\r\n      let ew = enode['timeW'];\r\n      if(snode == ''){\r\n        _this.timeAxisX =0\r\n      }\r\n      else\r\n      _this.timeAxisX = snode['timeX'];\r\n      _this.timeAxisW = enode['timeX'] - snode['timeX'] + enode['timeW']\r\n      if(ew==undefined){\r\n        _this.timeAxisW = width - snode['timeX']\r\n      }\r\n    },\r\n    graphGTransformX(val) {\r\n      const _this = this;\r\n      let groups = _this.groupsSvg;\r\n      _this.graphGMoveX = _this.graphGTransformX;\r\n      let graphGTransformX = _this.graphGTransformX;\r\n      let graphGTransformY = _this.graphGTransformY;\r\n      let graphGTransformK = _this.graphGTransformK;\r\n      groups.attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n    }\r\n  },\r\n  methods: {\r\n    editToolClk() {\r\n      const _this = this;\r\n      if (_this.curToolState == 'edit') _this.curToolState = 'unEdit';\r\n      else if (_this.curToolState != 'edit') _this.curToolState = 'edit';\r\n      this.$emit(\"toolState\", this.curToolState);\r\n    },\r\n    updataRel(){\r\n      const _this = this;\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let showJageData = _this.showEntityList;\r\n      let showRel = _this.showEntityRelIdList;\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n        let sorceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        let idN = \"basicRel\" + sorceId + \"_\" + targetId;\r\n        console.log(sorceId,showRel,showRel.includes(sorceId))\r\n        if((showRel.includes(sorceId))||(showRel.includes(targetId))){\r\n          d3.select(`#${idN}`).attr('opacity',1).attr('stroke','darkslateblue')\r\n        }\r\n        else{\r\n          d3.select(`#${idN}`).attr('opacity',0)\r\n          \r\n        }\r\n      };\r\n    },\r\n    drawRelationshipLine(svg) {\r\n      const _this = this;\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let showJageData = _this.showEntityList;\r\n      let margin = _this.margin;\r\n      let height = svg.attr('height');\r\n      let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < basicRel.length; r++) {\r\n\r\n        let sorceId = basicRel[r][0];\r\n        let targetId = basicRel[r][1];\r\n        let idN = \"basicRel\" + sorceId + \"_\" + targetId;\r\n        let classN = \"basicRel source\" + sorceId + \" target\" + targetId;\r\n        let sorceNode = oData.find(function (d) { return d['id'] == sorceId });\r\n        let targetNode = oData.find(function (d) { return d['id'] == targetId });\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n          if (sorceNode['x'] > targetNode['x']) {\r\n            let tp = sorceNode;\r\n            sorceNode = targetNode;\r\n            targetNode = tp;\r\n          }\r\n          const path = d3.path();\r\n\r\n          let startX = sorceNode['x'];\r\n          let endX = targetNode['x'];\r\n          let midX = (startX + endX) / 2;\r\n          let flag = ((sorceNode['sonFlag']) || (targetNode['sonFlag']));\r\n          // if((targetNode['id'] == \"4\")||((sorceNode['id']==\"1\")&&(targetNode['id']==\"6\"))||((sorceNode['id']==\"2\")&&(targetNode['id']==\"7\"))||((sorceNode['id']==\"3\")&&(targetNode['id']==\"8\"))){\r\n          //   flag = true;\r\n          // }\r\n          if (targetNode['id'] == \"4\") {\r\n            flag = true;\r\n          }\r\n          // if(targetNode['id'] == \"30\"){\r\n          //   flag = true;\r\n          // }\r\n          let rsourceint = (sorceNode['sonFlag']) ? (20) : (2);\r\n          let rtargetint = (targetNode['sonFlag']) ? (20) : (2);\r\n          let startY = (flag) ? (sorceNode['y'] - sorceNode['r'] - rsourceint) : (sorceNode['y'] + sorceNode['r'] + rsourceint);\r\n          let endY = (flag) ? (targetNode['y'] - targetNode['r'] - rtargetint) : (targetNode['y'] + targetNode['r'] + rtargetint);\r\n\r\n          let cnx1 = startX - 50;\r\n          let cnx2 = endX + 50;\r\n          let midY = (startY + endY) / 2;\r\n          // if(((sorceNode['id']==\"1\")&&(targetNode['id']==\"6\"))||((sorceNode['id']==\"2\")&&(targetNode['id']==\"7\"))||((sorceNode['id']==\"3\")&&(targetNode['id']==\"8\"))){\r\n          //   midY-=140\r\n          // }\r\n          let h = (((endX - startX) / 5) > (parseInt(height) + 100)) ? (parseInt(height) + 100) : ((endX - startX) / 5);\r\n          let cny = (flag) ? (midY - h) : (midY + h);\r\n\r\n          let cny1 = cny;\r\n          let cny2 = cny;\r\n\r\n          if (((sorceNode['layout'] == 2) && (cny < 0)) || ((sorceNode['layout'] == 0) && (cny > 0))) {\r\n            cnx1 -= 250;\r\n            cny1 = cny * 1.3;\r\n          }\r\n          if (((targetNode['layout'] == 2) && (cny < 0)) || ((targetNode['layout'] == 0) && (cny > 0))) {\r\n            cnx2 += 250;\r\n            cny2 = cny * 1.3;\r\n          }\r\n          // let midP = [(startP[0]+endP[0])/2,(startP[1])>(endP[1])?(startP[1]-100):(endP[1]-100)];\r\n          path.moveTo(startX, startY);\r\n          path.bezierCurveTo(midX, cny, midX, cny, endX, endY);\r\n          _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"9,9\", idN, classN);\r\n        }\r\n\r\n      };\r\n      let similarityRel = relData['similarityRel'];\r\n      // let basicRel = relData['basicRel'];\r\n      for (let r = 0; r < similarityRel.length; r++) {\r\n\r\n        let sorceId = similarityRel[r][0];\r\n        let targetId = similarityRel[r][1];\r\n\r\n        let idN = \"similarityRel\" + sorceId + \"_\" + targetId;\r\n\r\n        let classN = \"similarityRel source\" + sorceId + \" target\" + targetId;\r\n        let sorceNode = oData.find(function (d) { return d['id'] == sorceId });\r\n        let targetNode = oData.find(function (d) { return d['id'] == targetId });\r\n        let sorceJage = showJageData.find(function (d) { return d['id'] == sorceId })['show'];\r\n        let targetJage = showJageData.find(function (d) { return d['id'] == targetId })['show'];\r\n        if (sorceJage && targetJage) {\r\n\r\n          if (sorceNode['x'] > targetNode['x']) {\r\n            let tp = sorceNode;\r\n            sorceNode = targetNode;\r\n            targetNode = tp;\r\n          }\r\n          const path = d3.path();\r\n\r\n          let startX = sorceNode['x'] + sorceNode['r'] / 2;\r\n          let endX = targetNode['x'] - targetNode['r'] / 2;\r\n          let midX = (startX + endX) / 2;\r\n          let flag = ((sorceNode['sonFlag']) || (targetNode['sonFlag']));\r\n          let rsourceint = (sorceNode['sonFlag']) ? (20) : (2);\r\n          let rtargetint = (targetNode['sonFlag']) ? (20) : (2);\r\n          let startY = (flag) ? (sorceNode['y'] - sorceNode['r'] - rsourceint) : (sorceNode['y'] + sorceNode['r'] + rsourceint);\r\n          let endY = (flag) ? (targetNode['y'] - targetNode['r'] - rtargetint) : (targetNode['y'] + targetNode['r'] + rtargetint);\r\n\r\n          let midY = (startY + endY) / 2;\r\n\r\n          // let h1Scale_linear = d3.scaleLinear([0, _this.width], [(sorceNode['y']>targetNode['y'])?(sorceNode['y']*2):(targetNode['y']*2),parseInt(height)])\r\n          let h = (((endX - startX) / 14) > (parseInt(height) - 10)) ? (parseInt(height) - 10) : ((endX - startX) / 14);\r\n          let hScale_linear = d3.scaleLinear([0, _this.width / 2], [0, h / 3 * 2])\r\n          let cny = (flag) ? (midY - hScale_linear(endX)) : (midY + hScale_linear(endX));\r\n          if (sorceNode['id'] == '7') { cny -= 20 }\r\n          if (cny < -150) {\r\n            startY = sorceNode['y'] + sorceNode['r'] + rsourceint\r\n            endY = targetNode['y'] + targetNode['r'] + rtargetint\r\n            cny = height - cny - 300;\r\n          }\r\n\r\n          path.moveTo(startX, startY);\r\n          path.lineTo(startX, cny);\r\n          path.lineTo(endX, cny);\r\n          path.lineTo(endX, endY);\r\n          _this.drawTimeLine(svg, path, \"rgb(200,200,200)\", 5, \"0\", idN, classN);\r\n        }\r\n\r\n\r\n      };\r\n      _this.updataRel()\r\n    },\r\n    drawMain(svg) {\r\n      let _this = this;\r\n      let data = _this.data;\r\n      let margin = _this.margin;\r\n\r\n      let width = _this.width - margin.left - margin.right;\r\n      let height = _this.height - margin.top - margin.bottom;\r\n\r\n      let graphGTransformX = _this.graphGTransformX;\r\n      let graphGTransformY = _this.graphGTransformY;\r\n      let graphGTransformK = _this.graphGTransformK;\r\n      let axisGroups = svg.append(\"g\").attr(\"id\", \"axisGroups\").attr(\"width\", width).attr(\"height\", height)\r\n      // .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      let groups = svg.append(\"g\").attr(\"id\", \"groups\").attr(\"width\", width).attr(\"height\", height)\r\n        .attr(\"transform\", \"translate(\" + graphGTransformX + ',' + graphGTransformY + \") scale(\" + graphGTransformK + \")\");\r\n      this.groupsSvg = groups;\r\n\r\n      let backG = groups.append(\"g\").attr(\"id\", \"backG\").attr(\"width\", width).attr(\"height\", height);\r\n      let arcG = groups.append(\"g\").attr(\"id\", \"arcG\").attr(\"width\", width).attr(\"height\", height);\r\n      let timeLineG = groups.append(\"g\").attr(\"id\", \"timeLineG\").attr(\"width\", width).attr(\"height\", height);\r\n      let circleG = groups.append(\"g\").attr(\"id\", \"circleG\").attr(\"width\", width).attr(\"height\", height);\r\n\r\n      _this.arcG = arcG;\r\n      let stepX = _this.stepX;\r\n      let stepY = _this.stepY;\r\n      let interval = _this.circleInterval;\r\n\r\n\r\n      let scalePre = _this.graphSvgScale;\r\n      let stx = 0;\r\n      let sty = 0;\r\n      let stk = 1;\r\n      var graphZoom = d3.zoom()\r\n        .scaleExtent([0, 10])\r\n        .on(\"start\", (e) => {\r\n          sty = e.transform.y;\r\n          stx = e.transform.x;\r\n          stk = e.transform.k;\r\n        })\r\n        .on('zoom', (e) => {\r\n          graphGTransformX = _this.graphGTransformX + e.transform.x - stx;\r\n          graphGTransformY = _this.graphGTransformY + e.transform.y - sty;\r\n          graphGTransformK = _this.graphGTransformK + e.transform.k - stk;\r\n          _this.graphGMoveX = graphGTransformX;\r\n\r\n          groups.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        })\r\n        .on('end', (e) => {\r\n          _this.graphGTransformX = graphGTransformX;\r\n          _this.graphGTransformY = graphGTransformY;\r\n          _this.graphGTransformK = graphGTransformK;\r\n          groups.attr('transform', 'translate(' + (graphGTransformX) + ',' + (graphGTransformY) + ') scale(' + (graphGTransformK) + ')')\r\n        });\r\n\r\n\r\n      svg.call(graphZoom)\r\n      // .call(graphZoom.transform, d3.zoomIdentity.scale(1))\r\n      const path = d3.path()\r\n      path.moveTo(margin.left, margin.top)\r\n      let x = margin.left;\r\n      let prex = margin.left;\r\n      let prey = margin.top;\r\n      let prer = 0;\r\n      let preSonLen = 0;\r\n      let layoutShow = _this.layoutShow;\r\n      let sumTotalDuration = 0;\r\n      let rootIndex = -1;\r\n      for (let i = 0; i < data.length; i++) {\r\n        let lay = parseInt(data[i]['layout']);\r\n\r\n        let colors = _this.mcolor;\r\n        let colorsD = _this.mDarkcolor;\r\n        let entityLocationData = tools.deepClone(data[i]);\r\n        if (lay == 0) {\r\n          rootIndex++;\r\n        }\r\n        entityLocationData['rootIndex'] = rootIndex;\r\n        entityLocationData['color'] = colors[rootIndex % colors.length];\r\n        entityLocationData['colorD'] = colorsD[rootIndex % colorsD.length];\r\n        let timeList = data[i]['time'];\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        sumTotalDuration += duration;\r\n        let showEntity = _this.showEntityList.find(function (d) { return d['id'] == data[i]['id'] });\r\n        if ((showEntity['show'] == true)) {\r\n          let y = margin.top + lay * stepY\r\n          let relevanceValue = data[i]['attribute']['relevance'];\r\n          let totalDurationValue = data[i]['totalDuration'];\r\n          let rScale = _this.totalDurationScale_linear;\r\n\r\n\r\n          let r = rScale(totalDurationValue);\r\n          let stepL = r + stepX / 2 + interval / 10;\r\n          let controlP1x = prex + interval / 1;\r\n          let controlP2x = x - interval / 1;\r\n          let curLinex = x - r - interval;\r\n\r\n          let relData = _this.relData;\r\n          let oData = _this.drawEntityLocation;\r\n          let basicRel = relData['basicRel'];\r\n          let daId = data[(i)]['id'];\r\n          let jg=0;\r\n          for (let re = 0; re < basicRel.length; re++) {\r\n\r\n            let sorceId = basicRel[re][0];\r\n            let targetId = basicRel[re][1];\r\n            let cNode = '';\r\n            if ((sorceId == daId)||(targetId == daId)) {\r\n              jg=1;\r\n            }\r\n          };\r\n          let sonFlag = 1;\r\n          if (((i > 0) && (preSonLen == 0)) && (data[(i)]['son'].length == 0)) {\r\n            sonFlag = 0;\r\n            stepL = r + stepX / 1.2 + interval / 10;\r\n            x += stepL;\r\n            controlP1x = prex + interval / 1;\r\n            controlP2x = x - r - interval / 2 - interval / 1;\r\n            curLinex = r + interval / 10;\r\n          }\r\n          else if (((i > 0) && (preSonLen != 0)) && (data[(i)]['son'].length == 0)) {\r\n            sonFlag = 0;\r\n            stepL = r + stepX + interval + 30;\r\n            x += stepL;\r\n            controlP1x = prex + interval / 1;\r\n            controlP2x = x - r - interval / 1 - interval / 1;\r\n            curLinex = r + interval / 10;\r\n          }\r\n          else {\r\n            stepL = r + stepX + interval + 10;\r\n            x += stepL;\r\n            controlP1x = prex + interval / 1;\r\n            controlP2x = x - r - interval - interval / 1;\r\n            curLinex = r + interval;\r\n          }\r\n          \r\n          if((jg==1)&&(data[i]['type']==0)){\r\n            curLinex+=r*1.5\r\n          }\r\n          _this.drawEntity(circleG, x, y, r, data[i])\r\n          path.bezierCurveTo(controlP1x, prey, controlP2x, y, x - curLinex, y)\r\n          // path.lineTo(controlP1x, prey)\r\n          // path.lineTo(controlP2x, y)\r\n          // path.lineTo(x - curLinex, y)\r\n          path.moveTo(x + curLinex, y);\r\n          prex = x + curLinex;\r\n          prey = y;\r\n          prer = r;\r\n          preSonLen = data[(i)]['son'].length;\r\n          entityLocationData['x'] = x;\r\n          entityLocationData['y'] = y;\r\n          entityLocationData['r'] = r;\r\n        }\r\n        else {\r\n          entityLocationData['x'] = prex;\r\n          entityLocationData['y'] = prey;\r\n          entityLocationData['r'] = prer;\r\n        }\r\n        entityLocationData['sonFlag'] = (entityLocationData['son'].length > 0) ? (1) : (0);\r\n        // entityLocationData['showRel'] = false;\r\n        _this.drawEntityLocation.push(entityLocationData);\r\n      }\r\n      let entityLocationData = _this.drawEntityLocation;\r\n      let colors = _this.mcolor;\r\n      let colorIndex = 0;\r\n      let colorrootIndex = 0;\r\n\r\n      _this.sumTotalDuration = sumTotalDuration;\r\n      for (let i = 0; i < entityLocationData.length; i++) {\r\n        let x = entityLocationData[i]['x'];\r\n        let y = entityLocationData[i]['y'];\r\n        let r = entityLocationData[i]['r'];\r\n        if(entityLocationData[i]['type']==0){\r\n        _this.drawEntityTimeAxis(circleG, entityLocationData[i]);}\r\n        if ((entityLocationData[i]['layout'] == '0' && (entityLocationData[i]['name'] != 'Test'))) {\r\n          colorIndex = colorrootIndex;\r\n          colorrootIndex++;\r\n\r\n        }\r\n        if ((entityLocationData[i]['son'].length != 0) && (_this.showEntityList.find(function (d) { return d['id'] == entityLocationData[i]['son'][0] })['show'])) {\r\n          let maxxs = entityLocationData[i]['x'] - entityLocationData[i]['r'] - 40;\r\n          let maxys = entityLocationData[i]['y'] - entityLocationData[i]['r'] - 40;\r\n          let minxs = tools.deepClone(maxxs);\r\n          let minys = tools.deepClone(maxys);\r\n          let rectPoints = [[maxxs, maxys]];\r\n          let sons = tools.deepClone(data[i]['son']);\r\n          while ((sons.length > 0)) {\r\n            let s = sons[0];\r\n            sons.splice(0, 1);\r\n            let curson = entityLocationData.find(function (d) { return d['id'] == s; });\r\n            let curgson = curson['son'];\r\n            let curx = curson['x'] + curson['r'] * 2;\r\n            let cury = curson['y'] + curson['r'] * 2;\r\n            if (curx > maxxs) { maxxs = curx; }\r\n            // if(curson['y']<maxys)maxys = curson['y'];\r\n            if (cury < minys) minys = cury;\r\n            if (cury > maxys) maxys = cury;\r\n            for (let gs = 0; gs < curgson.length; gs++) {\r\n              sons.push(curgson[gs]);\r\n            }\r\n          }\r\n          rectPoints = [[minxs, minys], [minxs, maxys], [maxxs, maxys], [maxxs, minys]];\r\n          // _this.drawpolygon(backG, colors[colorIndex], rectPoints, \"rgb(255,255,255)\",0.3);\r\n          _this.drawRect(backG, minxs, minys, Math.abs(maxxs - minxs), Math.abs(maxys - minys), 20, 20, colors[colorIndex], 0.1, \"white\", `backRect${i}`)\r\n\r\n          colorIndex++;\r\n          colorIndex %= colors.length\r\n        }\r\n        // entityLocationData[i]['color'] = colors[colorIndex - 1];\r\n        // if ((entityLocationData[i]['layout'] == '0') && ((entityLocationData[i]['name'] == 'Test') || (entityLocationData[i]['name'] == 'Example'))) {\r\n        //   entityLocationData[i]['color'] = colors[colorIndex]\r\n        // }\r\n      }\r\n      _this.drawTimeLine(timeLineG, path, \"rgb(200,200,200)\", 5, '0', 'timeLine ', 'timeLine ');\r\n      _this.drawRelationshipLine(timeLineG);\r\n      _this.drawTimeAxis(_this.TimeAxisSvg);\r\n      _this.drawTypeRiver(_this.TimeAxisSvg);\r\n      _this.updataTimeAxisDur(_this.TimeAxisSvg, _this.timeAxisX, _this.timeAxisW);\r\n    },\r\n    updataTimeAxisDur(svg, x, width) {\r\n      const _this = this;\r\n      let margin = _this.margin;\r\n      let totalWidth = _this.width - margin.left - margin.right;\r\n      let y = 0;\r\n      let h = 160;\r\n      _this.drawRect(svg, 0, y, x, h, 3, 3, 'white', 0.3, '', \"timeAxisRect1\")\r\n      let curRect = _this.drawRect(svg, x, y-0, width, h-5, 3, 3, 'rgba(0,0,0,0)', 1, 'rgb(145, 180, 189)', 'winRect',2);\r\n      // --------------------------------------\r\n      // curRect.on('mousemove', function (e) {\r\n      //   d3.select(this).attr(\"cursor\", 'pointer');\r\n      //   if (_this.timeAxisDropFlag == 1) {\r\n      //     let mx = e.clientX - _this.timeAxisDownX;\r\n      //     _this.timeAxisX = e.layerX - 450 - _this.timeAxisW / 2;\r\n      //   }\r\n      // })\r\n      // curRect.on('mousedown', function (e) {\r\n      //   _this.timeAxisDownX = e.clientX;\r\n      //   _this.timeAxisDropFlag = 1;\r\n      // })\r\n      // curRect.on('mouseup', function (e) {\r\n      //   _this.timeAxisDownX = e.clientX;\r\n      //   _this.timeAxisDropFlag = 0;\r\n      // })\r\n      // ----------------------------------------\r\n\r\n      _this.drawRect(svg, x + width, y, totalWidth - width, h, 3, 3, 'white', 0.3, '', \"timeAxisRect2\")\r\n    },\r\n    drawTypeRiver(svg) {\r\n      const _this = this;\r\n      let oriData = _this.data;\r\n      let resData = [];\r\n      let triLi = [];\r\n      let exeLi = [];\r\n      var defs = svg.append(\"defs\");\r\n\r\n      var filter = defs\r\n        .append(\"filter\")\r\n        .attr(\"id\", \"coolShadow\")\r\n        .attr(\"x\", \"-100%\")\r\n        .attr(\"y\", \"-100%\") //\r\n        .attr(\"width\", \"300%\")\r\n        .attr(\"height\", \"300%\"); //\r\n\r\n      filter\r\n        .append(\"feMorphology\")\r\n        .attr(\"in\", \"SourceGraphic\")\r\n        .attr(\"result\", \"upperLayer\")\r\n        .attr(\"operator\", \"dilate\")\r\n        .attr(\"radius\", \"0.2 0.2\");\r\n\r\n      filter\r\n        .append(\"feMorphology\")\r\n        .attr(\"in\", \"SourceAlpha\")\r\n        .attr(\"result\", \"enlargedAlpha\")\r\n        .attr(\"operator\", \"dilate\")\r\n        .attr(\"radius\", \"0.2 0.2\");\r\n\r\n      filter\r\n        .append(\"feGaussianBlur\")\r\n        .attr(\"in\", \"enlargedAlpha\")\r\n        .attr(\"result\", \"bluredAlpha\")\r\n        .attr(\"stdDeviation\", \"3\");\r\n\r\n      filter\r\n        .append(\"feOffset\")\r\n        .attr(\"in\", \"bluredAlpha\")\r\n        .attr(\"result\", \"lowerLayer\")\r\n        .attr(\"dy\", \"1\"); //\r\n\r\n      var feMerge = filter.append(\"feMerge\");\r\n      feMerge.append(\"feMergeNode\").attr(\"in\", \"lowerLayer\");\r\n      feMerge.append(\"feMergeNode\").attr(\"in\", \"upperLayer\");\r\n      for (let i = 0; i < oriData.length; i++) {\r\n        let curEnt = oriData[i];\r\n        let tp = {}\r\n        tp['od'] = i;\r\n        if ((curEnt['type'] == \"1\")) {\r\n          triLi.push(tp);\r\n        }\r\n        if (curEnt['type'] == \"2\") {\r\n          exeLi.push(tp);\r\n        }\r\n        let typeData = curEnt[\"attribute\"][\"expressions\"];\r\n        let totalDur = 0;\r\n\r\n        for (let t in typeData) {\r\n          // let color = typeColor[i];\r\n          let typeDurition = typeData[t];\r\n          let totalTypeSeconds = 0;\r\n          for (let d in typeDurition) {\r\n            totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n          }\r\n          totalDur += totalTypeSeconds;\r\n          tp[t] = totalTypeSeconds;\r\n        }\r\n        for (let t in tp) {\r\n          if (t != 'od') {\r\n            tp[t] /= totalDur;\r\n            if (totalDur == 0) {\r\n              tp[t] = 0;\r\n            }\r\n          }\r\n        }\r\n        resData.push(tp)\r\n      }\r\n\r\n      let data = resData;\r\n      console.log(data)\r\n      var stack = d3.stack()\r\n        .keys(['1', '2', '3'])\r\n        .order(d3.stackOrderInsideOut)\r\n        .offset(d3.stackOffsetWiggle);\r\n\r\n      let yRangeWidth = 80;\r\n      let xStep = (svg.attr(\"width\")) / oriData.length;\r\n      let yScale = d3.scaleLinear().domain([-1, 1]).range([0, 80]);\r\n      var area = d3.area()\r\n        .curve(d3.curveBasis)\r\n        .x(function (d) {\r\n          return d.data.od * xStep +15;\r\n        })\r\n        .y0(function (d) {\r\n          return 120+yRangeWidth - yScale(d[0]);\r\n        })\r\n        .y1(function (d) {\r\n          return yRangeWidth - yScale(d[1]);\r\n        });\r\n      console.log(data)\r\n      let stackData = stack(data)\r\n      console.log(data, stackData)\r\n      let lenThreshold = 0.4;\r\n      let iconLi = {}\r\n      for (let s in stackData) {\r\n        iconLi[s] = []\r\n        for (let i in stackData[s]) {\r\n          let lenArea = stackData[s][i]\r\n          if ((lenArea[1] - lenArea[0]) > 0.4) {\r\n            iconLi[s].push([i, lenArea]);\r\n          }\r\n          for (let li in iconLi[s]) {\r\n            if (i < (iconLi[s][li][0] + 2)) {\r\n              let selectArea = iconLi[s][li][1]\r\n              if (((selectArea[1] - lenArea[1]) - (selectArea[0] - lenArea[0])) < 0.2) {\r\n                iconLi[s].splice(s, 1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // let areaG = svg.append(\"g\")\r\n      let typeColor = {\r\n        \"1\": \"#ff9c9c\",\r\n        \"2\": \"#f4f4d0\",\r\n        \"3\": \"#6f8be0\",\r\n      };\r\n      let colorLi = _this.mcolor;\r\n      svg.selectAll(\"path\")\r\n        .data(stackData)\r\n        .join(\"path\")\r\n        .attr(\"id\",function(d){return d.key})\r\n        .attr(\"class\",\"river\")\r\n        .attr(\"d\", function (d) {\r\n          return area(d)\r\n        })\r\n        .attr(\"fill\", function (d, i) {\r\n          return typeColor[d.key]\r\n        })\r\n        .on(\"mouseover\",function(d){\r\n          d3.selectAll(\".river\").style(\"filter\", \"url()\")\r\n          d3.select(this).style(\"filter\", \"url(#coolShadow)\")\r\n        })\r\n\r\n      for (let t in triLi) {\r\n        let area = tools.calcTriangle((triLi[t]['od']) * xStep, -30, 14);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n        _this.drawTxt(svg, (triLi[t]['od']) * xStep, -23, \"T\", \"white\", 0, \"middle\", 18)\r\n      }\r\n      for (let t in exeLi) {\r\n        let area = tools.calcTriangle((exeLi[t]['od']) * xStep, -30, 14);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n        _this.drawTxt(svg, (exeLi[t]['od']) * xStep, -23, \"E\", \"white\", 0, \"middle\", 18)\r\n      }\r\n    },\r\n    drawTimeAxis(svg) {\r\n      const _this = this;\r\n      let sumTotalDuration = _this.sumTotalDuration;\r\n      let data = _this.drawEntityLocation;\r\n      let addData = tools.deepClone(_this.drawEntityLocation);\r\n      let margin = _this.margin;\r\n      let prex = margin.left;\r\n      let prey = margin.top / 2;\r\n      let width = svg.attr(\"width\")// _this.width - margin.left - margin.right;\r\n      let height = _this.height - margin.top - margin.bottom;\r\n      let widthScale = d3.scaleLinear([0, sumTotalDuration], [0, width]);\r\n      data.forEach((self, indx, arr) => {\r\n        let totalDurationValue = self['totalDuration'];\r\n        let timeList = self['time'];\r\n        let id = self['id']\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        // console.log(timeList,tools.time2seconds(timeList[0]))\r\n        let evWidth = widthScale(duration)-4;\r\n\r\n        let evTWidth = widthScale(totalDurationValue);\r\n        let lay = parseInt(self['layout']);\r\n        let evHight = 80 - 20 * lay;\r\n        let x = prex;\r\n        let y = prey + 20 * lay;\r\n        prex += evWidth+4;\r\n        let cr = 3;\r\n        // if(self['type']==0){\r\n        if(1){\r\n          if (lay == 0) {\r\n            _this.drawRect(svg, x-2, y - 20, evTWidth, 100, 6, 6, self['color'], 0.3, 'white', `timeAxisEntB_${indx}`,1.5, 'timeAxisEntB')\r\n          }\r\n          _this.drawRect(svg, x, y, evWidth, evHight, 3, 3, self['color'], 0.4, self['colorD'], `timeAxisEnt_${id}`,1.5, 'timeAxisEnt')\r\n        }\r\n        else{\r\n          if (lay == 0) {\r\n            _this.drawRect(svg, x-2, y - 20, evTWidth, 100, 6, 6, self['color'], 0.3, 'white', `timeAxisEntB_${id}`,1.5, 'timeAxisEnt')\r\n          }\r\n          let area = [[x+cr,y+evHight-cr],[x-cr+evWidth,y+evHight-cr],[x+evWidth/2,y]];\r\n          _this.drawTriangle(svg, self['color'], area, self['color'],1,cr*2);\r\n        }\r\n        addData[indx]['timeX'] = x;\r\n        addData[indx]['timeW'] = evWidth\r\n      })\r\n      _this.drawEntityLocation = addData;\r\n      console.log(11111111111111, width, sumTotalDuration, data, _this.drawEntityLocation)\r\n    },\r\n    drawTriangle(svg, color, points, stroke, opacity = 1,strokeW=15) {\r\n      svg.append(\"polygon\")\r\n        .attr(\"points\", points)\r\n        .attr(\"fill\", color)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", strokeW);\r\n    },\r\n    drawpolygon(svg, color, areas, stroke, opacity = 1) {\r\n      svg.append(\"polygon\")\r\n        .attr(\"points\", areas)\r\n        .attr(\"fill\", color)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", \"1.5px\");\r\n    },\r\n    drawEntityTimeAxis(svg, entData) {\r\n\r\n      const _this = this;\r\n      let x = entData['x'];\r\n      let r = entData['r'];\r\n      let y = entData['y'] + r / 2;\r\n      let daId = entData['id']\r\n      let entDataO = _this.drawEntityLocation;\r\n      let sumTotalDuration = _this.sumTotalDuration;\r\n      let widthScale = d3.scaleLinear([0, sumTotalDuration], [0, Math.PI]);\r\n      let timeStepR = 0;\r\n      let timeStartR = -Math.PI / 2;\r\n      let inter = 0;\r\n      let sons = tools.deepClone(entData['son']);\r\n      let relList = [];\r\n      let relRootList = [];\r\n      let psNum = 0.5;\r\n      if ((sons.length > 0)) {\r\n        inter = 16\r\n      }\r\n\r\n      let relData = _this.relData;\r\n      let oData = _this.drawEntityLocation;\r\n      let basicRel = relData['basicRel'];\r\n      for (let re = 0; re < basicRel.length; re++) {\r\n\r\n        let sorceId = basicRel[re][0];\r\n        let targetId = basicRel[re][1];\r\n        let cNode = '';\r\n        if (sorceId == daId) {\r\n          cNode = oData.find(function (d) { return d['id'] == targetId });\r\n          relList.push(targetId);\r\n          relRootList.push(cNode['rootIndex']);\r\n        }\r\n\r\n        if (targetId == daId) {\r\n          cNode = oData.find(function (d) { return d['id'] == sorceId });\r\n          relList.push(sorceId);\r\n          relRootList.push(cNode['rootIndex']);\r\n          console.log(sorceId, targetId, daId, cNode)\r\n        }\r\n      };\r\n      console.log(relList, relRootList)\r\n      // if(entData[]) \r\n      let wline = 0;\r\n      let sumTotalDurationF = 0;\r\n      entDataO.forEach((self, indx, arr) => {\r\n        let totalDurationValue = self['totalDuration'];\r\n        let timeList = self['time'];\r\n        let layout = self['layout'];\r\n        let rootIndex = self['rootIndex'];\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        timeStepR = widthScale(duration);\r\n        if (!relRootList.includes(rootIndex)) {\r\n          wline += timeStepR * psNum;\r\n          sumTotalDurationF += duration;\r\n        }\r\n      })\r\n      let widthScaleA = d3.scaleLinear([0, sumTotalDuration - sumTotalDurationF], [0, Math.PI - wline]);\r\n      // if(rootEntityList.length==0){\r\n      //   widthScaleA = widthScale\r\n      // }\r\n      // let wline = 0;\r\n      entDataO.forEach((self, indx, arr) => {\r\n        let totalDurationValue = self['totalDuration'];\r\n        let timeList = self['time'];\r\n        let layout = self['layout'];\r\n        let rootIndex = self['rootIndex'];\r\n        let cId = self['id'];\r\n        let duration = tools.time2seconds(timeList[1]) - tools.time2seconds(timeList[0]);\r\n        timeStepR = widthScale(duration);\r\n        if (!relRootList.includes(rootIndex)) {\r\n          if (relRootList.length != 0) {\r\n            timeStepR = psNum * widthScale(duration);\r\n          }\r\n        }\r\n        else {\r\n          timeStepR = widthScaleA(duration)\r\n        }\r\n        let endAnglet = timeStartR + timeStepR;\r\n        var dataset = { startAngle: timeStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n        timeStartR = endAnglet;\r\n        let color = 'blue';\r\n        let rh = r*0.7;\r\n        let h = rh;\r\n        let nh = 0;\r\n        if (relRootList.length != 0) {\r\n          h = rh*0.3 + rh*0.6 - 3 * layout;\r\n          nh = rh*0.3;\r\n        }\r\n        if (!relRootList.includes(self['rootIndex'])) {\r\n          h = rh*0.7;\r\n          nh = h*0 + h*0.6;\r\n        }\r\n        else{\r\n          dataset.startAngle+=0.003;\r\n          dataset.endAngle-=0.003; \r\n\r\n        }\r\n        var arcPath = d3.arc()\r\n          .innerRadius(r + inter + nh)\r\n          .outerRadius(r + inter + h);\r\n        var pathArc = arcPath(dataset);\r\n        console.log(self, relList, relList.includes(self['id']))\r\n        let arc;\r\n        if (relRootList.length != 0) {\r\n          if (relRootList.includes(self['rootIndex'])) {\r\n            if (relList.includes(parseInt(self['id']))) {\r\n             arc= _this.drawArc(svg, x, y - r / 2, pathArc, self['color'], self['color'], `timeAxisFor f${entData['id']} ${self['id']}`, '0', 0, 1);\r\n            }\r\n            else {\r\n              arc = _this.drawArc(svg, x, y - r / 2, pathArc, \"white\", self['color'], `timeAxisFor f${entData['id']} ${self['id']}`, '0', 0.0, 0.4);\r\n            }\r\n          }\r\n          else{\r\n             arc = _this.drawArc(svg, x, y - r / 2, pathArc, self['color'], self['color'], `timeAxisFor f${entData['id']} ${self['id']}`, '0', 0, 0.2);\r\n        \r\n          }\r\n         arc.on(\"mouseover\",function(d){\r\n            let classN = d3.select(this).attr(\"fill\",'red');\r\n            let tId = classN.split(\" \")[2];\r\n\r\n          })\r\n         }\r\n      })\r\n    },\r\n    drawEntity(svg, x, y, r, data) {\r\n      const _this = this;\r\n      let color_linear = _this.importanceColor_linear;\r\n      let compute_color = _this.importanceCompute_color;\r\n      let rScale = _this.relevanceScale_linear;\r\n      let oData = _this.data;\r\n      let importanceValue = data['attribute']['importance'];\r\n      let relevanceValue = data['attribute']['relevance'];\r\n      // let r = rScale(relevanceValue)\r\n      // { 'id': data[i]['id'], \"x\": x, \"r\": r, \"layout\": lay, \"y\": y, \"sonFlag\": sonFlag }\r\n\r\n\r\n      if (data['type'] == '1') {\r\n        let area = tools.calcTriangle(x, y, r);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n\r\n        _this.drawTxt(svg, x, y + 8, 20, [\"T\"], 'white', 28, \"T\")\r\n      }\r\n      else if (data['type'] == '2') {\r\n        let area = tools.calcTriangle(x, y, r);\r\n        _this.drawTriangle(svg, \"rgb(250, 199, 88)\", area, \"rgb(250, 199, 88)\");\r\n\r\n        _this.drawTxt(svg, x, y + 8, 20, [\"E\"], 'white', 28, \"E\")\r\n      }\r\n      else {\r\n\r\n        let cy = y;\r\n        let totalDuration = _this.totalDuration;\r\n        let timeLineScale_linear = d3.scaleLinear([0, totalDuration], [x - r * Math.sqrt(3) / 2, x + r * Math.sqrt(3) / 2])\r\n        let timeLineHighScale_linear = d3.scaleLinear([0, _this.maxTotalDuration - 50], [r / 2, r * (1 + Math.sqrt(3) / 3 * 2)])\r\n        let circleColor = compute_color(color_linear(importanceValue));\r\n        _this.drawCircle(svg, x, cy, r, circleColor, data, 1, \"entCircle\", \"entCircle_\" + data['id']);\r\n\r\n        r = r * Math.sqrt(3) / 2;\r\n        y += r / 2;\r\n        let path = d3.path();\r\n\r\n\r\n        path.moveTo(x - r, y);\r\n        let lineLi = [data];\r\n        let linePoint = [{ 'id': data['id'], 'time': data['time'], 'x': 0, 'y': 0 }];\r\n        let jgidL = [data['id']];\r\n        let similarityRelsli = [data[\"similarityRel\"]];\r\n        while (similarityRelsli.length > 0) {\r\n          let similarityRels = similarityRelsli[0];\r\n          similarityRelsli.splice(0, 1);\r\n          let jg = 0;\r\n          for (let srel in similarityRels) {\r\n            let cdata = oData.find(function (d) { return d['id'] == similarityRels[srel] });\r\n            if (jgidL.indexOf(cdata['id']) == -1) {\r\n              similarityRelsli.push(cdata[\"similarityRel\"])\r\n              jg = 1;\r\n              lineLi.push(cdata)\r\n              jgidL.push(cdata['id'])\r\n              linePoint.push({ 'id': cdata['id'], 'time': cdata['time'], 'x': 0, 'y': 0 })\r\n            }\r\n          }\r\n          // if(jg==0){\r\n          // break;\r\n          // }\r\n        }\r\n\r\n        const sortmt = (a, b) => {\r\n          return tools.time2seconds(a[0]) - tools.time2seconds(b[0]);\r\n        }\r\n        const sortlp = (a, b) => {\r\n          return tools.time2seconds(a['time'][0]) - tools.time2seconds(b['time'][0]);\r\n        }\r\n\r\n        lineLi = lineLi.sort(sortlp);\r\n        linePoint = linePoint.sort(sortlp);\r\n        let lineData = [[x - r * Math.sqrt(3) / 2 - 4, y]];\r\n        for (let t = 0; t < lineLi.length; t++) {\r\n          let startT = lineLi[t]['time'][0];\r\n          let duration = lineLi[t]['totalDuration']\r\n          // let endT = lineLi[t]['time'][1];\r\n          let startS = tools.time2seconds(startT);\r\n          let endS = startS + duration;\r\n          // let startx = timeLineScale_linear((startS - duration * 10));\r\n          // let endx = timeLineScale_linear((endS + duration * 10));\r\n          let limst = (x - r * Math.sqrt(3) / 2);\r\n          let limed = (x + r * Math.sqrt(3) / 2);\r\n          let startx = (limst < timeLineScale_linear((startS))) ? (timeLineScale_linear((startS))) : (limst);\r\n          let endx = (limed > timeLineScale_linear((endS))) ? (timeLineScale_linear((endS))) : (limed);\r\n          // let midx = timeLineScale_linear((endS + startS) / 2);\r\n          let midx = (startx + endx) / 2;\r\n          let ys = y;\r\n          let yz = y - timeLineHighScale_linear((duration));\r\n          linePoint[t]['x'] = midx;\r\n          linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n          // if (startx < (lineData[lineData.length - 1][0])) {\r\n          if (t > 0) {\r\n            lineData.splice(lineData.length - 1, 1);\r\n            midx += t * 5;\r\n            startx = midx - ((midx - (lineData[lineData.length - 1][0] + midx) / 2)) / 2;\r\n            endx += t * 5;\r\n            ys = y + (y - lineData[lineData.length - 1][1]) / 3\r\n          }\r\n          // }\r\n          lineData.push([startx, ys], [midx, yz], [endx, y])\r\n          // let startx = timeLineScale_linear((startS - duration * 10));\r\n          // let endx = timeLineScale_linear((endS + duration * 10));\r\n\r\n          // let startyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let startyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let endyf = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let endyf1 = y + timeLineHighScale_linear((duration)) / 8;\r\n          // let yz = y - timeLineHighScale_linear((duration));\r\n          // let midx = timeLineScale_linear((endS + startS) / 2);\r\n          // linePoint[t]['x'] = midx;\r\n          // linePoint[t]['y'] = y - timeLineHighScale_linear(duration) / 1.7;\r\n          // let y1 = y;\r\n          // if (startx < (lineData[lineData.length - 1][0])) {\r\n          //   if (t > 0) {\r\n          //     lineData.splice(lineData.length - 3, 3);\r\n          //     startx = (lineData[lineData.length - 1][0] + midx) / 2;\r\n          //     y1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n          //     startyf = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n          //     startyf1 = lineData[lineData.length - 1][1] + timeLineHighScale_linear((duration)) / 2;\r\n          //   }\r\n          // }\r\n          // let startx1 = startx + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // let endx1 = endx - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // let startx2 = startx1 + (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // let endx2 = endx1 - (timeLineScale_linear((startS + duration)) - timeLineScale_linear((startS)));\r\n          // if (endx > (r + x)) endx = r + x;\r\n          // if (startx1 < (lineData[lineData.length - 1][0])) startx1 = lineData[lineData.length - 1][0];\r\n          // if (endx1 > (r + x)) endx1 = r + x;\r\n          // if (startx2 < (lineData[lineData.length - 1][0])) startx2 = lineData[lineData.length - 1][0];\r\n          // if (endx2 > (r + x)) endx2 = r + x;\r\n          // lineData.push([startx, y1], [startx1, startyf1], [startx2, startyf], [midx, yz], [endx2, endyf], [endx1, endyf1], [endx, y])\r\n        }\r\n        lineData.push([x + r, y])\r\n        let curve_generator = d3.line()\r\n          .x((d) => d[0])\r\n          .y((d) => {\r\n            let h = Math.sqrt(Math.pow(r, 2) - Math.pow((d[0] - (x - r)), 2));\r\n            if ((y - d[1]) > (h + r * Math.sqrt(3) / 2))\r\n              return y - (h + r * Math.sqrt(3) / 2) + 2;\r\n            return d[1];\r\n          })\r\n          .curve(d3.curveBundle)\r\n        // .curve(d3.curveCatmullRom  )\r\n        // .curve(d3.curveBasis)\r\n        _this.drawTimeLine(svg, curve_generator(lineData), \"white\", 2, '0', 'sonLine ', 'sonLine ');\r\n\r\n\r\n        for (let p = 0; p < linePoint.length; p++) {\r\n          _this.drawCircle(svg, linePoint[p]['x'], linePoint[p]['y'], 5, \"red\", linePoint[p], 0, \"linePoint\", \"linePoint_\" + linePoint[p]['id']);\r\n        }\r\n\r\n        // \"1\": \"rgb(145, 204, 117)\",\r\n        //   \"2\": \"rgb(84, 112, 198)\",\r\n        //   \"3\": \"rgb(238, 102, 102)\",\r\n        let typeColor = {\r\n          \"1\": \"#ff9c9c\",\r\n          \"2\": \"#f4f4d0\",\r\n          \"3\": \"#6f8be0\",\r\n        };\r\n        let duration = tools.time2seconds(data['time'][0]) - tools.time2seconds(data['time'][1]);\r\n        let typeData = data['attribute']['expressions'];\r\n        let sonList = data['son'];\r\n        let sons = [sonList];\r\n        while (sons.length > 0) {\r\n          let curSonList = sons[0];\r\n          sons.splice(0, 1);\r\n          if (curSonList.length > 0) {\r\n            for (let s in curSonList) {\r\n              let sonData = oData.find(function (d) { return d['id'] == curSonList[s] });\r\n              let sonTypeData = sonData['attribute']['expressions'];\r\n\r\n              for (let t in sonTypeData) {\r\n                let typeDurition = sonTypeData[t];\r\n                for (let d in typeDurition) {\r\n                  typeData[t].push(typeDurition[d])\r\n                }\r\n              }\r\n              sons.push(sonData['son']);\r\n            }\r\n          }\r\n        }\r\n        var typeStartR = 0//Math.PI/4;\r\n\r\n        var typeStepR = Math.PI / 1;\r\n\r\n        if (sonList.length > 0) {\r\n          let typeTotalDur = 0;\r\n          for (let t in typeData) {\r\n            let typeDurition = typeData[t];\r\n            for (let d in typeDurition) {\r\n              typeTotalDur += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n          }\r\n          let typeArcScale_linear = d3.scaleLinear([0, typeTotalDur], [0, Math.PI * 2]);\r\n          for (let i in typeData) {\r\n            let color = typeColor[i];\r\n            let typeDurition = typeData[i];\r\n            let totalTypeSeconds = 0;\r\n            for (let d in typeDurition) {\r\n              totalTypeSeconds += (tools.time2seconds(typeDurition[d][1]) - tools.time2seconds(typeDurition[d][0]))\r\n            }\r\n            if (totalTypeSeconds > 0) {\r\n              let typeStepR = typeArcScale_linear(totalTypeSeconds)//Math.PI/2;\r\n\r\n              let endAnglet = typeStartR + 1 * typeStepR\r\n              var dataset = { startAngle: typeStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n              typeStartR = endAnglet;\r\n              var arcPath = d3.arc()\r\n                .innerRadius(r + 10)\r\n                .outerRadius(r + 25);\r\n              var pathArc = arcPath(dataset);\r\n              _this.drawArc(svg, x, y - r / 2, pathArc, color, color, 'type f' + data['id'] + \" t\" + i);\r\n            }\r\n          }\r\n          let sonTotal = 0;\r\n          let sonNum = 0\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n            sonTotal += sonDur;\r\n            sonNum += 1;\r\n          }\r\n          let skipArc = Math.PI / (sonNum + 2);\r\n          let timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI - skipArc * (sonNum - 1)]);\r\n          let timeSonHeighLinear = d3.scaleLinear([0, sonTotal], [40, 40]);\r\n\r\n          let timeSonColor_linear = d3.scaleLinear().domain([0, sonTotal]).range([0, 1]);\r\n          let timeSonCompute_color = d3.interpolate(\"white\", circleColor);\r\n          var sonStartR = Math.PI / 2;\r\n\r\n          let relList = [];\r\n          let relRootList = [];\r\n          let psNum = 0.1;\r\n          let daId = data['id']\r\n          let relData = _this.relData;\r\n          let odData = _this.data;\r\n          let basicRel = relData['basicRel'];\r\n          for (let re = 0; re < basicRel.length; re++) {\r\n\r\n            let sorceId = basicRel[re][0];\r\n            let targetId = basicRel[re][1];\r\n            let cNode = '';\r\n            if (sorceId == daId) {\r\n              cNode = odData.find(function (d) { return parseInt(d['id']) == parseInt(targetId) });\r\n              relList.push(targetId);\r\n            }\r\n\r\n            if (targetId == daId) {\r\n              cNode = odData.find(function (d) { return parseInt(d['id']) == parseInt(sorceId) });\r\n              relList.push(sorceId);\r\n            }\r\n          };\r\n          if (relList.length == 0) {\r\n            sonStartR = 0;\r\n            timeSonLinear = d3.scaleLinear([0, sonTotal], [0, Math.PI * 2 - skipArc * (sonNum)]);\r\n          }\r\n\r\n          for (let s in sonList) {\r\n            let sonData = oData.find(function (d) { return d['id'] == sonList[s] });\r\n            let sonDur = sonData['totalDuration'];\r\n\r\n            let sonStepR = timeSonLinear(sonDur)//Math.PI/2;\r\n\r\n            let endAnglet = sonStartR + sonStepR;\r\n            var dataset = { startAngle: sonStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n            sonStartR = endAnglet;\r\n            let color = 'blue';\r\n            var arcPath = d3.arc()\r\n              .innerRadius(r + 28)\r\n              .outerRadius(r + timeSonHeighLinear(sonDur));\r\n            var arcMidPath = d3.arc()\r\n              .innerRadius(0)\r\n              .outerRadius(r + 32);\r\n            var pathArc = arcPath(dataset);\r\n\r\n            endAnglet = sonStartR + skipArc;\r\n            var midDataset = { startAngle: sonStartR, endAngle: endAnglet }; //创建一个弧生成器\r\n\r\n            let jiantouPath = d3.path();\r\n            jiantouPath.arc(x, y - r / 2, r + 32, sonStartR - Math.PI / 2, endAnglet - Math.PI / 2);\r\n\r\n            sonStartR += skipArc;\r\n            var pathMidArc = arcMidPath(midDataset);\r\n            let timeSonColor = compute_color(color_linear(sonData['attribute']['importance']));\r\n            _this.drawArc(svg, x, y - r / 2, pathArc, timeSonColor, timeSonColor, 'son f' + data['id'] + \" s\" + sonList[s], '0');\r\n            if (s != sonList.length - 1) {\r\n\r\n              // console.log\r\n              _this.drawTimeLine(_this.arcG, jiantouPath, \"rgb(200,200,200)\", 3, '9,5', 'midArc ', 'midArc ');\r\n              // _this.drawTimeLine(_this.arcG, path, \"white\", 2,'0', 'sonLine ', 'sonLine ');\r\n              // _this.drawArc(_this.arcG, x, y - r / 2, pathMidArc, \"rgb(200,200,200)\", \"white\", 'son f' + data['id'], \"9,5\", 3);\r\n            }\r\n          }\r\n\r\n        };\r\n      }\r\n      let txts = data['name'].split(\" \")\r\n      let tx = x - r - 30;\r\n      let ty = y + r + 60;\r\n      let tw = r * 2;\r\n      tx = x;\r\n      if (data['son'].length == 0) {\r\n        tx = x//-r-10;\r\n        ty = y + r * 2;\r\n      }\r\n      if (data['id'] == \"3\") {\r\n        tx = x - 10;\r\n        ty = y + r * 2;\r\n      }\r\n      if (data['id'] == \"4\") {\r\n        tx = x + 10;\r\n        ty = y + r * 2;\r\n      }\r\n      // if(data['type']=='1'){\r\n      //   tx = x-r/2;\r\n      //   ty = y+r*2;\r\n      // }\r\n\r\n      _this.drawTxt(svg, tx, ty, tw, txts, \"grey\", 16, `text_${data['id']}`);\r\n    },\r\n    drawArc(svg, x, y, arcPath, stroke, fill, className, stroke_dasharray = \"0\", width = 3, opacity = 1) {\r\n      let arc = svg.append(\"path\")\r\n        .attr(\"d\", arcPath)\r\n        .attr(\"class\", className)\r\n        .attr(\"transform\", \"translate(\" + x + \",\" + y + \")\")\r\n        .attr(\"stroke\", stroke)\r\n        .attr('stroke-width', width)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr(\"stroke-linejoin\", \"round\")\r\n        .attr(\"fill\", fill)\r\n        .attr(\"opacity\", opacity);\r\n        return arc;\r\n    },\r\n    drawCircle(svg, x, y, r, fill, data, opacity, className, idName) {\r\n      const _this = this;\r\n      const oData = _this.data\r\n      svg.append(\"circle\")\r\n        .attr(\"id\", idName)\r\n        .attr(\"class\", className)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"cx\", x)\r\n        .attr(\"cy\", y)\r\n        .attr(\"r\", r)\r\n        .attr(\"fill\", fill)\r\n        .on(\"mouseover\", function (d) {\r\n          d3.select(this).attr(\"r\", r * 1.1)\r\n          let classN = d3.select(this).attr(\"class\");\r\n          let idN = d3.select(this).attr(\"id\").split(\"_\")[1]\r\n          let showRel = _this.showEntityRelIdList\r\n          if(!showRel.includes(parseInt(idN))){ \r\n            showRel.push(parseInt(idN))\r\n            _this.showEntityRelIdOverState = 0;\r\n          }\r\n          else{\r\n            _this.showEntityRelIdOverState = 1;\r\n          }\r\n          _this.showEntityRelIdList = showRel;\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 1).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1.1)\"\r\n              })\r\n\r\n            d3.selectAll(\".basicRel\")\r\n              .attr(\"class\", function (d) {\r\n                let classN = d3.select(this).attr(\"class\");\r\n                let classNList = classN.split(\" \");\r\n                let jg = 0;\r\n                for (let i = 0; i < classNList.length - 1; i++) {\r\n                  if ('source' + data['id'] == classNList[i]) { jg = 1; }\r\n                  if ('target' + data['id'] == classNList[i]) { jg = 1; }\r\n                }\r\n                if (jg == 1) {\r\n                  classN += \" activeS\";\r\n                }\r\n                return classN;\r\n              })\r\n          }\r\n        })\r\n        .on(\"mouseleave\", function (d) {\r\n          d3.select(this).attr(\"r\", r)\r\n          let classN = d3.select(this).attr(\"class\");\r\n          \r\n          let idN = d3.select(this).attr(\"id\").split(\"_\")[1]\r\n          let showRel = _this.showEntityRelIdList\r\n          if(_this.showEntityRelIdOverState == 1){ \r\n            showRel.push(parseInt(idN))\r\n          }\r\n          else{\r\n            showRel.splice(showRel.indexOf(parseInt(idN)),1)\r\n          }\r\n          _this.showEntityRelIdList = showRel;\r\n\r\n          if (classN == 'linePoint') {\r\n            d3.select(this).attr(\"opacity\", 0).attr(\"r\", 5)\r\n          }\r\n          else {\r\n            d3.selectAll(\".f\" + data['id'])\r\n              .attr(\"transform\", function (d) {\r\n                let transformd = d3.select(this).attr(\"transform\")\r\n                return transformd.split(\" \")[0] + \" scale(1)\"\r\n              })\r\n            d3.select(\"#graphPanel\").selectAll(\"path\")\r\n              .attr(\"class\", function (d) {\r\n                let thisSelect = d3.select(this)\r\n                let classN = thisSelect.attr(\"class\");\r\n                let classNList = classN.split(\" \")\r\n                if (classNList[classNList.length - 1] == \"activeS\") {\r\n                  classN = \"\";\r\n                  for (let i = 0; i < classNList.length - 1; i++) {\r\n                    classN += \" \" + classNList[i];\r\n                  }\r\n                }\r\n                return classN\r\n              })\r\n          }\r\n        })\r\n        .on(\"click\", function (d) {\r\n\r\n          let idN = d3.select(this).attr(\"id\").split(\"_\")[1]\r\n          let showRel = _this.showEntityRelIdList;\r\n          //  - _this.showEntityRelIdOverState;\r\n          if(!showRel.includes(parseInt(idN))){ \r\n            showRel = [(parseInt(idN))]\r\n            _this.showEntityRelIdOverState = 1;\r\n          }\r\n          else if(showRel.includes(parseInt(idN))){ \r\n            // showRel.filter(item=>{return item==parseInt(idN)})\r\n            _this.showEntityRelIdOverState = 0;\r\n            showRel.splice(showRel.indexOf(parseInt(idN)),1)\r\n          }\r\n          _this.showEntityRelIdList = showRel;\r\n\r\n          d3.select(this).attr(\"r\", r);\r\n          d3.selectAll(\".f\" + data['id'])\r\n            .attr(\"transform\", function (d) {\r\n              let transformd = d3.select(this).attr(\"transform\")\r\n              return transformd.split(\" \")[0] + \" scale(1)\"\r\n            })\r\n          let thisId = this.id.split(\"_\")[1];\r\n          _this.curEntId = thisId;\r\n          let thisData = oData.find(function (a) { return a['id'] == thisId })\r\n          let thisTime = thisData['time'];\r\n          _this.click_Ent(thisTime);\r\n          // console.log(thisTime,thisId,thisData)\r\n        })\r\n        .on(\"contextmenu\", function (d, i) {\r\n          d.preventDefault();\r\n\r\n          let thisId = this.id.split(\"_\")[1];\r\n          let thisShowEntityData = _this.showEntityList.find(function (d) { return d['id'] == thisId });\r\n          let thisSons = thisShowEntityData['son'];\r\n          if (thisSons.length != 0) {\r\n            let sons = tools.deepClone(thisSons);\r\n            let showJage = false;\r\n            let i = 0\r\n            while ((sons.length > 0)) {\r\n              let s = sons[0];\r\n              sons.splice(0, 1);\r\n              let curson = _this.showEntityList.find(function (d) { return d['id'] == s + '' })\r\n              if (i == 0) {\r\n                i++;\r\n                showJage = !curson['show']\r\n              }\r\n              // ['show'] = !_this.showEntityList.find(function (d) { return d['id'] == thisSons[s] })['show']\r\n              curson['show'] = showJage;\r\n              let curgson = curson['son'];\r\n              if (!showJage) {\r\n                for (let gs = 0; gs < curgson.length; gs++) {\r\n                  sons.push(curgson[gs]);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          _this.updataGraph()\r\n        });\r\n      // .on(\"\")\r\n    },\r\n    drawRect(svg, x, y, w, h, rx, ry, fill, opacity, stroke, id = 'rect',strokeW = 1.5,classN = 'rect') {\r\n      d3.select(`#${id}`).remove()\r\n      let rect = svg.append(\"rect\")\r\n        .attr(\"id\", id)\r\n        .attr(\"class\",classN)\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y)\r\n        .attr(\"rx\", rx)\r\n        .attr(\"ry\", ry)\r\n        .attr(\"height\", h)\r\n        .attr(\"width\", w) //刚才设置的块的宽度\r\n        .attr(\"fill\", fill)\r\n        .attr(\"opacity\", opacity)\r\n        .attr(\"stroke\", stroke)\r\n        .attr(\"stroke-width\", `${strokeW}px`);\r\n      return rect;\r\n    },\r\n    drawTxt(svg, x, y, width, txts, fill, fontsize = 12, idN) {\r\n      let tx = x;\r\n      let ty = y;\r\n      let preWidth = 0;\r\n      let preIdN = 0;\r\n      let pretext = ''\r\n      for (let t = 0; t < txts.length; t++) {\r\n        pretext += \" \" + txts[t];\r\n        let txt = svg.append(\"text\")\r\n          .attr(\"y\", ty)\r\n          .attr(\"x\", tx)\r\n          .attr(\"id\", `${idN}_${t}`)\r\n          .attr(\"fill\", fill)\r\n          .attr(\"font-size\", fontsize)\r\n          .style(\"text-anchor\", \"middle\")\r\n          .text(pretext)\r\n        let textWidth = document.getElementById(`${idN}_${t}`).getBBox().width;\r\n        if ((textWidth > width) || (t == txts.length - 1)) {\r\n          pretext = '';\r\n          tx = x;\r\n          ty += 25;\r\n        }\r\n        else {\r\n          txt.remove()\r\n        }\r\n        preWidth += textWidth;\r\n      }\r\n    },\r\n    drawTimeLine(svg, path, stroke, width, stroke_dasharray = \"0\", idName, className) {\r\n      svg.append('path')\r\n        .attr('d', path.toString())\r\n        .attr('stroke', stroke)\r\n        .attr('class', className)\r\n        .attr('id', idName)\r\n        .attr(\"stroke-dasharray\", stroke_dasharray)\r\n        .attr('stroke-width', width)\r\n        .attr('fill', 'none')\r\n        .on('mouseover', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let idN = thisSelect.attr(\"id\");\r\n          if (classN.split(\" \")[0] == \"basicRel\") {\r\n            d3.select(this).attr(\"class\", classN + \" activeS\");\r\n          }\r\n        })\r\n        .on('mouseleave', function (d) {\r\n          let thisSelect = d3.select(this)\r\n          let classN = thisSelect.attr(\"class\");\r\n          let classNList = classN.split(\" \")\r\n          if (classNList[classNList.length - 1] == \"activeS\") {\r\n            classN = \"\";\r\n            for (let i = 0; i < classNList.length - 1; i++) {\r\n              classN += classNList[i] + \" \";\r\n            }\r\n            d3.select(this).attr(\"class\", classN);\r\n          }\r\n        })\r\n    },\r\n    transformGraphSvg(flag) {\r\n      const _this = this;\r\n      let groups = _this.groupsSvg;\r\n\r\n      let scalePre = _this.graphSvgScale;\r\n\r\n      let margin = _this.margin;\r\n      if (flag == 'left') {\r\n        _this.graphGTransformX += 10;\r\n      }\r\n      if (flag == 'right') {\r\n        _this.graphGTransformX -= 10;\r\n      }\r\n      // groups.attr('transform', 'translate(' + (_this.graphGTransformX) + ',' + (margin.top) + ') scale(' + (scalePre) + ')')\r\n    },\r\n    updataAssistGraphPanel() {\r\n      const _this = this;\r\n      var content = this.groupsSvg.html();\r\n      let height = document.getElementById(\"assistGraphPanel\").clientHeight;\r\n      let width = document.getElementById(\"assistGraphPanel\").clientWidth;\r\n      d3.select('#assistGraphPanel').select('svg').remove();\r\n      let transX = _this.assistGTransformX;\r\n      let transY = _this.assistGTransformY;\r\n      var div = d3.select('#assistGraphPanel')\r\n        .append('svg')\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height)\r\n        .append(\"g\")\r\n        .attr(\"transform\", `translate(${transX},${transY})`)\r\n        .html(content);\r\n    },\r\n    moveGraphLeft(e) {\r\n      const _this = this;\r\n      _this.moveFlag == true;\r\n      clearInterval(this.moveTimer)// 清除定时器\r\n      this.moveTimer = setInterval(() => { _this.transformGraphSvg(\"left\") }, 10)//_this.transformGraphSvg('left'), 100);\r\n    },\r\n    moveGraphRight(e) {\r\n      const _this = this;\r\n      // console.log(\"⚡🐲🫧❄️👁️\",e)\r\n      clearInterval(this.moveTimer)// 清除定时器\r\n      _this.moveFlag == true;\r\n      this.moveTimer = setInterval(() => { _this.transformGraphSvg(\"right\") }, 10)//_this.transformGraphSvg('left'), 100);\r\n    },\r\n    leaveGraphMove() {\r\n      // this.moveFlag == false;\r\n      clearInterval(this.moveTimer)// 清除定时器\r\n      // this.graphGTransformX = 0;\r\n    },\r\n    updataGraph() {\r\n      var _this = this;\r\n      let margin = _this.margin\r\n      let width = _this.$refs.graphDiv.offsetWidth - margin.left - margin.right;\r\n      let height = document.getElementById(\"graphPanel\").clientHeight - margin.top - margin.bottom;\r\n      let heightTimeAxis = document.getElementById(\"graphTimeAxisPanel\").clientHeight - margin.top - margin.bottom;\r\n      _this.width = width;\r\n      _this.height = height;\r\n      d3.select(\"#graphPanel\").select(\"svg\").remove()\r\n      var svg = d3.select(\"#graphPanel\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      _this.rootSvg = svg;\r\n      d3.select(\"#graphTimeAxisPanel\").select(\"svg\").remove()\r\n      var TimeAxisSvg = d3.select(\"#graphTimeAxisPanel\").append(\"svg\")\r\n        .attr(\"width\", width)\r\n        .attr(\"height\", height);\r\n      _this.TimeAxisSvg = TimeAxisSvg;\r\n      let data = _this.data;\r\n\r\n      let maxDImportance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let minDImportance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['importance']; }))\r\n      let maxDRelevance = Math.max.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let minDRelevance = Math.min.apply(Math, data.map(function (d) { return d['attribute']['relevance']; }))\r\n      let maxDDuration = Math.max.apply(Math, data.map(function (d) { return tools.time2seconds(d['time'][1]) - tools.time2seconds(d['time'][0]); }))\r\n      let maxTotalDuration = Math.max.apply(Math, data.map(function (d) { return d['totalDuration']; }))\r\n      _this.drawEntityLocation = [];\r\n      _this.minDImportance = minDImportance;\r\n      _this.maxDImportance = maxDImportance;\r\n      _this.minDRelevance = minDRelevance;\r\n      _this.maxDRelevance = maxDRelevance;\r\n      _this.maxDDuration = maxDDuration;\r\n      _this.maxTotalDuration = maxTotalDuration;\r\n\r\n      let currentMaxColor = _this.importanceMaxColor;\r\n      let currentMinColor = _this.importanceMinColor;\r\n      _this.importanceColor_linear = d3.scaleLinear().domain([minDImportance, maxDImportance]).range([0, 1]);\r\n      _this.importanceCompute_color = d3.interpolate(currentMinColor, currentMaxColor);\r\n      _this.relevanceScale_linear = d3.scaleLinear([minDRelevance, maxDRelevance], [20, 50])\r\n      _this.totalDurationScale_linear = d3.scaleLinear().domain([0, maxTotalDuration]).range([20, 60]);\r\n\r\n      _this.drawMain(svg);\r\n      // });\r\n    },\r\n    zoomInLayoutClk() {\r\n      const _this = this;\r\n      _this.layoutShow += 1;\r\n      if (_this.layoutShow > 3) {\r\n        _this.layoutShow = 3;\r\n      }\r\n      // _this.updataGraph();\r\n    },\r\n    zoomOutLayoutClk() {\r\n      const _this = this;\r\n      _this.layoutShow -= 1;\r\n      if (_this.layoutShow < 0) {\r\n        _this.layoutShow = 0;\r\n      }\r\n      // _this.updataGraph();\r\n\r\n    },\r\n    click_Ent(time) {\r\n      this.$emit(\"timeDur\", time);\r\n    },\r\n  },\r\n  created() {\r\n    var _this = this;\r\n    let margin = _this.margin\r\n    this.$nextTick(() => {\r\n      _this.updataGraph();\r\n      _this.updataAssistGraphPanel();\r\n    });\r\n  },\r\n  mounted() {\r\n    const _this = this;\r\n    let width = _this.$refs.graphDiv.offsetWidth;\r\n    let height = _this.height;\r\n    let showEntityList = tools.deepClone(_this.data);\r\n    for (let e in showEntityList) {\r\n      showEntityList[e]['show'] = true;\r\n    }\r\n    _this.showEntityList = showEntityList;\r\n    // let width = _this.width;\r\n    this.$bus.$on('graphData', (val) => {\r\n      _this.data = val;\r\n      let showEntityList = tools.deepClone(_this.data);\r\n      for (let e in showEntityList) {\r\n        showEntityList[e]['show'] = true;\r\n      }\r\n      _this.showEntityList = showEntityList;\r\n      _this.updataGraph();\r\n    });\r\n\r\n    // this.$refs.moveGraphLeft.addEventListener(\"mouseover\", _this.moveGraphLeft); // 监听点击事件\r\n    // this.$refs.moveGraphRight.addEventListener(\"mousemove\", _this.moveGraphRight); // 监听点击事件\r\n    // this.$refs.moveGraphLeft.addEventListener(\"mouseleave\", _this.leaveGraphMove); // 监听点击事件\r\n    // this.$refs.moveGraphRight.addEventListener(\"mouseleave\", _this.leaveGraphMove); // 监听点击事件\r\n\r\n  },\r\n  beforeDestroy() {\r\n    clearInterval(this.moveTimer);\r\n  },\r\n} \r\n</script>\r\n\r\n<style>\r\n@import './index.css';\r\n</style>\r\n"]}]}